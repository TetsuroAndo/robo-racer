# Architecture Overview — Robo Racer

## 目的 / Why this exists
このリポジトリは、**小型自動運転カーを「安全に・早く・再現性高く」走らせる**ための
フルスタック構成です。目的は単なるデモではなく、次の3点を満たすことです。

1. **低遅延で安全**: 走行の最終判断とモータ制御はESP32が担当し、緊急停止を最優先にする。
2. **高レベル知能の拡張性**: RPi側で認識・戦術・経路計画を入れ替え可能にする。
3. **学習パイプラインの再現性**: 学習→モデル管理→実機投入が1本の流れで回る状態にする。

---

## 現状の全体アーキテクチャ（ハード + ソフト）

```
  Sensors (TSD20 / IMU / Camera*)          *camera/2D LiDAR are planned
                 |
                 v
  RPi5 (Python runtime: perception/control/driver)
                 |
        COBS + CRC16 (UART)
                 |
                 v
  ESP32 (firmware: state machine + motion control)
                 |
                 v
           Motor / Servo
```

- **ESP32 (firmware/)**: 低レベル制御の最終責任者。安全停止・基礎センサ処理・モータ制御を担う。
- **RPi5 (src/)**: 高レベル判断（認識、戦術、経路計画）を担う想定。現在は最小構成。
- **Training (training/)**: データ整備・学習・モデル生成。現時点は雛形のみ。
- **Config / Models**: 実機と学習の共通設定・モデルの管理（README記載に準拠）。

---

## RPiランタイム（Python, src/）の役割

想定される責務は次の通り。現時点では構造のみで、ロジックはこれから実装する段階。

- **perception/**: カメラ/2D LiDAR入力、モデル推論、地物推定。
- **control/**: 高レベル制御（速度目標、戦術決定、回避方針）。
- **driver/**: ESP32との通信ドライバ（プロトコル実装）。
- **common/**: 型定義・共有ユーティリティ。

**意図**: RPi側を「交換可能な頭脳」にして、ESP32は常に安全な足回りであることを保証する。

---

## ESP32ファームウェア（firmware/）の役割

現在の実装は **安全走行の最小セット** に集中しています。

- **app/App**: ループ全体の統括。センサ更新 → コマンド反映 → 状態遷移 → 出力 → テレメトリ送信。
- **control/**:
  - `Strategy`: 自律走行の簡易戦略（Cruise / Brake / Reverse / Turn）。
  - `MotionController`: 直進保持（Yaw P制御）とスロットルのスルーレート制限。
  - `State`: 走行モード・E-Stop・右左優先の保持。
- **hardware/**:
  - `Tsd20`: 1D LiDAR距離取得。
  - `Imu`: MPU6050のYaw推定。
  - `MotorDriver` / `ServoSteering`: モータ・サーボ制御。
- **comm/**:
  - COBSフレーミング + CRC16のバイナリプロトコル。
  - RPiからの `SetMode / SetManual / SetPrefer / Estop` 等を受信。
  - `Status` テレメトリを送信。

---

## 制御フロー（現状）

1. **センサ更新**: TSD20距離、IMU yaw/yawRate を取得。
2. **ホストコマンド反映**: RPiからのモード/操作/優先方向/E-Stopを反映。
3. **状態機械**:
   - `Idle`: 停止
   - `Manual`: RPi指令を安全制約付きで適用
   - `Auto`: 障害物回避の最小戦略
4. **モーション制御**: ヘディング保持 + スルーレート制限。
5. **安全クランプ**: 距離閾値以下は必ず停止。
6. **テレメトリ送信**: RPiへ状態送信。

---

## 通信インターフェース（RPi ↔ ESP32）

- **物理層**: UART
- **フレーミング**: COBS
- **検査**: CRC16-CCITT
- **主要メッセージ**:
  - `SetMode` (Idle/Manual/Auto)
  - `SetManual` (throttle/steer)
  - `SetPrefer` (右/左優先)
  - `Estop` / `ClearEstop`
  - `Status` (距離, yaw, コマンド出力, loopHz)

**設計意図**: 低遅延・堅牢なバイナリ通信で、RPi側のアルゴリズムを自由に入れ替える。

---

## 安全設計（現状）

- **E-Stopは常に最優先**（即座にスロットル0、操舵センター）。
- **距離閾値による停止**（TSD20が近距離を検知したら強制停止）。
- **ホスト監視**: Manualモードでハートビート途絶なら停止。

---

## 学習・モデル運用（想定）

```
training/data -> training/src -> models/production -> RPi推論
```

- **training/** で学習・解析を行い、実機で使うモデルを `models/production/` に配置。
- RPiはモデルを読み込み、推論結果を戦術・速度目標に変換する。

---

## プロジェクト全体で「何をしたいのか」

このプロジェクトの最終的な狙いは、以下の状態に到達することです。

1. **安全に走るベースラインの確立**
   - ESP32単体でも安全に走れる最低限の自律走行を保持。
2. **RPiで高レベル戦術を実装**
   - 2D LiDAR/カメラから進行方向判断、速度調整、回避方針の変更。
3. **学習と実機のギャップを埋める**
   - 学習データの整備、推論モデルの更新、実機での検証ループを確立。
4. **モジュール分離で進化し続ける**
   - センサ/戦術/モデルが入れ替え可能な構造にして、継続的に強くする。

---

## 既知の未実装 / 今後の埋めどころ

- RPi側の通信実装（Protocol.h準拠の送受信）
- perception/control の具体ロジック
- training パイプラインの実装とデータ仕様
- config/ の実データ化（車体パラメータ、学習ハイパーパラメータ）

