Directory structure of: .
----------------------------------------
./
├── AGENTS.md
├── cad/
│   └── kicad/
│       ├── car.kicad_pcb
│       ├── car.kicad_prl
│       ├── car.kicad_pro
│       └── car.kicad_sch
├── code.txt
├── docs/
│   ├── architecture/
│   │   ├── overview.md
│   │   └── test_design.md
│   ├── contracts/
│   │   ├── bag_ops_v0.1.md
│   │   ├── ipc_uds_v0.1.md
│   │   ├── mc_bridge_v0.1.md
│   │   ├── min_spec_v0_1.md
│   │   └── ros_topics_v0.1.md
│   ├── firmware/
│   │   ├── hils_guide.md
│   │   ├── hils_plan.md
│   │   ├── log_guide.md
│   │   ├── log_plan.md
│   │   └── plan.md
│   ├── interfaces/
│   │   ├── ipc_payloads_v1.md
│   │   ├── ipc_topics_v1.md
│   │   └── protocol_rpi_esp32_v1.md
│   ├── ml/
│   │   ├── dataset_schema_v1.md
│   │   └── policy_plugin_v1.md
│   ├── observability/
│   │   └── logging_v1.md
│   ├── ops/
│   │   ├── monitoring_thresholds_v1.md
│   │   └── systemd_v1.md
│   ├── planning/
│   │   ├── a_min_spec_implementation_status.md
│   │   ├── a_min_spec_plan.md
│   │   ├── bc_taskflow_implementation_status.md
│   │   ├── bc_taskflow_plan.md
│   │   ├── dir_utils_status.md
│   │   ├── ftg_v1.md
│   │   ├── hils_e2e_status.md
│   │   ├── interface_freeze_status.md
│   │   ├── lidar_received_eintr_status.md
│   │   ├── lidar_received_logging_status.md
│   │   ├── lidar_shm_integration_status.md
│   │   ├── mc_bridge_status.md
│   │   ├── p0_branch_test_memo.md
│   │   ├── p0_parallelization_status.md
│   │   ├── process_decision_telemetry_status.md
│   │   ├── role_definitions_v1.md
│   │   ├── ros2_bag_session_status.md
│   │   ├── ros2_env_status.md
│   │   ├── ros2_novnc_bind_bag_ops_status.md
│   │   ├── ros2_novnc_trap_status.md
│   │   ├── ros2_param_validation_status.md
│   │   ├── ros2_xdg_runtime_dir_status.md
│   │   └── telemetry_tcp_bridge_status.md
│   ├── proto/
│   │   ├── log_transport.md
│   │   ├── overview.md
│   │   ├── protocol_logging_plan.md
│   │   └── test_plan.md
│   ├── ros2/
│   │   ├── bag_ops.md
│   │   ├── dev_env.md
│   │   └── topic_spec.md
│   ├── slam/
│   │   └── ros2_setup_v1.md
│   └── testing/
│       ├── hils_e2e_plan.md
│       └── hils_v1.md
├── firmware/
│   ├── lib/
│   │   ├── common/
│   │   │   ├── Math.h
│   │   │   ├── Result.h
│   │   │   ├── SlewRateLimiter.h
│   │   │   └── Time.h
│   │   └── library.json
│   ├── PLATFORMIO_SNIPPET.ini
│   ├── src/
│   │   ├── comm/
│   │   │   ├── handlers/
│   │   │   │   ├── DriveHandler.cpp
│   │   │   │   ├── KillHandler.cpp
│   │   │   │   ├── ModeHandler.cpp
│   │   │   │   └── PingHandler.cpp
│   │   │   ├── registry.cpp
│   │   │   ├── registry.h
│   │   │   ├── UartTx.cpp
│   │   │   └── UartTx.h
│   │   ├── config/
│   │   │   └── Config.h
│   │   ├── control/
│   │   │   ├── ControllerInput.cpp
│   │   │   └── ControllerInput.h
│   │   ├── hardware/
│   │   │   ├── Drive.cpp
│   │   │   ├── Drive.h
│   │   │   ├── Engine.cpp
│   │   │   ├── Engine.h
│   │   │   ├── Steer.cpp
│   │   │   └── Steer.h
│   │   ├── log/
│   │   │   ├── AsyncLogger.cpp
│   │   │   └── AsyncLogger.h
│   │   └── main.cpp
│   └── test/
│       └── test_mc_proto/
│           └── test_main.cpp
├── LICENSE
├── logs/
├── Makefile
├── platformio.ini
├── pyproject.toml
├── README.md
├── rpi/
│   ├── apps/
│   │   ├── lidar_received/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config/
│   │   │   │   └── Config.h
│   │   │   ├── lidar_recieiver.h
│   │   │   ├── LidarScanData.cpp
│   │   │   ├── LidarScanData.hpp
│   │   │   └── main.cpp
│   │   ├── metricsd/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config/
│   │   │   │   └── Config.h
│   │   │   └── src/
│   │   │       └── main.cpp
│   │   ├── serialctl/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config/
│   │   │   │   └── Config.h
│   │   │   └── main.cpp
│   │   ├── seriald/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config/
│   │   │   │   └── Config.h
│   │   │   ├── Makefile
│   │   │   ├── seriald_client.py
│   │   │   └── src/
│   │   │       ├── async_logger.cpp
│   │   │       ├── async_logger.h
│   │   │       ├── main.cpp
│   │   │       ├── sink_file.cpp
│   │   │       ├── sink_file.h
│   │   │       ├── sink_stdout.cpp
│   │   │       └── sink_stdout.h
│   │   └── sim_esp32d/
│   │       ├── CMakeLists.txt
│   │       ├── config/
│   │       │   └── Config.h
│   │       └── src/
│   │           └── main.cpp
│   ├── CMakeLists.txt
│   ├── config/
│   │   └── frames.yaml
│   ├── lib/
│   │   ├── mc_core/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── include/
│   │   │   │   └── mc/
│   │   │   │       └── core/
│   │   │   │           ├── Endian.hpp
│   │   │   │           ├── Log.hpp
│   │   │   │           ├── Path.hpp
│   │   │   │           ├── Process.hpp
│   │   │   │           ├── Result.hpp
│   │   │   │           └── Time.hpp
│   │   │   └── src/
│   │   │       ├── Log.cpp
│   │   │       ├── Process.cpp
│   │   │       └── Time.cpp
│   │   ├── mc_ipc/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── include/
│   │   │   │   └── mc/
│   │   │   │       └── ipc/
│   │   │   │           └── UdsSeqPacket.hpp
│   │   │   └── src/
│   │   │       └── UdsSeqPacket.cpp
│   │   ├── mc_proto/
│   │   │   └── CMakeLists.txt
│   │   ├── mc_serial/
│   │   │   ├── CMakeLists.txt
│   │   │   ├── include/
│   │   │   │   └── mc/
│   │   │   │       └── serial/
│   │   │   │           └── Uart.hpp
│   │   │   └── src/
│   │   │       └── Uart.cpp
│   │   └── rplidar_sdk/
│   ├── models/
│   │   ├── archive/
│   │   └── production/
│   ├── ros2_ws/
│   │   └── src/
│   │       ├── lidar_bridge/
│   │       │   ├── lidar_bridge/
│   │       │   │   ├── __init__.py
│   │       │   │   └── bridge_node.py
│   │       │   ├── package.xml
│   │       │   ├── resource/
│   │       │   │   └── lidar_bridge
│   │       │   ├── setup.cfg
│   │       │   └── setup.py
│   │       ├── mc_bridge/
│   │       │   ├── mc_bridge/
│   │       │   │   ├── __init__.py
│   │       │   │   ├── bridge_node.py
│   │       │   │   └── mc_proto_codec.py
│   │       │   ├── package.xml
│   │       │   ├── resource/
│   │       │   │   └── mc_bridge
│   │       │   ├── setup.cfg
│   │       │   └── setup.py
│   │       ├── mc_demo_pub/
│   │       │   ├── mc_demo_pub/
│   │       │   │   ├── __init__.py
│   │       │   │   └── demo_pub_node.py
│   │       │   ├── package.xml
│   │       │   ├── resource/
│   │       │   │   └── mc_demo_pub
│   │       │   └── setup.py
│   │       ├── mc_msgs/
│   │       │   ├── CMakeLists.txt
│   │       │   ├── msg/
│   │       │   │   ├── DriveCmd.msg
│   │       │   │   ├── HilsState.msg
│   │       │   │   ├── LogRecord.msg
│   │       │   │   └── Status.msg
│   │       │   └── package.xml
│   │       └── mc_tf_static/
│   │           ├── mc_tf_static/
│   │           │   ├── __init__.py
│   │           │   └── static_tf_node.py
│   │           ├── package.xml
│   │           ├── resource/
│   │           │   └── mc_tf_static
│   │           └── setup.py
│   ├── src/
│   │   ├── CMakeLists.txt
│   │   ├── config/
│   │   │   └── Config.h
│   │   ├── lidar_to_esp.cpp
│   │   ├── lidar_to_esp.h
│   │   ├── LidarReceiver.cpp
│   │   ├── LidarReceiver.h
│   │   ├── main.cpp
│   │   ├── Process.cpp
│   │   ├── Process.h
│   │   ├── Sender.cpp
│   │   ├── Sender.h
│   │   ├── ShmLidarReceiver.cpp
│   │   ├── ShmLidarReceiver.h
│   │   ├── Telemetry.cpp
│   │   └── Telemetry.h
│   └── training/
│       ├── data/
│       │   ├── processed/
│       │   └── raw/
│       ├── notebooks/
│       └── src/
│           └── __init__.py
├── shared/
│   └── proto/
│       ├── include/
│       │   ├── mc/
│       │   │   └── proto/
│       │   │       ├── Ack.hpp
│       │   │       └── Proto.hpp
│       │   └── mc_proto.h
│       ├── library.json
│       └── src/
│           └── mcproto.cpp
├── test/
│   ├── firmware/
│   │   ├── comm/
│   │   │   ├── cpp/
│   │   │   │   ├── comm_integration_tests.cpp
│   │   │   │   └── UartTx_stub.cpp
│   │   │   ├── include/
│   │   │   │   └── Arduino.h
│   │   │   ├── test_comm_integration_cpp.py
│   │   │   └── test_placeholder.py
│   │   └── proto/
│   │       ├── cpp/
│   │       │   └── proto_tests.cpp
│   │       └── test_proto_firmware_cpp.py
│   └── rpi/
│       ├── comm/
│       │   ├── cpp/
│       │   │   └── sender_tests.cpp
│       │   ├── test_placeholder.py
│       │   └── test_sender_cpp.py
│       ├── hils/
│       │   ├── cpp/
│       │   │   └── racerd_stub.cpp
│       │   └── test_hils_e2e.py
│       ├── mc_proto/
│       │   ├── cpp/
│       │   │   └── proto_tests.cpp
│       │   └── test_mc_proto_cpp.py
│       ├── proto/
│       │   ├── cpp/
│       │   │   └── proto_tests.cpp
│       │   └── test_proto_rpi_cpp.py
│       └── seriald/
│           └── test_seriald_integration.py
└── uv.lock

113 directories, 204 files
----------------------------------------

----------------------------------------
File: firmware/PLATFORMIO_SNIPPET.ini
----------------------------------------
; Merge these lines into your project's platformio.ini.
; This firmware assumes ESP32 DevKitC (WROOM-32D) Arduino framework.

[env:esp32dev]
platform = espressif32
board = esp32dev
framework = arduino

monitor_speed = 115200

; Prefer managing deps with lib_deps; if you vendor libs under firmware/lib/external,
; you can omit these and point lib_extra_dirs to that folder.
lib_deps =
  h2zero/NimBLE-Arduino @ ^1.4.1

; Local libraries
lib_extra_dirs =
  firmware/lib
----------------------------------------

----------------------------------------
File: firmware/test/test_mc_proto/test_main.cpp
----------------------------------------
#include <Arduino.h>
#include <unity.h>
#include <mc/proto/Proto.hpp>
static void test_crc16_vector() {
	const uint8_t data[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
	const uint16_t crc = mc::proto::crc16_ccitt(data, sizeof(data));
	TEST_ASSERT_EQUAL_HEX16(0x29B1, crc);
}
static void test_packet_roundtrip() {
	const uint8_t payload[2] = {0x01, 0x00};
	uint8_t encoded[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		encoded, sizeof(encoded), out_len, mc::proto::Type::PING, 0, 0x1234,
		payload, static_cast< uint16_t >(sizeof(payload)));
	TEST_ASSERT_TRUE(ok);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < out_len; ++i) {
		reader.push(encoded[i]);
	}
	TEST_ASSERT_TRUE(reader.hasFrame());
	const auto &frame = reader.frame();
	TEST_ASSERT_EQUAL_UINT8(mc::proto::VERSION, frame.ver());
	TEST_ASSERT_EQUAL_UINT8(static_cast< uint8_t >(mc::proto::Type::PING),
							frame.type());
	TEST_ASSERT_EQUAL_UINT16(0x1234, frame.seq());
	TEST_ASSERT_EQUAL_UINT16(sizeof(payload), frame.len());
	TEST_ASSERT_EQUAL_UINT16(sizeof(payload), frame.payload_len);
	TEST_ASSERT_EQUAL_UINT8_ARRAY(payload, frame.payload, sizeof(payload));
}
void setup() {
	UNITY_BEGIN();
	RUN_TEST(test_crc16_vector);
	RUN_TEST(test_packet_roundtrip);
	UNITY_END();
}
void loop() {}
----------------------------------------

----------------------------------------
File: firmware/lib/common/Time.h
----------------------------------------
#pragma once
#include <Arduino.h>
#include <stdint.h>
namespace mc {
struct Time {
  static inline uint32_t ms() { return (uint32_t)millis(); }
  static inline uint64_t us() { return (uint64_t)micros(); }
};
class PeriodicTimer {
 public:
  explicit PeriodicTimer(uint32_t period_ms = 1000) : _period(period_ms), _next(0) {}
  void setPeriod(uint32_t period_ms) { _period = period_ms; }
  void reset(uint32_t now_ms) { _next = now_ms + _period; }
  bool due(uint32_t now_ms) {
    if ((int32_t)(now_ms - _next) >= 0) { _next += _period; return true; }
    return false;
  }
 private:
  uint32_t _period;
  uint32_t _next;
};
} 
----------------------------------------

----------------------------------------
File: firmware/lib/common/SlewRateLimiter.h
----------------------------------------
#pragma once
#include <stdint.h>
namespace mc {
class SlewRateLimiter {
 public:
  SlewRateLimiter(float rate_up, float rate_down, float initial = 0.0f)
  : _rateUp(rate_up), _rateDown(rate_down), _y(initial) {}
  void reset(float v) { _y = v; }
  float value() const { return _y; }
  float update(float target, float dt_s) {
    const float dy = target - _y;
    const float maxUp = _rateUp * dt_s;
    const float maxDn = _rateDown * dt_s;
    if (dy > maxUp) _y += maxUp;
    else if (dy < -maxDn) _y -= maxDn;
    else _y = target;
    return _y;
  }
 private:
  float _rateUp;
  float _rateDown;
  float _y;
};
} 
----------------------------------------

----------------------------------------
File: firmware/lib/common/Result.h
----------------------------------------
#pragma once
#include <stdint.h>
namespace mc {
enum class Errc : uint8_t {
  Ok = 0,
  Timeout,
  Bus,
  Invalid,
  NotReady,
  Range,
  Internal
};
struct Result {
  Errc code;
  const char* msg;   
  constexpr bool ok() const { return code == Errc::Ok; }
  static constexpr Result Ok() { return {Errc::Ok, ""}; }
  static constexpr Result Fail(Errc c, const char* m) { return {c, m}; }
};
} 
----------------------------------------

----------------------------------------
File: firmware/lib/common/Math.h
----------------------------------------
#pragma once
#include <cmath>
namespace mc {
template <typename T>
static inline T clamp(T v, T lo, T hi) {
  return (v < lo) ? lo : (v > hi) ? hi : v;
}
static constexpr float kPi = 3.14159265358979323846f;
static inline float deg2rad(float d) { return d * kPi / 180.0f; }
static inline float rad2deg(float r) { return r * 180.0f / kPi; }
static inline float wrapDeg180(float deg) {
  while (deg >= 180.0f) deg -= 360.0f;
  while (deg < -180.0f) deg += 360.0f;
  return deg;
}
} 
----------------------------------------

----------------------------------------
File: firmware/lib/library.json
----------------------------------------
{
  "name": "mc_common",
  "version": "0.1.0",
  "description": "Common utilities for TOYOTA42 mini-car firmware",
  "keywords": "common, utilities, embedded",
  "authors": [
    { "name": "TOYOTA42 team" }
  ],
  "license": "MIT",
  "frameworks": ["arduino"],
  "platforms": ["espressif32"]
}
----------------------------------------

----------------------------------------
File: firmware/src/hardware/Engine.h
----------------------------------------
#pragma once
#include <Arduino.h>
#include "../../lib/common/SlewRateLimiter.h"
class Engine {
public:
	void begin();
	void setTarget(int speed_pwm);
	void stop();
	void control(float dt_s);
	int current() const { return _cur; }
	int target() const { return _tgt; }
private:
	int _cur = 0;
	int _tgt = 0;
	mc::SlewRateLimiter _lim{800.0f, 1200.0f, 0.0f};
	void applyPWM(uint8_t rpwm, uint8_t lpwm);
	void outputSpeed(int cur);
};
----------------------------------------

----------------------------------------
File: firmware/src/hardware/Drive.h
----------------------------------------
#pragma once
#include "Engine.h"
#include "Steer.h"
#include <Arduino.h>
class Drive {
public:
	void begin();
	void setTargetMmS(int16_t speed_mm_s);
	void setTargetSteerCdeg(int16_t steer_cdeg);
	void setTtlMs(uint16_t ttl_ms);
	void setDistMm(uint16_t dist_mm);
	void tick(uint32_t now_ms, float dt_s, bool killed);
	int16_t appliedSpeedMmS() const { return _applied_speed_mm_s; }
	int16_t appliedSteerCdeg() const { return _applied_steer_cdeg; }
	uint16_t ttlMs() const { return _ttl_ms; }
	uint16_t distMm() const { return _dist_mm; }
	uint32_t lastUpdateMs() const { return _lastUpdateMs; }
private:
	Engine _engine;
	Steer  _steer;
	int16_t _tgt_speed_mm_s = 0;
	int16_t _tgt_steer_cdeg = 0;
	uint16_t _ttl_ms = 100;
	uint16_t _dist_mm = 0;
	int16_t _applied_speed_mm_s = 0;
	int16_t _applied_steer_cdeg = 0;
	uint32_t _lastUpdateMs = 0;
	static constexpr int MAX_SPEED_MM_S = 2000;
	int speedMmSToPwm_(int16_t mm_s) const;
	float steerCdegToDeg_(int16_t cdeg) const;
};
----------------------------------------

----------------------------------------
File: firmware/src/hardware/Drive.cpp
----------------------------------------
#include "Drive.h"
#include "../../lib/common/Math.h"
void Drive::begin() {
	_engine.begin();
	_steer.begin();
	_lastUpdateMs = millis();
}
void Drive::setTargetMmS(int16_t speed_mm_s) {
	_tgt_speed_mm_s = speed_mm_s;
	_lastUpdateMs = millis();
}
void Drive::setTargetSteerCdeg(int16_t steer_cdeg) {
	_tgt_steer_cdeg = steer_cdeg;
	_lastUpdateMs = millis();
}
void Drive::setTtlMs(uint16_t ttl_ms) {
	_ttl_ms = ttl_ms;
	_lastUpdateMs = millis();
}
void Drive::setDistMm(uint16_t dist_mm) {
	_dist_mm = dist_mm;
	_lastUpdateMs = millis();
}
int Drive::speedMmSToPwm_(int16_t mm_s) const {
	int v = (int)mm_s;
	v = mc::clamp< int >(v, -MAX_SPEED_MM_S, MAX_SPEED_MM_S);
	long pwm = (long)v * 255L / (long)MAX_SPEED_MM_S;
	return (int)mc::clamp< long >(pwm, -255, 255);
}
float Drive::steerCdegToDeg_(int16_t cdeg) const {
	float deg = (float)cdeg / 100.0f;
	return mc::clamp< float >(deg, -30.0f, 30.0f);
}
void Drive::tick(uint32_t now_ms, float dt_s, bool killed) {
	bool expired = ((uint32_t)(now_ms - _lastUpdateMs) > (uint32_t)_ttl_ms);
	int16_t cmd_speed = (killed || expired) ? 0 : _tgt_speed_mm_s;
	int16_t cmd_steer = (killed || expired) ? 0 : _tgt_steer_cdeg;
	_applied_speed_mm_s = cmd_speed;
	_applied_steer_cdeg = cmd_steer;
	_engine.setTarget(speedMmSToPwm_(cmd_speed));
	_engine.control(dt_s);
	_steer.setAngle(steerCdegToDeg_(cmd_steer));
}
----------------------------------------

----------------------------------------
File: firmware/src/hardware/Steer.h
----------------------------------------
#pragma once
#include <Arduino.h>
class Steer {
public:
  void begin();
  void center();
  void left();
  void right();
  void setAngle(float angle);
private:
  void writePulseUs_(int us);
};
----------------------------------------

----------------------------------------
File: firmware/src/hardware/Engine.cpp
----------------------------------------
#include "Engine.h"
#include "../config/Config.h"
void Engine::begin() {
	pinMode(cfg::ENGINE_PIN_REN, OUTPUT);
	pinMode(cfg::ENGINE_PIN_LEN, OUTPUT);
	digitalWrite(cfg::ENGINE_PIN_REN, HIGH);
	digitalWrite(cfg::ENGINE_PIN_LEN, HIGH);
	ledcSetup(cfg::ENGINE_CHANNEL_RPWM, cfg::ENGINE_PWM_FREQ_HZ,
			  cfg::ENGINE_PWM_RES_BITS);
	ledcSetup(cfg::ENGINE_CHANNEL_LPWM, cfg::ENGINE_PWM_FREQ_HZ,
			  cfg::ENGINE_PWM_RES_BITS);
	ledcAttachPin(cfg::ENGINE_PIN_RPWM, cfg::ENGINE_CHANNEL_RPWM);
	ledcAttachPin(cfg::ENGINE_PIN_LPWM, cfg::ENGINE_CHANNEL_LPWM);
	stop();
}
void Engine::applyPWM(uint8_t rpwm, uint8_t lpwm) {
	ledcWrite(cfg::ENGINE_CHANNEL_RPWM, rpwm);
	ledcWrite(cfg::ENGINE_CHANNEL_LPWM, lpwm);
}
void Engine::outputSpeed(int cur) {
	digitalWrite(cfg::ENGINE_PIN_REN, HIGH);
	digitalWrite(cfg::ENGINE_PIN_LEN, HIGH);
	if (cur > 0)
		applyPWM((uint8_t)cur, 0);
	else if (cur < 0)
		applyPWM(0, (uint8_t)(-cur));
	else
		applyPWM(0, 0);
}
void Engine::setTarget(int speed_pwm) {
	_tgt =
		constrain(speed_pwm, -cfg::ENGINE_SPEED_LIMIT, cfg::ENGINE_SPEED_LIMIT);
}
void Engine::control(float dt_s) {
	float y = _lim.update((float)_tgt, dt_s);
	int next = (int)lroundf(y);
	next = constrain(next, -cfg::ENGINE_SPEED_LIMIT, cfg::ENGINE_SPEED_LIMIT);
	if (next != _cur) {
		_cur = next;
		outputSpeed(_cur);
	}
}
void Engine::stop() {
	_tgt = 0;
	_cur = 0;
	_lim.reset(0.0f);
	applyPWM(0, 0);
}
----------------------------------------

----------------------------------------
File: firmware/src/hardware/Steer.cpp
----------------------------------------
#include "Steer.h"
#include "../config/Config.h"
namespace {
float lerp(float start, float end, float t) {
	return (1 - t) * start + t * end;
}
} 
void Steer::begin() {
	ledcSetup(cfg::STEER_CHANNEL, cfg::STEER_PWM_FREQ_HZ,
			  cfg::STEER_PWM_RESOLUTION_BITS);
	ledcAttachPin(cfg::STEER_PIN_SERVO, cfg::STEER_CHANNEL);
	center();
}
void Steer::writePulseUs_(int us) {
	us = constrain(us, cfg::STEER_PULSE_MIN_US, cfg::STEER_PULSE_MAX_US);
	const uint32_t period_us = cfg::STEER_PWM_PERIOD_US;
	uint32_t duty = (uint32_t)((uint64_t)us * 65535ULL / period_us);
	ledcWrite(cfg::STEER_CHANNEL, duty);
}
void Steer::setAngle(float angle) {
	if (cfg::STEER_ANGLE_RANGE_DEG < angle) {
		angle = cfg::STEER_ANGLE_RANGE_DEG;
	} else if (angle < -cfg::STEER_ANGLE_RANGE_DEG) {
		angle = -cfg::STEER_ANGLE_RANGE_DEG;
	}
	angle += cfg::STEER_ANGLE_CENTER_DEG;
	int us =
		map(angle, cfg::STEER_ANGLE_CENTER_DEG - cfg::STEER_ANGLE_RANGE_DEG,
			cfg::STEER_ANGLE_CENTER_DEG + cfg::STEER_ANGLE_RANGE_DEG,
			cfg::STEER_PULSE_MIN_US, cfg::STEER_PULSE_MAX_US);
	writePulseUs_(us);
}
void Steer::center() { setAngle(cfg::STEER_ANGLE_CENTER_DEG); }
void Steer::left() {
	setAngle(cfg::STEER_ANGLE_CENTER_DEG + cfg::STEER_ANGLE_RANGE_DEG);
}
void Steer::right() {
	setAngle(cfg::STEER_ANGLE_CENTER_DEG - cfg::STEER_ANGLE_RANGE_DEG);
}
----------------------------------------

----------------------------------------
File: firmware/src/config/Config.h
----------------------------------------
#pragma once
#include <stdint.h>
namespace cfg {
static constexpr uint32_t LOG_BAUD             = 115200;
static constexpr uint32_t LOG_STARTUP_DELAY_MS = 200;
static constexpr int SERIAL_RX_PIN             = 16;
static constexpr int SERIAL_TX_PIN             = 17;
static constexpr uint32_t SERIAL_BAUD          = 921600;
static constexpr uint32_t HEARTBEAT_TIMEOUT_MS = 200;
static constexpr uint32_t DRIVE_TIMEOUT_MS     = 250;
static constexpr int DRIVE_FRONT_AREA_DEG      = 30;
static constexpr int DRIVE_CURVE_AREA_DEG      = 70;
static constexpr int FULL_CIRCLE_DEG           = 360;
static constexpr int DRIVE_SPEED_MAX           = 255;
static constexpr int DRIVE_AVE_DEG_NUM         = 1;
static constexpr int STEER_PIN_SERVO           = 12;
static constexpr int STEER_CHANNEL             = 2;
static constexpr int STEER_PWM_FREQ_HZ         = 50;
static constexpr int STEER_PWM_RESOLUTION_BITS = 16;
static constexpr int STEER_PWM_PERIOD_US       = 1000000 / STEER_PWM_FREQ_HZ;
static constexpr int STEER_PULSE_MIN_US        = 1200;
static constexpr int STEER_PULSE_MAX_US        = 1800;
static constexpr int STEER_PULSE_CENTER_US     =
	(STEER_PULSE_MIN_US + STEER_PULSE_MAX_US) / 2;
static constexpr int STEER_ANGLE_RANGE_DEG     = 30;
static constexpr int STEER_ANGLE_CENTER_DEG    = 90;
static constexpr float STEER_CDEG_SCALE        = 100.0f;
static constexpr int ENGINE_PIN_RPWM           = 25;
static constexpr int ENGINE_PIN_LPWM           = 26;
static constexpr int ENGINE_PIN_REN            = 27;
static constexpr int ENGINE_PIN_LEN            = 14;
static constexpr int ENGINE_CHANNEL_RPWM       = 0;
static constexpr int ENGINE_CHANNEL_LPWM       = 1;
static constexpr int ENGINE_PWM_FREQ_HZ        = 20000;
static constexpr int ENGINE_PWM_RES_BITS       = 8;
static constexpr int ENGINE_SPEED_STEP         = 4;
static constexpr int ENGINE_RAMP_DELAY_MS      = 10;
static constexpr int ENGINE_SPEED_LIMIT        = 255;
static constexpr int   MANUAL_SPEED_MAX  = 180;
static constexpr int   MANUAL_SPEED_STEP = 6;
static constexpr float MANUAL_STEER_DEG  = 20.0f;
static constexpr uint32_t STATUS_INTERVAL_MS       = 50;
static constexpr bool PROTO_TRACE_ENABLE           = true;
static constexpr bool PROTO_TRACE_VERBOSE          = false;
static constexpr uint32_t PROTO_TRACE_SUMMARY_MS   = 1000;
static constexpr uint8_t ACK_CODE_OK               = 0;
static constexpr uint8_t ACK_CODE_VERSION_MISMATCH = 2;
static constexpr uint8_t ACK_CODE_INVALID_PAYLOAD  = 3;
static constexpr uint8_t ACK_CODE_UNHANDLED        = 4;
static constexpr uint8_t ACK_CODE_INVALID_TTL      = 5;
static constexpr uint8_t AUTO_CMD_SEQ_WINDOW = 128;
static constexpr uint16_t AUTO_CMD_AGE_UNKNOWN_MS = 0xFFFF;
} 
----------------------------------------

----------------------------------------
File: firmware/src/comm/UartTx.cpp
----------------------------------------
#include "UartTx.h"
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <string.h>
namespace mc {
void UartTx::begin(HardwareSerial &uart) {
	_uart = &uart;
	if (!_q) {
		_q = xQueueCreateStatic(QDEPTH, sizeof(TxMsg), _qstorage, &_qbuf);
	}
	if (!_task) {
		xTaskCreatePinnedToCore(&UartTx::txTask_, "mc_uart_tx", 4096, this, 1,
								&_task, 0);
	}
}
bool UartTx::enqueue(const uint8_t *data, uint16_t len) {
	if (!_q || !_uart)
		return false;
	if (!data || len == 0 || len > MSGMAX)
		return false;
	TxMsg m{};
	m.len = len;
	memcpy(m.data, data, len);
	if (xQueueSend(_q, &m, 0) != pdTRUE) {
		_dropped++;
		return false;
	}
	return true;
}
void UartTx::txTask_(void *arg) { static_cast< UartTx * >(arg)->txLoop_(); }
void UartTx::txLoop_() {
	while (true) {
		TxMsg m{};
		if (xQueueReceive(_q, &m, portMAX_DELAY) == pdTRUE) {
			if (_uart && m.len) {
				_uart->write(m.data, m.len);
			}
		}
	}
}
} 
----------------------------------------

----------------------------------------
File: firmware/src/comm/UartTx.h
----------------------------------------
#pragma once
#include <Arduino.h>
#include <stdint.h>
namespace mc {
class UartTx {
public:
	void begin(HardwareSerial& uart);
	bool enqueue(const uint8_t* data, uint16_t len);
	uint32_t dropped() const { return _dropped; }
private:
	HardwareSerial* _uart = nullptr;
	static constexpr int QDEPTH = 32;
	static constexpr size_t MSGMAX = 256;
	struct TxMsg {
		uint16_t len;
		uint8_t data[MSGMAX];
	};
	StaticQueue_t _qbuf{};
	uint8_t _qstorage[QDEPTH * sizeof(TxMsg)]{};
	QueueHandle_t _q = nullptr;
	TaskHandle_t _task = nullptr;
	uint32_t _dropped = 0;
	static void txTask_(void* arg);
	void txLoop_();
};
} 
----------------------------------------

----------------------------------------
File: firmware/src/comm/registry.h
----------------------------------------
#pragma once
#include "../../lib/common/Result.h"
#include <mc/proto/Proto.hpp>
#include <stdint.h>
class HardwareSerial;
namespace mc {
enum class Mode : uint8_t { MANUAL = 0, AUTO = 1 };
struct ControlState {
	volatile Mode mode = Mode::MANUAL;
	volatile bool killed = false;
	volatile uint16_t last_seq = 0;
	volatile uint32_t last_cmd_ms = 0;
	volatile uint32_t cmd_expire_ms = 0;
	volatile uint32_t last_hb_ms = 0;
	volatile int16_t target_steer_cdeg = 0;
	volatile int16_t target_speed_mm_s = 0;
	volatile uint16_t target_ttl_ms = 100;
	volatile uint16_t target_dist_mm = 0;
};
class AsyncLogger;
class UartTx;
struct Context {
	ControlState* st;
	HardwareSerial* uart;
	AsyncLogger* log;
	UartTx* tx;
};
class IHandler {
public:
	virtual ~IHandler() {}
	virtual mc::Result onFrame(const proto::FrameView& f, Context& ctx, uint32_t now_ms) = 0;
};
class Registry {
public:
	static Registry& instance();
	bool add(uint8_t type, IHandler* h);
	IHandler* get(uint8_t type);
private:
	Registry();
	static constexpr int MAX = 16;
	struct Entry { uint8_t type; IHandler* h; };
	Entry _e[MAX];
	int _n;
};
class AutoRegister {
public:
	AutoRegister(uint8_t type, IHandler* h) { Registry::instance().add(type, h); }
};
} 
#define MC_REGISTER_HANDLER(TYPE_ENUM, CLASSNAME) \
	static CLASSNAME g_##CLASSNAME; \
	static mc::AutoRegister g_reg_##CLASSNAME((uint8_t)(TYPE_ENUM), &g_##CLASSNAME);
----------------------------------------

----------------------------------------
File: firmware/src/comm/registry.cpp
----------------------------------------
#include "registry.h"
#include <string.h>
namespace mc {
Registry &Registry::instance() {
	static Registry inst;
	return inst;
}
Registry::Registry() : _n(0) { memset(_e, 0, sizeof(_e)); }
bool Registry::add(uint8_t type, IHandler *h) {
	for (int i = 0; i < _n; i++) {
		if (_e[i].type == type) {
			_e[i].h = h;
			return true;
		}
	}
	if (_n >= MAX)
		return false;
	_e[_n++] = {type, h};
	return true;
}
IHandler *Registry::get(uint8_t type) {
	for (int i = 0; i < _n; i++)
		if (_e[i].type == type)
			return _e[i].h;
	return nullptr;
}
} 
----------------------------------------

----------------------------------------
File: firmware/src/comm/handlers/DriveHandler.cpp
----------------------------------------
#include "../../../lib/common/Math.h"
#include "../../log/AsyncLogger.h"
#include "../registry.h"
#include <mc/proto/Ack.hpp>
namespace {
static inline int16_t rd16(const uint8_t *p) {
	return (int16_t)((uint16_t)p[0] | ((uint16_t)p[1] << 8));
}
static inline uint16_t rdu16(const uint8_t *p) {
	return (uint16_t)p[0] | ((uint16_t)p[1] << 8);
}
class DriveHandler : public mc::IHandler {
public:
	mc::Result onFrame(const mc::proto::FrameView &f, mc::Context &ctx,
					   uint32_t now_ms) override {
		if (f.payload_len != 8) {
			if (ctx.log) {
				ctx.log->logf(mc::LogLevel::WARN, "proto",
							  "RX DRIVE invalid len=%u",
							  (unsigned)f.payload_len);
			}
			return mc::Result::Fail(mc::Errc::Invalid, "drive len");
		}
		int16_t steer_cdeg = rd16(f.payload + 0);
		int16_t speed_mm_s = rd16(f.payload + 2);
		uint16_t ttl_ms = rdu16(f.payload + 4);
		uint16_t dist_mm = rdu16(f.payload + 6);
		steer_cdeg = (int16_t)mc::clamp< int >(steer_cdeg, -3000, 3000);
		speed_mm_s = (int16_t)mc::clamp< int >(speed_mm_s, -5000, 5000);
		if (ttl_ms < 10)
			ttl_ms = 10;
		if (ttl_ms > 2000)
			ttl_ms = 2000;
		auto *st = ctx.st;
		st->last_seq = f.seq();
		st->last_cmd_ms = now_ms;
		st->cmd_expire_ms = now_ms + ttl_ms;
		st->target_steer_cdeg = steer_cdeg;
		st->target_speed_mm_s = speed_mm_s;
		st->target_ttl_ms = ttl_ms;
		st->target_dist_mm = dist_mm;
		if (ctx.log) {
			ctx.log->logf(mc::LogLevel::DEBUG, "proto",
						  "RX DRIVE seq=%u steer=%d speed=%d ttl=%u dist=%u",
						  (unsigned)st->last_seq, (int)steer_cdeg,
						  (int)speed_mm_s, (unsigned)ttl_ms, (unsigned)dist_mm);
		}
		if (f.flags() & mc::proto::FLAG_ACK_REQ) {
			mc::proto::send_ack(ctx.tx, f.seq());
		}
		return mc::Result::Ok();
	}
};
} 
MC_REGISTER_HANDLER(mc::proto::Type::DRIVE, DriveHandler)
----------------------------------------

----------------------------------------
File: firmware/src/comm/handlers/KillHandler.cpp
----------------------------------------
#include "../../log/AsyncLogger.h"
#include "../registry.h"
#include <mc/proto/Ack.hpp>
namespace {
class KillHandler : public mc::IHandler {
public:
	mc::Result onFrame(const mc::proto::FrameView &f, mc::Context &ctx,
					   uint32_t now_ms) override {
		(void)f;
		(void)now_ms;
		ctx.st->killed = true;
		ctx.st->cmd_expire_ms = 0;
		if (ctx.log) {
			ctx.log->log(mc::LogLevel::WARN, "proto", "RX KILL -> killed=1");
		}
		if (f.flags() & mc::proto::FLAG_ACK_REQ) {
			mc::proto::send_ack(ctx.tx, f.seq());
		}
		return mc::Result::Ok();
	}
};
} 
MC_REGISTER_HANDLER(mc::proto::Type::KILL, KillHandler)
----------------------------------------

----------------------------------------
File: firmware/src/comm/handlers/PingHandler.cpp
----------------------------------------
#include "../../log/AsyncLogger.h"
#include "../registry.h"
#include <mc/proto/Ack.hpp>
namespace {
class PingHandler : public mc::IHandler {
public:
	mc::Result onFrame(const mc::proto::FrameView &f, mc::Context &ctx,
					   uint32_t now_ms) override {
		if (f.payload_len != 0) {
			if (ctx.log) {
				ctx.log->log(mc::LogLevel::WARN, "proto",
							 "RX PING nonzero len");
			}
			return mc::Result::Fail(mc::Errc::Invalid, "ping len");
		}
		ctx.st->last_hb_ms = now_ms;
		const uint16_t seq = f.seq();
		mc::proto::send_ack(ctx.tx, seq);
		if (ctx.log) {
			ctx.log->logf(mc::LogLevel::TRACE, "proto", "RX PING -> ACK seq=%u",
						  (unsigned)seq);
		}
		return mc::Result::Ok();
	}
};
} 
MC_REGISTER_HANDLER(mc::proto::Type::PING, PingHandler)
----------------------------------------

----------------------------------------
File: firmware/src/comm/handlers/ModeHandler.cpp
----------------------------------------
#include "../../log/AsyncLogger.h"
#include "../registry.h"
#include <mc/proto/Ack.hpp>
namespace {
class ModeHandler : public mc::IHandler {
public:
	mc::Result onFrame(const mc::proto::FrameView &f, mc::Context &ctx,
					   uint32_t now_ms) override {
		(void)now_ms;
		if (f.payload_len != 1) {
			if (ctx.log) {
				ctx.log->log(mc::LogLevel::WARN, "proto",
							 "RX MODE invalid len");
			}
			return mc::Result::Fail(mc::Errc::Invalid, "mode len");
		}
		uint8_t mode = f.payload[0];
		if (mode == 0)
			ctx.st->mode = mc::Mode::MANUAL;
		else if (mode == 1)
			ctx.st->mode = mc::Mode::AUTO;
		else {
			if (ctx.log) {
				ctx.log->logf(mc::LogLevel::WARN, "proto",
							  "RX MODE invalid val=%u", (unsigned)mode);
			}
			return mc::Result::Fail(mc::Errc::Range, "mode val");
		}
		if (ctx.log) {
			ctx.log->logf(mc::LogLevel::INFO, "proto", "RX MODE -> %s",
						  (mode == 0 ? "MANUAL" : "AUTO"));
		}
		if (f.flags() & mc::proto::FLAG_ACK_REQ) {
			mc::proto::send_ack(ctx.tx, f.seq());
		}
		return mc::Result::Ok();
	}
};
} 
MC_REGISTER_HANDLER(mc::proto::Type::MODE_SET, ModeHandler)
----------------------------------------

----------------------------------------
File: firmware/src/log/AsyncLogger.h
----------------------------------------
#pragma once
#include <Arduino.h>
#include <stdint.h>
#include <mc/proto/Proto.hpp>
#include "../comm/UartTx.h"
namespace mc {
enum class LogLevel : uint8_t {
	TRACE = 0,
	DEBUG = 1,
	INFO = 2,
	WARN = 3,
	ERROR = 4,
	FATAL = 5
};
class AsyncLogger {
public:
	void begin(UartTx& tx);
	void setMinLevel(LogLevel lv) { _min = lv; }
	LogLevel minLevel() const { return _min; }
	bool log(LogLevel lv, const char* tag, const char* msg);
	bool logf(LogLevel lv, const char* tag, const char* fmt, ...);
	uint32_t dropped() const { return _dropped; }
private:
	UartTx* _tx = nullptr;
	LogLevel _min = LogLevel::INFO;
	static constexpr size_t MSGMAX = mc::proto::MAX_FRAME_ENCODED;
	uint16_t _seq = 1;
	uint32_t _dropped = 0;
	bool enqueue_(const uint8_t* data, uint16_t len);
	bool buildPayload_(LogLevel lv, const char* tag, const char* msg,
		uint8_t* payload_buf, uint16_t& payload_len);
	bool buildFrame_(LogLevel lv, const char* tag, const char* msg,
		uint8_t* frame_buf, uint16_t& frame_len);
};
} 
----------------------------------------

----------------------------------------
File: firmware/src/log/AsyncLogger.cpp
----------------------------------------
#include "AsyncLogger.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
namespace mc {
void AsyncLogger::begin(UartTx &tx) { _tx = &tx; }
bool AsyncLogger::enqueue_(const uint8_t *data, uint16_t len) {
	if (!_tx)
		return false;
	if (len == 0 || len > MSGMAX)
		return false;
	if (!_tx->enqueue(data, len)) {
		_dropped++;
		return false;
	}
	return true;
}
bool AsyncLogger::buildPayload_(LogLevel lv, const char *tag, const char *msg,
								uint8_t *payload_buf, uint16_t &payload_len) {
	payload_len = 0;
	if (!payload_buf)
		return false;
	payload_buf[0] = static_cast< uint8_t >(lv);
	static constexpr uint16_t MAX_TEXT = (uint16_t)(mc::proto::MAX_PAYLOAD - 1);
	char text[MAX_TEXT + 1];
	text[0] = '\0';
	const char *t = (tag && tag[0]) ? tag : nullptr;
	const char *m = (msg && msg[0]) ? msg : "";
	if (t) {
		snprintf(text, sizeof(text), "%s: %s", t, m);
	} else {
		snprintf(text, sizeof(text), "%s", m);
	}
	size_t n = strnlen(text, MAX_TEXT);
	memcpy(payload_buf + 1, text, n);
	payload_len = (uint16_t)(1 + n);
	return true;
}
bool AsyncLogger::buildFrame_(LogLevel lv, const char *tag, const char *msg,
							  uint8_t *frame_buf, uint16_t &frame_len) {
	frame_len = 0;
	if (!frame_buf)
		return false;
	uint8_t payload[mc::proto::MAX_PAYLOAD];
	uint16_t payload_len = 0;
	if (!buildPayload_(lv, tag, msg, payload, payload_len))
		return false;
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		frame_buf, MSGMAX, out_len, mc::proto::Type::LOG, 0, _seq++, payload,
		payload_len);
	if (!ok)
		return false;
	frame_len = (uint16_t)out_len;
	return true;
}
bool AsyncLogger::log(LogLevel lv, const char *tag, const char *msg) {
	if (!_tx)
		return false;
	if ((uint8_t)lv < (uint8_t)_min)
		return true;
	uint8_t frame[MSGMAX];
	uint16_t frame_len = 0;
	if (!buildFrame_(lv, tag, msg, frame, frame_len)) {
		_dropped++;
		return false;
	}
	return enqueue_(frame, frame_len);
}
bool AsyncLogger::logf(LogLevel lv, const char *tag, const char *fmt, ...) {
	if (!_tx)
		return false;
	if ((uint8_t)lv < (uint8_t)_min)
		return true;
	char buf[mc::proto::MAX_PAYLOAD];
	va_list ap;
	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	return log(lv, tag, buf);
}
} 
----------------------------------------

----------------------------------------
File: firmware/src/main.cpp
----------------------------------------
#include "config/Config.h"
#include "control/ControllerInput.h"
#include "hardware/Drive.h"
#include <Arduino.h>
#include "../lib/common/Math.h"
#include "../lib/common/Time.h"
#include "comm/UartTx.h"
#include "comm/registry.h"
#include "log/AsyncLogger.h"
#include <mc/proto/Proto.hpp>
static constexpr int SERIAL_RXD = 16;
static constexpr int SERIAL_TXD = 17;
static constexpr int DEFAULT_ESP_BAUD = 921600;
static mc::ControlState g_state;
static mc::Context g_ctx;
static Drive drive;
static ControllerInput pad;
static mc::AsyncLogger alog;
static mc::UartTx uart_tx;
static mc::proto::PacketReader reader;
static mc::PeriodicTimer statusTimer(50);
static mc::PeriodicTimer logTimer(200);
static uint16_t status_seq = 0;
static inline void wr16(uint8_t *p, uint16_t v) {
	p[0] = (uint8_t)(v & 0xFF);
	p[1] = (uint8_t)(v >> 8);
}
#pragma pack(push, 1)
struct StatusPayload {
	uint8_t seq_applied;
	uint8_t auto_active;
	uint16_t faults_le;
	int16_t speed_mm_s_le;
	int16_t steer_cdeg_le;
	uint16_t age_ms_le;
};
#pragma pack(pop)
static void sendStatus_(uint32_t now_ms) {
	const bool auto_active = (g_state.mode == mc::Mode::AUTO);
	const bool hb_timeout = auto_active && (g_state.last_hb_ms != 0) &&
							((uint32_t)(now_ms - g_state.last_hb_ms) >
							 (uint32_t)cfg::HEARTBEAT_TIMEOUT_MS);
	const bool ttl_expired =
		auto_active && (g_state.cmd_expire_ms != 0) &&
		((uint32_t)now_ms > (uint32_t)g_state.cmd_expire_ms);
	const bool auto_inactive =
		(!auto_active) && (g_state.cmd_expire_ms != 0) &&
		((uint32_t)now_ms <= (uint32_t)g_state.cmd_expire_ms);
	uint16_t faults = 0;
	if (g_state.killed)
		faults |= 1u << 0; 
	if (hb_timeout)
		faults |= 1u << 1; 
	if (ttl_expired)
		faults |= 1u << 2; 
	if (auto_inactive)
		faults |= 1u << 3; 
	uint16_t age_ms = cfg::AUTO_CMD_AGE_UNKNOWN_MS;
	if (g_state.last_cmd_ms != 0) {
		uint32_t age = now_ms - g_state.last_cmd_ms;
		if (age > 0xFFFFu)
			age = 0xFFFFu;
		age_ms = (uint16_t)age;
	}
	StatusPayload p{};
	p.seq_applied = (uint8_t)(g_state.last_seq & 0xFFu);
	p.auto_active = auto_active ? 1u : 0u;
	wr16((uint8_t *)&p.faults_le, faults);
	wr16((uint8_t *)&p.speed_mm_s_le,
		 (uint16_t)(int16_t)drive.appliedSpeedMmS());
	wr16((uint8_t *)&p.steer_cdeg_le,
		 (uint16_t)(int16_t)drive.appliedSteerCdeg());
	wr16((uint8_t *)&p.age_ms_le, age_ms);
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	mc::proto::PacketWriter::build(out, sizeof(out), out_len,
								   mc::proto::Type::STATUS, 0, status_seq++,
								   (const uint8_t *)&p, (uint16_t)sizeof(p));
	if (g_ctx.tx) {
		g_ctx.tx->enqueue(out, (uint16_t)out_len);
	}
}
static void handleRx_(uint32_t now_ms) {
	while (Serial2.available() > 0) {
		uint8_t b = (uint8_t)Serial2.read();
		if (reader.push(b) && reader.hasFrame()) {
			const auto &f = reader.frame();
			mc::IHandler *h = mc::Registry::instance().get(f.type());
			if (h) {
				(void)h->onFrame(f, g_ctx, now_ms);
			} else if (g_ctx.log) {
				g_ctx.log->logf(mc::LogLevel::WARN, "proto",
								"RX unknown type=0x%02X", (unsigned)f.type());
			}
			reader.consumeFrame();
		}
	}
}
static void applyTargets_(uint32_t now_ms, float dt_s) {
	const bool cmd_fresh =
		(g_state.cmd_expire_ms != 0) && (now_ms <= g_state.cmd_expire_ms);
	if (g_state.mode == mc::Mode::MANUAL) {
		pad.update();
		if (pad.isConnected()) {
			const PadState &st = pad.state();
			int forward = st.rt;
			int back = st.lt;
			int v = forward - back;
			int16_t speed_mm_s = (int16_t)mc::clamp< int >(v * 2, -2000, 2000);
			int16_t steer = 0;
			if (st.dpad & DPAD_LEFT)
				steer = +1500;
			if (st.dpad & DPAD_RIGHT)
				steer = -1500;
			drive.setTargetMmS(speed_mm_s);
			drive.setTargetSteerCdeg(steer);
			drive.setTtlMs(100);
			drive.setDistMm(0);
		} else {
			drive.setTargetMmS(0);
			drive.setTargetSteerCdeg(0);
			drive.setTtlMs(100);
			drive.setDistMm(0);
		}
	} else {
		if (cmd_fresh) {
			drive.setTargetMmS(g_state.target_speed_mm_s);
			drive.setTargetSteerCdeg(g_state.target_steer_cdeg);
			drive.setTtlMs(g_state.target_ttl_ms);
			drive.setDistMm(g_state.target_dist_mm);
		} else {
			drive.setTargetMmS(0);
			drive.setTargetSteerCdeg(0);
			drive.setTtlMs(100);
			drive.setDistMm(0);
		}
	}
	drive.tick(now_ms, dt_s, g_state.killed);
}
void setup() {
	Serial.begin(115200);
	delay(200);
	Serial2.begin(DEFAULT_ESP_BAUD, SERIAL_8N1, SERIAL_RXD, SERIAL_TXD);
	Serial2.setRxBufferSize(4096);
	Serial2.setTxBufferSize(4096);
	g_ctx.st = &g_state;
	g_ctx.uart = &Serial2;
	g_ctx.log = &alog;
	g_ctx.tx = &uart_tx;
	pad.begin();
	drive.begin();
	uart_tx.begin(Serial2);
	alog.begin(uart_tx);
	alog.setMinLevel(mc::LogLevel::INFO);
	alog.logf(mc::LogLevel::INFO, "boot", "ESP32 up baud=%d", DEFAULT_ESP_BAUD);
	uint32_t now = millis();
	statusTimer.reset(now);
	logTimer.reset(now);
}
void loop() {
	static uint64_t last_us = mc::Time::us();
	uint64_t now_us = mc::Time::us();
	float dt_s = (float)(now_us - last_us) / 1e6f;
	if (dt_s < 0.0f)
		dt_s = 0.0f;
	if (dt_s > 0.05f)
		dt_s = 0.05f;
	last_us = now_us;
	uint32_t now_ms = (uint32_t)millis();
	handleRx_(now_ms);
	applyTargets_(now_ms, dt_s);
	if (statusTimer.due(now_ms)) {
		sendStatus_(now_ms);
	}
	if (logTimer.due(now_ms)) {
		const char *mode =
			(g_state.mode == mc::Mode::MANUAL) ? "MANUAL" : "AUTO";
		alog.logf(mc::LogLevel::INFO, "drive",
				  "mode=%s killed=%d applied(speed=%dmm/s steer=%dcdeg "
				  "ttl=%ums dist=%umm) drop=%u",
				  mode, (int)g_state.killed, (int)drive.appliedSpeedMmS(),
				  (int)drive.appliedSteerCdeg(), (unsigned)drive.ttlMs(),
				  (unsigned)drive.distMm(), (unsigned)alog.dropped());
	}
	delay(1);
}
----------------------------------------

----------------------------------------
File: firmware/src/control/ControllerInput.cpp
----------------------------------------
#include "ControllerInput.h"
ControllerPtr ControllerInput::myCtl_ = nullptr;
void ControllerInput::onConnected(ControllerPtr ctl) {
	Serial.println("Controller connected");
	if (!myCtl_) {
		myCtl_ = ctl;
		Serial.println("Using this controller as primary.");
	}
}
void ControllerInput::onDisconnected(ControllerPtr ctl) {
	Serial.println("Controller disconnected");
	if (myCtl_ == ctl) {
		myCtl_ = nullptr;
		Serial.println("Primary controller cleared.");
	}
}
void ControllerInput::begin() {
	BP32.setup(&ControllerInput::onConnected, &ControllerInput::onDisconnected);
}
void ControllerInput::update() {
	BP32.update();
	toggleRunningEdge_ = false;
	if (!myCtl_ || !myCtl_->isConnected()) {
		return;
	}
	bool selectNow = myCtl_->miscSelect();
	if (selectNow && !prevSelect_) {
		toggleRunningEdge_ = true;
	}
	prevSelect_ = selectNow;
	readPad_();
}
bool ControllerInput::consumeToggleRunning() {
	if (toggleRunningEdge_) {
		toggleRunningEdge_ = false;
		return true;
	}
	return false;
}
bool ControllerInput::isConnected() const {
	return (myCtl_ && myCtl_->isConnected());
}
void ControllerInput::readPad_() {
	st_.lt = myCtl_->brake();
	st_.rt = myCtl_->throttle();
	st_.A = myCtl_->b();
	st_.B = myCtl_->a();
	st_.X = myCtl_->y();
	st_.Y = myCtl_->x();
	st_.select = myCtl_->miscSelect();
	st_.start = myCtl_->miscStart();
	st_.home = myCtl_->miscHome();
	st_.dpad = myCtl_->dpad();
}
----------------------------------------

----------------------------------------
File: firmware/src/control/ControllerInput.h
----------------------------------------
#pragma once
#include <Arduino.h>
#include <Bluepad32.h>
struct PadState {
  int lt = 0;
  int rt = 0;
  bool A = false;
  bool B = false;
  bool X = false;
  bool Y = false;
  bool select = false; 
  bool start  = false; 
  bool home   = false; 
  int dpad = 0;
};
class ControllerInput {
public:
  void begin();
  void update();
  bool isConnected() const;
  const PadState& state() const { return st_; }
  bool consumeToggleRunning();
private:
  static void onConnected(ControllerPtr ctl);
  static void onDisconnected(ControllerPtr ctl);
  static ControllerPtr myCtl_;
  PadState st_;
  bool prevSelect_ = false;
  bool toggleRunningEdge_ = false;
  void readPad_();
};
----------------------------------------

----------------------------------------
File: test/firmware/proto/cpp/proto_tests.cpp
----------------------------------------
#include <mc/proto/Proto.hpp>
#include <cassert>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <vector>
namespace {
static constexpr size_t kCrcSize = 2;
size_t build_raw_frame(const mc::proto::Header &hdr, const uint8_t *payload,
					   size_t payload_len, uint8_t *out, size_t out_max) {
	const size_t frame_len = sizeof(mc::proto::Header) + payload_len;
	const size_t total_len = frame_len + kCrcSize;
	if (total_len > out_max) {
		return 0;
	}
	std::memcpy(out, &hdr, sizeof(mc::proto::Header));
	if (payload_len > 0 && payload != nullptr) {
		std::memcpy(out + sizeof(mc::proto::Header), payload, payload_len);
	}
	const uint16_t crc = mc::proto::crc16_ccitt(out, frame_len);
	out[frame_len] = static_cast< uint8_t >(crc & 0xFF);
	out[frame_len + 1] = static_cast< uint8_t >((crc >> 8) & 0xFF);
	return total_len;
}
std::vector< uint8_t > encode_frame(const uint8_t *raw, size_t raw_len) {
	uint8_t cobs_buf[mc::proto::MAX_FRAME_ENCODED];
	const size_t encoded_len =
		mc::proto::cobs_encode(raw, raw_len, cobs_buf, sizeof(cobs_buf));
	assert(encoded_len > 0);
	std::vector< uint8_t > out(cobs_buf, cobs_buf + encoded_len);
	out.push_back(0x00);
	return out;
}
void print_bytes(const char *label, const uint8_t *data, size_t len) {
	std::cout << "\t" << label << " (" << len << "): ";
	for (size_t i = 0; i < len; ++i) {
		std::cout << std::hex << std::setw(2) << std::setfill('0')
				  << static_cast< unsigned int >(data[i]);
		if (i + 1 != len) {
			std::cout << " ";
		}
	}
	std::cout << std::dec << "\n";
}
} 
static void test_crc16() {
	std::cout << "[TEST] crc16\n";
	const uint8_t data[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
	const uint16_t crc = mc::proto::crc16_ccitt(data, sizeof(data));
	std::cout << "\tgot: 0x" << std::hex << std::setw(4) << std::setfill('0')
			  << crc << std::dec << "\n";
	std::cout << "\texpected: 0x29b1\n";
	assert(crc == 0x29B1);
}
static void test_cobs_roundtrip() {
	std::cout << "[TEST] cobs_roundtrip\n";
	const uint8_t input[] = {0x11, 0x00, 0x22, 0x33, 0x00, 0x44};
	uint8_t encoded[32];
	uint8_t decoded[32];
	const size_t enc_len =
		mc::proto::cobs_encode(input, sizeof(input), encoded, sizeof(encoded));
	assert(enc_len > 0);
	const size_t dec_len =
		mc::proto::cobs_decode(encoded, enc_len, decoded, sizeof(decoded));
	print_bytes("input", input, sizeof(input));
	print_bytes("encoded", encoded, enc_len);
	print_bytes("decoded", decoded, dec_len);
	assert(dec_len == sizeof(input));
	assert(std::memcmp(input, decoded, sizeof(input)) == 0);
}
static void test_cobs_encode_overflow() {
	std::cout << "[TEST] cobs_encode_overflow\n";
	const uint8_t input[] = {0x11, 0x22, 0x33, 0x44};
	uint8_t small_out[2];
	const size_t enc_len = mc::proto::cobs_encode(input, sizeof(input),
												  small_out, sizeof(small_out));
	std::cout << "\texpect enc_len=0 actual=" << enc_len << "\n";
	assert(enc_len == 0);
}
static void test_writer_payload_too_large() {
	std::cout << "[TEST] writer_payload_too_large\n";
	std::vector< uint8_t > payload(mc::proto::MAX_PAYLOAD + 1, 0xAA);
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, mc::proto::Type::LOG, 0, 1, payload.data(),
		(uint16_t)payload.size());
	std::cout << "\texpect ok=false actual=" << (ok ? "true" : "false") << "\n";
	assert(!ok);
}
static void test_reader_ok() {
	std::cout << "[TEST] packet_reader_ok\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = 0x0042;
	hdr.len_le = 2;
	const uint8_t payload[2] = {0x01, 0x00};
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	assert(raw_len > 0);
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded) {
		reader.push(b);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	std::cout << "\theader got: ver=" << static_cast< int >(frame.ver())
			  << " type=0x" << std::hex << static_cast< int >(frame.type())
			  << " flags=0x" << static_cast< int >(frame.flags()) << " seq=0x"
			  << static_cast< int >(frame.seq()) << std::dec
			  << " len=" << frame.len() << "\n";
	std::cout << "\theader expected: ver=" << static_cast< int >(hdr.ver)
			  << " type=0x" << std::hex << static_cast< int >(hdr.type)
			  << " flags=0x" << static_cast< int >(hdr.flags) << " seq=0x"
			  << static_cast< int >(mc::proto::le16_to_host(hdr.seq_le))
			  << std::dec << " len=" << mc::proto::le16_to_host(hdr.len_le)
			  << "\n";
	assert(frame.ver() == mc::proto::VERSION);
	assert(frame.type() == hdr.type);
	assert(frame.flags() == hdr.flags);
	assert(frame.seq() == mc::proto::le16_to_host(hdr.seq_le));
	assert(frame.len() == mc::proto::le16_to_host(hdr.len_le));
	assert(frame.payload_len == sizeof(payload));
	assert(std::memcmp(frame.payload, payload, sizeof(payload)) == 0);
}
static void test_reader_crc_fail() {
	std::cout << "[TEST] packet_reader_crc_fail\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::DRIVE);
	hdr.flags = 0;
	hdr.seq_le = 0x0010;
	hdr.len_le = 1;
	uint8_t payload[1] = {0x7A};
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	assert(raw_len > 0);
	raw[sizeof(mc::proto::Header)] ^= 0xFF;
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded) {
		reader.push(b);
	}
	std::cout << "\tbadCrc: " << reader.badCrc() << "\n";
	assert(reader.badCrc() == 1);
	assert(!reader.hasFrame());
}
static void test_reader_bad_length() {
	std::cout << "[TEST] packet_reader_bad_length\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::MODE_SET);
	hdr.flags = 0;
	hdr.seq_le = 0x0020;
	hdr.len_le = 3;
	const uint8_t payload[2] = {0x00, 0x00};
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	assert(raw_len > 0);
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded) {
		reader.push(b);
	}
	std::cout << "\tbadHdr: " << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 1);
	assert(!reader.hasFrame());
}
static void test_reader_bad_version() {
	std::cout << "[TEST] packet_reader_bad_version\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = static_cast< uint8_t >(mc::proto::VERSION + 1);
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0x01;
	hdr.seq_le = 0x0033;
	hdr.len_le = 0;
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	assert(raw_len > 0);
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded) {
		reader.push(b);
	}
	std::cout << "\tbadHdr: " << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 1);
	assert(!reader.hasFrame());
}
static void test_golden_frame_output() {
	std::cout << "[TEST] golden_frame_output\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = 0x01;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::ACK);
	hdr.flags = 0x01;
	hdr.seq_le = 0x0010;
	hdr.len_le = 0x0004;
	const uint8_t payload[4] = {0xAA, 0xBB, 0xCC, 0xDD};
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	const uint8_t expected[] = {0x4D, 0x43, 0x01, 0x80, 0x01, 0x10, 0x00, 0x04,
								0x00, 0xAA, 0xBB, 0xCC, 0xDD, 0xE6, 0xC8};
	print_bytes("raw", raw, raw_len);
	print_bytes("expected", expected, sizeof(expected));
	assert(raw_len == sizeof(expected));
	assert(std::memcmp(raw, expected, sizeof(expected)) == 0);
}
static void test_min_frame_len0() {
	std::cout << "[TEST] min_frame_len0\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::host_to_le16(0x0042);
	hdr.len_le = mc::proto::host_to_le16(0);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded) {
		reader.push(b);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	std::cout << "\texpect len=0 actual len=" << frame.payload_len << "\n";
	assert(frame.payload_len == 0);
}
static void test_max_payload() {
	std::cout << "[TEST] max_payload\n";
	std::vector< uint8_t > payload(mc::proto::MAX_PAYLOAD, 0xAB);
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::LOG);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::host_to_le16(0x0011);
	hdr.len_le = mc::proto::host_to_le16((uint16_t)payload.size());
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload.data(), payload.size(), raw, sizeof(raw));
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded) {
		reader.push(b);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	std::cout << "\texpect len=" << payload.size()
			  << " actual len=" << frame.payload_len << "\n";
	assert(frame.payload_len == payload.size());
}
static void test_back_to_back_frames() {
	std::cout << "[TEST] back_to_back_frames\n";
	std::vector< uint8_t > stream;
	for (int i = 0; i < 2; ++i) {
		uint8_t payload[1] = {static_cast< uint8_t >(i)};
		mc::proto::Header hdr{};
		hdr.magic[0] = mc::proto::MAGIC0;
		hdr.magic[1] = mc::proto::MAGIC1;
		hdr.ver = mc::proto::VERSION;
		hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
		hdr.flags = 0;
		hdr.seq_le = mc::proto::host_to_le16((uint16_t)i);
		hdr.len_le = mc::proto::host_to_le16(1);
		uint8_t raw[mc::proto::MAX_FRAME_DECODED];
		const size_t raw_len =
			build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
		const auto enc = encode_frame(raw, raw_len);
		stream.insert(stream.end(), enc.begin(), enc.end());
	}
	mc::proto::PacketReader reader;
	int frames = 0;
	for (uint8_t b : stream) {
		reader.push(b);
		if (reader.hasFrame()) {
			const auto &f = reader.frame();
			std::cout << "\tframe " << frames << " seq=" << f.seq()
					  << " len=" << f.payload_len << "\n";
			frames++;
			reader.consumeFrame();
		}
	}
	std::cout << "\texpect frames=2 actual=" << frames << "\n";
	assert(frames == 2);
}
static void test_resync_after_bad_crc() {
	std::cout << "[TEST] resync_after_bad_crc\n";
	uint8_t payload[1] = {0xAA};
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::host_to_le16(0x10);
	hdr.len_le = mc::proto::host_to_le16(1);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	size_t raw_len =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	raw[sizeof(mc::proto::Header)] ^= 0xFF;
	const auto bad = encode_frame(raw, raw_len);
	hdr.seq_le = mc::proto::host_to_le16(0x11);
	raw_len = build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	const auto good = encode_frame(raw, raw_len);
	std::vector< uint8_t > stream;
	stream.insert(stream.end(), bad.begin(), bad.end());
	stream.insert(stream.end(), good.begin(), good.end());
	mc::proto::PacketReader reader;
	int ok_frames = 0;
	for (uint8_t b : stream) {
		reader.push(b);
		if (reader.hasFrame()) {
			const auto &f = reader.frame();
			std::cout << "\tgot seq=" << f.seq() << "\n";
			ok_frames++;
			reader.consumeFrame();
		}
	}
	std::cout << "\texpect ok_frames=1 actual=" << ok_frames << "\n";
	assert(ok_frames == 1);
}
static void test_header_and_length_errors() {
	std::cout << "[TEST] header_and_length_errors\n";
	mc::proto::PacketReader reader;
	mc::proto::Header hdr{};
	hdr.magic[0] = 'X';
	hdr.magic[1] = 'Y';
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::host_to_le16(0x20);
	hdr.len_le = mc::proto::host_to_le16(0);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	size_t raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	auto enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "\tbadHdr after bad magic=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 1);
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.len_le = mc::proto::host_to_le16(2);
	uint8_t payload[1] = {0x01};
	raw_len = build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "\tbadHdr after len mismatch=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 2);
	hdr.len_le = mc::proto::host_to_le16(mc::proto::MAX_PAYLOAD + 1);
	raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "\tbadHdr after len>MAX=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 3);
	const uint8_t bad_cobs[] = {0x02, 0x00};
	for (uint8_t b : bad_cobs)
		reader.push(b);
	std::cout << "\tbadCobs after bad cobs=" << reader.badCobs() << "\n";
	assert(reader.badCobs() >= 1);
}
static void test_writer_ack_roundtrip() {
	std::cout << "[TEST] writer_ack_roundtrip\n";
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const uint16_t seq = 0x1234;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::ACK, 0, seq, nullptr, 0);
	assert(ok);
	assert(enc_len > 0);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < enc_len; ++i) {
		reader.push(enc[i]);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	assert(frame.type() == static_cast< uint8_t >(mc::proto::Type::ACK));
	assert(frame.flags() == 0);
	assert(frame.payload_len == 0);
	assert(frame.seq() == seq);
}
static void test_writer_status_roundtrip() {
	std::cout << "[TEST] writer_status_roundtrip\n";
	mc::proto::StatusPayload payload{};
	payload.seq_applied = 0x7B;
	payload.auto_active = 1;
	payload.faults_le = mc::proto::host_to_le16(0x0005);
	payload.speed_mm_s_le =
		(int16_t)mc::proto::host_to_le16((uint16_t)(int16_t)-123);
	payload.steer_cdeg_le =
		(int16_t)mc::proto::host_to_le16((uint16_t)(int16_t)456);
	payload.age_ms_le = mc::proto::host_to_le16(250);
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::STATUS, 0, 0x0102,
		reinterpret_cast< const uint8_t * >(&payload), sizeof(payload));
	assert(ok);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < enc_len; ++i) {
		reader.push(enc[i]);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	assert(frame.type() == static_cast< uint8_t >(mc::proto::Type::STATUS));
	assert(frame.payload_len == sizeof(payload));
	assert(std::memcmp(frame.payload, &payload, sizeof(payload)) == 0);
}
int main() {
	test_crc16();
	test_cobs_roundtrip();
	test_cobs_encode_overflow();
	test_reader_ok();
	test_reader_crc_fail();
	test_reader_bad_length();
	test_reader_bad_version();
	test_golden_frame_output();
	test_writer_ack_roundtrip();
	test_writer_status_roundtrip();
	test_writer_payload_too_large();
	test_min_frame_len0();
	test_max_payload();
	test_back_to_back_frames();
	test_resync_after_bad_crc();
	test_header_and_length_errors();
	std::cout << "firmware proto tests ok\n";
	return 0;
}
----------------------------------------

----------------------------------------
File: test/firmware/proto/test_proto_firmware_cpp.py
----------------------------------------
import shutil
import subprocess
from pathlib import Path
import pytest
def test_firmware_proto_cpp(tmp_path: Path):
    if shutil.which("g++") is None:
        pytest.skip("g++ not available")
    repo_root = Path(__file__).resolve().parents[3]
    test_cpp = repo_root / "test/firmware/proto/cpp/proto_tests.cpp"
    proto_src = [
        repo_root / "shared/proto/src/mcproto.cpp",
    ]
    output = tmp_path / "firmware_proto_tests"
    cmd = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-Wpedantic",
        "-O2",
        "-I",
        str(repo_root / "shared/proto/include"),
        str(test_cpp),
        *[str(path) for path in proto_src],
        "-o",
        str(output),
    ]
    build = subprocess.run(cmd, capture_output=True, text=True)
    print("[INFO] build cmd:", " ".join(cmd))
    assert build.returncode == 0, build.stdout + build.stderr
    run = subprocess.run([str(output)], capture_output=True, text=True)
    print("[INFO] run bin:", output)
    assert run.returncode == 0, (run.stdout or "") + (run.stderr or "")
----------------------------------------

----------------------------------------
File: test/firmware/comm/test_comm_integration_cpp.py
----------------------------------------
import shutil
import subprocess
from pathlib import Path
import pytest
def test_firmware_comm_integration_cpp(tmp_path: Path):
    if shutil.which("g++") is None:
        pytest.skip("g++ not available")
    repo_root = Path(__file__).resolve().parents[3]
    test_cpp = repo_root / "test/firmware/comm/cpp/comm_integration_tests.cpp"
    proto_src = [
        repo_root / "shared/proto/src/mcproto.cpp",
        repo_root / "firmware/src/comm/registry.cpp",
        repo_root / "firmware/src/comm/handlers/DriveHandler.cpp",
        repo_root / "firmware/src/comm/handlers/ModeHandler.cpp",
        repo_root / "firmware/src/comm/handlers/KillHandler.cpp",
        repo_root / "firmware/src/comm/handlers/PingHandler.cpp",
        repo_root / "firmware/src/log/AsyncLogger.cpp",
        repo_root / "test/firmware/comm/cpp/UartTx_stub.cpp",
    ]
    output = tmp_path / "firmware_comm_tests"
    cmd = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-Wpedantic",
        "-O2",
        "-I",
        str(repo_root / "test/firmware/comm/include"),
        "-I",
        str(repo_root / "firmware/src"),
        "-I",
        str(repo_root / "shared/proto/include"),
        str(test_cpp),
        *[str(path) for path in proto_src],
        "-o",
        str(output),
    ]
    build = subprocess.run(cmd, capture_output=True, text=True)
    print("\n[INFO] build cmd:", " ".join(cmd))
    assert build.returncode == 0, f"build failed rc={build.returncode}"
    run = subprocess.run([str(output)], capture_output=False, text=True)
    print("\n[INFO] run bin:", output)
    assert run.returncode == 0, (run.stdout or "") + (run.stderr or "")
----------------------------------------

----------------------------------------
File: test/firmware/comm/test_placeholder.py
----------------------------------------
import pytest
pytest.skip("placeholder for firmware/comm tests", allow_module_level=True)
----------------------------------------

----------------------------------------
File: test/firmware/comm/include/Arduino.h
----------------------------------------
#pragma once
#include <stddef.h>
#include <stdint.h>
class HardwareSerial {
public:
	int available() { return 0; }
	int read() { return -1; }
};
typedef void *QueueHandle_t;
typedef void *TaskHandle_t;
typedef int StaticQueue_t;
----------------------------------------

----------------------------------------
File: test/firmware/comm/cpp/comm_integration_tests.cpp
----------------------------------------
#include "comm/UartTx.h"
#include "comm/registry.h"
#include <mc/proto/Proto.hpp>
#include "log/AsyncLogger.h"
#include <cassert>
#include <cstring>
#include <iostream>
#include <vector>
namespace mc::test {
void reset_tx();
const std::vector< std::vector< uint8_t > > &frames();
} 
namespace {
struct TestCtx {
	mc::ControlState st{};
	mc::Context ctx{};
	mc::UartTx tx{};
};
std::vector< uint8_t > build_frame(mc::proto::Type type, uint8_t flags,
								   uint16_t seq, const uint8_t *payload,
								   uint16_t payload_len) {
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, type, flags, seq, payload, payload_len);
	assert(ok);
	return std::vector< uint8_t >(out, out + out_len);
}
mc::proto::FrameView decode_one(const std::vector< uint8_t > &enc) {
	mc::proto::PacketReader reader;
	for (uint8_t b : enc) {
		reader.push(b);
	}
	assert(reader.hasFrame());
	return reader.frame();
}
void expect_ack_seq(const std::vector< uint8_t > &enc, uint16_t seq) {
	mc::proto::PacketReader reader;
	for (uint8_t b : enc) {
		reader.push(b);
	}
	assert(reader.hasFrame());
	const auto &f = reader.frame();
	assert(f.type() == (uint8_t)mc::proto::Type::ACK);
	assert(f.payload_len == 0);
	assert(f.seq() == seq);
}
} 
static void test_ack_for_mode_set() {
	std::cout << "[TEST] firmware_comm_ack_mode_set\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	t.ctx.uart = nullptr;
	const uint8_t payload[1] = {1};
	const auto enc = build_frame(mc::proto::Type::MODE_SET,
								 mc::proto::FLAG_ACK_REQ, 0x10, payload, 1);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 123);
	const auto &frames = mc::test::frames();
	std::cout << "\tTX frames=" << frames.size() << " (expect 1 ACK)\n";
	assert(frames.size() == 1);
	expect_ack_seq(frames[0], 0x10);
}
static void test_ack_for_drive_and_state() {
	std::cout << "[TEST] firmware_comm_ack_drive\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	t.ctx.uart = nullptr;
	uint8_t payload[8] = {};
	payload[0] = 100 & 0xFF;
	payload[1] = (100 >> 8) & 0xFF;
	payload[2] = (uint16_t)(int16_t)-200 & 0xFF;
	payload[3] = (uint16_t)(int16_t)-200 >> 8;
	payload[4] = 100 & 0xFF;
	payload[5] = (100 >> 8) & 0xFF;
	payload[6] = 0;
	payload[7] = 0;
	const auto enc = build_frame(mc::proto::Type::DRIVE,
								 mc::proto::FLAG_ACK_REQ, 0x20, payload, 8);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 1000);
	std::cout << "\tEXPECT last_seq=0x20 steer=100 speed=-200\n";
	std::cout << "\tACTUAL last_seq=0x" << std::hex << t.st.last_seq << std::dec
			  << " steer=" << t.st.target_steer_cdeg
			  << " speed=" << t.st.target_speed_mm_s << "\n";
	assert(t.st.last_seq == 0x20);
	assert(t.st.target_steer_cdeg == 100);
	assert(t.st.target_speed_mm_s == -200);
	const auto &frames = mc::test::frames();
	std::cout << "\tTX frames=" << frames.size() << " (expect 1 ACK)\n";
	assert(frames.size() == 1);
	expect_ack_seq(frames[0], 0x20);
}
static void test_ack_for_kill() {
	std::cout << "[TEST] firmware_comm_ack_kill\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	t.ctx.uart = nullptr;
	const auto enc = build_frame(mc::proto::Type::KILL, mc::proto::FLAG_ACK_REQ,
								 0x30, nullptr, 0);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 0);
	std::cout << "\tEXPECT killed=true\n";
	std::cout << "\tACTUAL killed=" << (t.st.killed ? "true" : "false") << "\n";
	assert(t.st.killed == true);
	const auto &frames = mc::test::frames();
	std::cout << "\tTX frames=" << frames.size() << " (expect 1 ACK)\n";
	assert(frames.size() == 1);
	expect_ack_seq(frames[0], 0x30);
}
static void test_mode_len2_reason() {
	std::cout << "[TEST] firmware_comm_mode_len2\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	uint8_t payload[2] = {0, 42};
	const auto enc =
		build_frame(mc::proto::Type::MODE_SET, 0, 0x40, payload, 2);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 0);
	std::cout << "\tEXPECT mode=MANUAL(0) ACTUAL=" << (int)t.st.mode << "\n";
	assert((int)t.st.mode == 0);
}
static void test_mode_invalid_value() {
	std::cout << "[TEST] firmware_comm_mode_invalid_value\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	uint8_t payload[1] = {2};
	const auto enc = build_frame(mc::proto::Type::MODE_SET,
								 mc::proto::FLAG_ACK_REQ, 0x41, payload, 1);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 0);
	const auto &frames = mc::test::frames();
	std::cout << "\tEXPECT no ACK frames, actual=" << frames.size() << "\n";
	assert(frames.empty());
}
static void test_ping_len0_len4_ack() {
	std::cout << "[TEST] firmware_comm_ping_len0_len4\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	const auto enc0 = build_frame(mc::proto::Type::PING, 0, 0x50, nullptr, 0);
	const auto f0 = decode_one(enc0);
	mc::IHandler *h = mc::Registry::instance().get(f0.type());
	assert(h != nullptr);
	h->onFrame(f0, t.ctx, 100);
	std::cout << "\tlen=0 last_hb_ms=" << t.st.last_hb_ms << "\n";
	assert(t.st.last_hb_ms == 100);
	assert(mc::test::frames().size() == 1);
	expect_ack_seq(mc::test::frames()[0], 0x50);
	mc::test::reset_tx();
	uint8_t payload[4] = {1, 2, 3, 4};
	const auto enc4 = build_frame(mc::proto::Type::PING, 0, 0x51, payload, 4);
	const auto f4 = decode_one(enc4);
	h->onFrame(f4, t.ctx, 200);
	std::cout << "\tlen=4 last_hb_ms=" << t.st.last_hb_ms << "\n";
	assert(t.st.last_hb_ms == 100);
	assert(mc::test::frames().empty());
}
static void test_drive_len_invalid() {
	std::cout << "[TEST] firmware_comm_drive_len_invalid\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	uint8_t payload[4] = {0};
	const auto enc = build_frame(mc::proto::Type::DRIVE,
								 mc::proto::FLAG_ACK_REQ, 0x60, payload, 4);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 0);
	std::cout << "\tEXPECT no ACK, actual=" << mc::test::frames().size()
			  << "\n";
	assert(mc::test::frames().empty());
}
static void test_drive_clamp() {
	std::cout << "[TEST] firmware_comm_drive_clamp\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	uint8_t payload[8] = {};
	payload[0] = 0x88;
	payload[1] = 0x13; 
	payload[2] = 0xF1;
	payload[3] = 0xD8; 
	payload[4] = 0x01;
	payload[5] = 0x00; 
	payload[6] = 0;
	payload[7] = 0;
	const auto enc = build_frame(mc::proto::Type::DRIVE, 0, 0x61, payload, 8);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 1000);
	std::cout << "\tEXPECT steer=3000 speed=-5000 ttl=10\n";
	std::cout << "\tACTUAL steer=" << t.st.target_steer_cdeg
			  << " speed=" << t.st.target_speed_mm_s
			  << " ttl=" << t.st.target_ttl_ms << "\n";
	assert(t.st.target_steer_cdeg == 3000);
	assert(t.st.target_speed_mm_s == -5000);
	assert(t.st.target_ttl_ms == 10);
}
static void test_kill_len2() {
	std::cout << "[TEST] firmware_comm_kill_len2\n";
	mc::test::reset_tx();
	TestCtx t{};
	t.ctx.st = &t.st;
	t.ctx.tx = &t.tx;
	t.ctx.log = nullptr;
	uint8_t payload[2] = {0, 1};
	const auto enc = build_frame(mc::proto::Type::KILL, 0, 0x70, payload, 2);
	const auto f = decode_one(enc);
	mc::IHandler *h = mc::Registry::instance().get(f.type());
	assert(h != nullptr);
	h->onFrame(f, t.ctx, 0);
	std::cout << "\tEXPECT killed=true ACTUAL="
			  << (t.st.killed ? "true" : "false") << "\n";
	assert(t.st.killed == true);
}
static void test_unknown_type_no_crash() {
	std::cout << "[TEST] firmware_comm_unknown_type\n";
	mc::IHandler *h = mc::Registry::instance().get(0x99);
	std::cout << "\tEXPECT nullptr ACTUAL=" << (h ? "non-null" : "null")
			  << "\n";
	assert(h == nullptr);
}
int main() {
	test_ack_for_mode_set();
	test_ack_for_drive_and_state();
	test_ack_for_kill();
	test_mode_len2_reason();
	test_mode_invalid_value();
	test_ping_len0_len4_ack();
	test_drive_len_invalid();
	test_drive_clamp();
	test_kill_len2();
	test_unknown_type_no_crash();
	std::cout << "firmware comm integration tests ok\n";
	return 0;
}
----------------------------------------

----------------------------------------
File: test/firmware/comm/cpp/UartTx_stub.cpp
----------------------------------------
#include "comm/UartTx.h"
#include <vector>
namespace mc::test {
static std::vector< std::vector< uint8_t > > g_frames;
void reset_tx() { g_frames.clear(); }
const std::vector< std::vector< uint8_t > > &frames() { return g_frames; }
} 
namespace mc {
void UartTx::begin(HardwareSerial &uart) { _uart = &uart; }
bool UartTx::enqueue(const uint8_t *data, uint16_t len) {
	if (!data || len == 0)
		return false;
	mc::test::g_frames.emplace_back(data, data + len);
	return true;
}
} 
----------------------------------------

----------------------------------------
File: test/rpi/proto/test_proto_rpi_cpp.py
----------------------------------------
import shutil
import subprocess
from pathlib import Path
import pytest
def test_proto_cpp(tmp_path: Path):
    if shutil.which("g++") is None:
        pytest.skip("g++ not available")
    repo_root = Path(__file__).resolve().parents[3]
    test_cpp = repo_root / "test/rpi/proto/cpp/proto_tests.cpp"
    proto_src = [
        repo_root / "shared/proto/src/mcproto.cpp",
    ]
    if not all(path.exists() for path in proto_src):
        pytest.skip("shared proto sources not present")
    output = tmp_path / "proto_tests"
    cmd = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-Wpedantic",
        "-O2",
        "-I",
        str(repo_root / "shared/proto/include"),
        str(test_cpp),
        *[str(path) for path in proto_src],
        "-o",
        str(output),
    ]
    build = subprocess.run(cmd, capture_output=True, text=True)
    print("\n[INFO] build cmd:", " ".join(cmd))
    assert build.returncode == 0, build.stdout + build.stderr
    run = subprocess.run([str(output)], capture_output=True, text=True)
    print("\n[INFO] run bin:", output)
    assert run.returncode == 0, (run.stdout or "") + (run.stderr or "")
----------------------------------------

----------------------------------------
File: test/rpi/proto/cpp/proto_tests.cpp
----------------------------------------
#include <mc/proto/Proto.hpp>
#include <cassert>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <vector>
namespace {
size_t build_raw_frame(const mc::proto::Header &hdr, const uint8_t *payload,
					   size_t payload_len, uint8_t *out, size_t out_max) {
	const size_t frame_len = sizeof(mc::proto::Header) + payload_len;
	const size_t total_len = frame_len + 2;
	if (total_len > out_max)
		return 0;
	std::memcpy(out, &hdr, sizeof(mc::proto::Header));
	if (payload_len > 0 && payload != nullptr) {
		std::memcpy(out + sizeof(mc::proto::Header), payload, payload_len);
	}
	const uint16_t crc = mc::proto::crc16_ccitt(out, frame_len);
	out[frame_len] = static_cast< uint8_t >(crc & 0xFF);
	out[frame_len + 1] = static_cast< uint8_t >((crc >> 8) & 0xFF);
	return total_len;
}
std::vector< uint8_t > encode_frame(const uint8_t *raw, size_t raw_len) {
	uint8_t cobs_buf[mc::proto::MAX_FRAME_ENCODED];
	const size_t encoded_len =
		mc::proto::cobs_encode(raw, raw_len, cobs_buf, sizeof(cobs_buf));
	assert(encoded_len > 0);
	std::vector< uint8_t > out(cobs_buf, cobs_buf + encoded_len);
	out.push_back(0x00);
	return out;
}
void print_bytes(const char *label, const uint8_t *data, size_t len) {
	std::cout << "  " << label << " (" << len << "): ";
	for (size_t i = 0; i < len; ++i) {
		std::cout << std::hex << std::setw(2) << std::setfill('0')
				  << static_cast< unsigned int >(data[i]);
		if (i + 1 != len)
			std::cout << " ";
	}
	std::cout << std::dec << "\n";
}
} 
static void test_crc16() {
	std::cout << "[TEST] crc16\n";
	const uint8_t data[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
	const uint16_t crc = mc::proto::crc16_ccitt(data, sizeof(data));
	std::cout << "  expected=0x29b1 actual=0x" << std::hex << std::setw(4)
			  << std::setfill('0') << crc << std::dec << "\n";
	assert(crc == 0x29B1);
}
static void test_cobs_roundtrip() {
	std::cout << "[TEST] cobs_roundtrip\n";
	const uint8_t input[] = {0x11, 0x00, 0x22, 0x33, 0x00, 0x44};
	uint8_t encoded[32];
	uint8_t decoded[32];
	const size_t enc_len =
		mc::proto::cobs_encode(input, sizeof(input), encoded, sizeof(encoded));
	const size_t dec_len =
		mc::proto::cobs_decode(encoded, enc_len, decoded, sizeof(decoded));
	print_bytes("input", input, sizeof(input));
	print_bytes("encoded", encoded, enc_len);
	print_bytes("decoded", decoded, dec_len);
	assert(dec_len == sizeof(input));
	assert(std::memcmp(input, decoded, sizeof(input)) == 0);
}
static void test_cobs_encode_overflow() {
	std::cout << "[TEST] cobs_encode_overflow\n";
	const uint8_t input[] = {0x11, 0x22, 0x33, 0x44};
	uint8_t small_out[2];
	const size_t enc_len = mc::proto::cobs_encode(input, sizeof(input),
												  small_out, sizeof(small_out));
	std::cout << "  expect enc_len=0 actual=" << enc_len << "\n";
	assert(enc_len == 0);
}
static void test_writer_payload_too_large() {
	std::cout << "[TEST] writer_payload_too_large\n";
	std::vector< uint8_t > payload(mc::proto::MAX_PAYLOAD + 1, 0xAA);
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, mc::proto::Type::LOG, 0, 1, payload.data(),
		(uint16_t)payload.size());
	std::cout << "  expect ok=false actual=" << (ok ? "true" : "false") << "\n";
	assert(!ok);
}
static void test_min_frame_len0() {
	std::cout << "[TEST] min_frame_len0\n";
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::to_le16(0x0042);
	hdr.len_le = mc::proto::to_le16(0);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded)
		reader.push(b);
	assert(reader.hasFrame());
	const auto &f = reader.frame();
	std::cout << "  expected len=0 actual len=" << f.payload_len << "\n";
	assert(f.payload_len == 0);
}
static void test_max_payload() {
	std::cout << "[TEST] max_payload\n";
	std::vector< uint8_t > payload(mc::proto::MAX_PAYLOAD, 0xAB);
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::LOG);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::to_le16(0x0011);
	hdr.len_le = mc::proto::to_le16((uint16_t)payload.size());
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload.data(), payload.size(), raw, sizeof(raw));
	const auto encoded = encode_frame(raw, raw_len);
	mc::proto::PacketReader reader;
	for (uint8_t b : encoded)
		reader.push(b);
	assert(reader.hasFrame());
	const auto &f = reader.frame();
	std::cout << "  expected len=" << payload.size()
			  << " actual len=" << f.payload_len << "\n";
	assert(f.payload_len == payload.size());
}
static void test_back_to_back_frames() {
	std::cout << "[TEST] back_to_back_frames\n";
	std::vector< uint8_t > encoded_all;
	for (int i = 0; i < 2; ++i) {
		uint8_t payload[1] = {static_cast< uint8_t >(i)};
		mc::proto::Header hdr{};
		hdr.magic[0] = mc::proto::MAGIC0;
		hdr.magic[1] = mc::proto::MAGIC1;
		hdr.ver = mc::proto::VERSION;
		hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
		hdr.flags = 0;
		hdr.seq_le = mc::proto::to_le16((uint16_t)i);
		hdr.len_le = mc::proto::to_le16(1);
		uint8_t raw[mc::proto::MAX_FRAME_DECODED];
		const size_t raw_len =
			build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
		const auto enc = encode_frame(raw, raw_len);
		encoded_all.insert(encoded_all.end(), enc.begin(), enc.end());
	}
	mc::proto::PacketReader reader;
	int frames = 0;
	for (uint8_t b : encoded_all) {
		reader.push(b);
		if (reader.hasFrame()) {
			const auto &f = reader.frame();
			std::cout << "  frame " << frames << " seq=" << f.seq()
					  << " len=" << f.payload_len << "\n";
			frames++;
			reader.consumeFrame();
		}
	}
	std::cout << "  expected frames=2 actual=" << frames << "\n";
	assert(frames == 2);
}
static void test_resync_after_bad_crc() {
	std::cout << "[TEST] resync_after_bad_crc\n";
	uint8_t payload[1] = {0xAA};
	mc::proto::Header hdr{};
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::to_le16(0x10);
	hdr.len_le = mc::proto::to_le16(1);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	raw[sizeof(mc::proto::Header)] ^= 0xFF; 
	const auto bad = encode_frame(raw, raw_len);
	hdr.seq_le = mc::proto::to_le16(0x11);
	const size_t raw_len2 =
		build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	const auto good = encode_frame(raw, raw_len2);
	std::vector< uint8_t > stream;
	stream.insert(stream.end(), bad.begin(), bad.end());
	stream.insert(stream.end(), good.begin(), good.end());
	mc::proto::PacketReader reader;
	int ok_frames = 0;
	for (uint8_t b : stream) {
		reader.push(b);
		if (reader.hasFrame()) {
			const auto &f = reader.frame();
			std::cout << "  got frame seq=" << f.seq() << "\n";
			ok_frames++;
			reader.consumeFrame();
		}
	}
	std::cout << "  expected ok_frames=1 actual=" << ok_frames << "\n";
	assert(ok_frames == 1);
}
static void test_header_and_length_errors() {
	std::cout << "[TEST] header_and_length_errors\n";
	mc::proto::PacketReader reader;
	mc::proto::Header hdr{};
	hdr.magic[0] = 'X';
	hdr.magic[1] = 'Y';
	hdr.ver = mc::proto::VERSION;
	hdr.type = static_cast< uint8_t >(mc::proto::Type::PING);
	hdr.flags = 0;
	hdr.seq_le = mc::proto::to_le16(0x20);
	hdr.len_le = mc::proto::to_le16(0);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	size_t raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	auto enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "  badHdr after bad magic=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 1);
	hdr.magic[0] = mc::proto::MAGIC0;
	hdr.magic[1] = mc::proto::MAGIC1;
	hdr.ver = mc::proto::VERSION + 1;
	raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "  badHdr after bad ver=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 2);
	hdr.ver = mc::proto::VERSION;
	hdr.len_le = mc::proto::to_le16(2);
	uint8_t payload[1] = {0x01};
	raw_len = build_raw_frame(hdr, payload, sizeof(payload), raw, sizeof(raw));
	enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "  badHdr after len mismatch=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 3);
	hdr.len_le = mc::proto::to_le16(mc::proto::MAX_PAYLOAD + 1);
	raw_len = build_raw_frame(hdr, nullptr, 0, raw, sizeof(raw));
	enc = encode_frame(raw, raw_len);
	for (uint8_t b : enc)
		reader.push(b);
	std::cout << "  badHdr after len>MAX=" << reader.badHdr() << "\n";
	assert(reader.badHdr() >= 4);
	const uint8_t bad_cobs[] = {0x02, 0x00};
	for (uint8_t b : bad_cobs)
		reader.push(b);
	std::cout << "  badCobs after bad cobs=" << reader.badCobs() << "\n";
	assert(reader.badCobs() >= 1);
}
int main() {
	test_crc16();
	test_cobs_roundtrip();
	test_cobs_encode_overflow();
	test_min_frame_len0();
	test_max_payload();
	test_back_to_back_frames();
	test_resync_after_bad_crc();
	test_header_and_length_errors();
	test_writer_payload_too_large();
	std::cout << "rpi proto tests ok\n";
	return 0;
}
----------------------------------------

----------------------------------------
File: test/rpi/seriald/test_seriald_integration.py
----------------------------------------
import os
import shutil
import select
import socket
import struct
import subprocess
import sys
import time
from pathlib import Path
import pytest
MAGIC = b"MC"
VER = 1
TYPE_MODE_SET = 0x03
TYPE_LOG = 0x10
TYPE_STATUS = 0x11
FLAG_ACK_REQ = 1 << 0
def crc16_ccitt(data: bytes) -> int:
    crc = 0xFFFF
    for b in data:
        crc ^= (b << 8) & 0xFFFF
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) ^ 0x1021) & 0xFFFF
            else:
                crc = (crc << 1) & 0xFFFF
    return crc
def cobs_encode(inp: bytes) -> bytes:
    out = bytearray()
    out.append(0)
    code = 1
    code_idx = 0
    for b in inp:
        if b == 0:
            out[code_idx] = code
            code = 1
            code_idx = len(out)
            out.append(0)
        else:
            out.append(b)
            code += 1
            if code == 0xFF:
                out[code_idx] = code
                code = 1
                code_idx = len(out)
                out.append(0)
    out[code_idx] = code
    return bytes(out)
def cobs_decode(inp: bytes) -> bytes:
    if not inp:
        return b""
    out = bytearray()
    idx = 0
    while idx < len(inp):
        code = inp[idx]
        if code == 0:
            return b""
        idx += 1
        for _ in range(code - 1):
            if idx >= len(inp):
                return b""
            out.append(inp[idx])
            idx += 1
        if code != 0xFF and idx < len(inp):
            out.append(0)
    return bytes(out)
def build_packet(ptype: int, seq: int, payload: bytes, flags: int = 0) -> bytes:
    hdr = struct.pack(
        "<2sBBBHH", MAGIC, VER, ptype, flags, seq & 0xFFFF, len(payload) & 0xFFFF
    )
    body = hdr + payload
    crc = crc16_ccitt(body)
    decoded = body + struct.pack("<H", crc)
    enc = cobs_encode(decoded) + b"\x00"
    return enc
def decode_packet(enc: bytes):
    if not enc:
        return None
    if enc[-1] == 0:
        enc = enc[:-1]
    raw = cobs_decode(enc)
    if len(raw) < 9 + 2:
        return None
    hdr = raw[:9]
    magic, ver, ptype, flags, seq, plen = struct.unpack("<2sBBBHH", hdr)
    if magic != MAGIC or ver != VER:
        return None
    payload = raw[9:-2]
    if len(payload) != plen:
        return None
    crc_got = struct.unpack("<H", raw[-2:])[0]
    crc_exp = crc16_ccitt(raw[:-2])
    if crc_got != crc_exp:
        return None
    return (ptype, flags, seq, payload)
def read_frame_from_fd(fd: int, timeout_s: float) -> bytes:
    buf = bytearray()
    end = time.time() + timeout_s
    while time.time() < end:
        r, _, _ = select.select([fd], [], [], 0.05)
        if not r:
            continue
        chunk = os.read(fd, 4096)
        if not chunk:
            continue
        buf.extend(chunk)
        if 0 in chunk:
            idx = buf.find(0)
            frame = bytes(buf[: idx + 1])
            return frame
    return b""
@pytest.mark.skipif(
    sys.platform != "linux",
    reason="requires Linux AF_UNIX SOCK_SEQPACKET support",
)
@pytest.mark.skipif(shutil.which("g++") is None, reason="g++ not available")
def test_seriald_uart_ipc_roundtrip(tmp_path: Path):
    repo_root = Path(__file__).resolve().parents[3]
    seriald_dir = repo_root / "rpi/apps/seriald"
    bin_path = tmp_path / "seriald"
    build_cmd = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-O2",
        "-pthread",
        "-I",
        str(seriald_dir / "include"),
        "-I",
        str(seriald_dir / "src"),
        "-I",
        str(repo_root / "shared/proto/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_ipc/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_serial/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_core/include"),
        str(seriald_dir / "src/main.cpp"),
        str(repo_root / "shared/proto/src/mcproto.cpp"),
        str(repo_root / "rpi/lib/mc_ipc/src/UdsSeqPacket.cpp"),
        str(repo_root / "rpi/lib/mc_serial/src/Uart.cpp"),
        str(repo_root / "rpi/lib/mc_core/src/Log.cpp"),
        str(repo_root / "rpi/lib/mc_core/src/Time.cpp"),
        "-o",
        str(bin_path),
    ]
    build = subprocess.run(build_cmd, capture_output=True, text=True)
    assert build.returncode == 0, build.stdout + build.stderr
    print("[INFO] built seriald for test:", bin_path)
    master_fd, slave_fd = os.openpty()
    slave_name = os.ttyname(slave_fd)
    sock_path = Path("/tmp/seriald.sock")
    log_path = Path("/tmp/seriald.log")
    try:
        log_path.unlink()
    except FileNotFoundError:
        pass
    try:
        sock_path.unlink()
    except FileNotFoundError:
        pass
    proc = subprocess.Popen(
        [
            str(bin_path),
            "--dev",
            slave_name,
            "--baud",
            "115200",
            "--sock",
            str(sock_path),
            "--log",
            str(log_path),
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=str(seriald_dir),
    )
    try:
        deadline = time.time() + 2.5
        try:
            sock_path.unlink()
        except FileNotFoundError:
            pass
        uds = None
        sock_type = socket.SOCK_SEQPACKET
        last_err = ""
        while time.time() < deadline:
            if proc.poll() is not None:
                break
            try:
                uds = socket.socket(socket.AF_UNIX, sock_type)
                uds.connect(str(sock_path))
                last_err = ""
                break
            except OSError as e:
                last_err = str(e)
                if uds is not None:
                    uds.close()
                uds = None
                time.sleep(0.05)
        if uds is None:
            proc.terminate()
            try:
                out, err = proc.communicate(timeout=1)
            except subprocess.TimeoutExpired:
                proc.kill()
                out, err = proc.communicate(timeout=1)
            log_text = ""
            if log_path.exists():
                log_text = log_path.read_text(errors="replace")
            assert uds is not None, (
                f"seriald IPC not ready. rc={proc.returncode} last_err={last_err}\n"
                f"stdout:\n{out.decode(errors='replace')}\n"
                f"stderr:\n{err.decode(errors='replace')}\n"
                f"log:\n{log_text}\n"
            )
        mode_payload = bytes([1])
        mode_frame = build_packet(TYPE_MODE_SET, 0x10, mode_payload, FLAG_ACK_REQ)
        print(
            "[INFO] send IPC->UART MODE_SET",
            {
                "type": TYPE_MODE_SET,
                "seq": 0x10,
                "flags": FLAG_ACK_REQ,
                "payload": mode_payload,
            },
        )
        uds.send(mode_frame)
        rx_uart = read_frame_from_fd(master_fd, 1.0)
        print("[INFO] uart rx bytes:", rx_uart)
        assert rx_uart
        dec = decode_packet(rx_uart)
        print("[INFO] uart decoded:", dec)
        assert dec is not None
        ptype, flags, seq, payload = dec
        print(
            "[EXPECT] uart type/flags/seq/payload:",
            TYPE_MODE_SET,
            FLAG_ACK_REQ,
            0x10,
            mode_payload,
        )
        print("[ACTUAL] uart type/flags/seq/payload:", ptype, flags, seq, payload)
        assert ptype == TYPE_MODE_SET
        assert flags == FLAG_ACK_REQ
        assert seq == 0x10
        assert payload == mode_payload
        status_payload = struct.pack("<BBHhhH", 0x22, 1, 0x0002, -10, 25, 100)
        status_frame = build_packet(TYPE_STATUS, 0x33, status_payload, 0)
        print(
            "[INFO] send UART->IPC STATUS",
            {"type": TYPE_STATUS, "seq": 0x33, "flags": 0, "payload": status_payload},
        )
        os.write(master_fd, status_frame)
        r, _, _ = select.select([uds], [], [], 1.0)
        print("[INFO] ipc recv ready:", bool(r))
        assert r
        rx_ipc = uds.recv(4096)
        print("[INFO] ipc rx bytes:", rx_ipc)
        dec2 = decode_packet(rx_ipc)
        print("[INFO] ipc decoded:", dec2)
        assert dec2 is not None
        ptype2, flags2, seq2, payload2 = dec2
        print(
            "[EXPECT] ipc type/flags/seq/payload:", TYPE_STATUS, 0, 0x33, status_payload
        )
        print("[ACTUAL] ipc type/flags/seq/payload:", ptype2, flags2, seq2, payload2)
        assert ptype2 == TYPE_STATUS
        assert flags2 == 0
        assert seq2 == 0x33
        assert payload2 == status_payload
        log_text = "test-log-msg"
        log_payload = bytes([2]) + log_text.encode("utf-8")
        log_frame = build_packet(TYPE_LOG, 0x44, log_payload, 0)
        print(
            "[INFO] send UART->LOG",
            {"type": TYPE_LOG, "seq": 0x44, "flags": 0, "payload": log_payload},
        )
        os.write(master_fd, log_frame)
        deadline = time.time() + 2.0
        found = False
        while time.time() < deadline:
            if log_path.exists():
                txt = log_path.read_text(errors="replace")
                if log_text in txt:
                    found = True
                    break
            time.sleep(0.05)
        print("[EXPECT] log contains:", log_text)
        print("[ACTUAL] log found:", found)
        assert found
    finally:
        if "uds" in locals() and uds is not None:
            uds.close()
        proc.terminate()
        try:
            proc.wait(timeout=2.0)
        except subprocess.TimeoutExpired:
            proc.kill()
        os.close(master_fd)
        os.close(slave_fd)
----------------------------------------

----------------------------------------
File: test/rpi/mc_proto/test_mc_proto_cpp.py
----------------------------------------
import shutil
import subprocess
from pathlib import Path
import pytest
def test_rpi_mc_proto_cpp(tmp_path: Path):
    if shutil.which("g++") is None:
        pytest.skip("g++ not available")
    repo_root = Path(__file__).resolve().parents[3]
    test_cpp = repo_root / "test/rpi/mc_proto/cpp/proto_tests.cpp"
    proto_src = [
        repo_root / "shared/proto/src/mcproto.cpp",
    ]
    output = tmp_path / "mc_proto_tests"
    cmd = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-Wpedantic",
        "-O2",
        "-I",
        str(repo_root / "shared/proto/include"),
        str(test_cpp),
        *[str(path) for path in proto_src],
        "-o",
        str(output),
    ]
    build = subprocess.run(cmd, capture_output=True, text=True)
    print("\n[INFO] build cmd:", " ".join(cmd))
    assert build.returncode == 0, build.stdout + build.stderr
    run = subprocess.run([str(output)], capture_output=False, text=True)
    print("\n[INFO] run bin:", output)
    assert run.returncode == 0, run.stdout + run.stderr
----------------------------------------

----------------------------------------
File: test/rpi/mc_proto/cpp/proto_tests.cpp
----------------------------------------
#include <mc/proto/Proto.hpp>
#include <cassert>
#include <cstring>
#include <iostream>
static void test_writer_ack_roundtrip() {
	std::cout << "[TEST] writer_ack_roundtrip\n";
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const uint16_t seq = 0x1234;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::ACK, 0, seq, nullptr, 0);
	assert(ok);
	assert(enc_len > 0);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < enc_len; ++i) {
		reader.push(enc[i]);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	std::cout << "\texpect type=ACK flags=0 len=0 seq=0x" << std::hex << seq
			  << std::dec << "\n";
	std::cout << "\tactual type=0x" << std::hex << (unsigned)frame.type()
			  << " flags=0x" << (unsigned)frame.flags()
			  << " len=" << frame.payload_len << " seq=0x" << frame.seq()
			  << std::dec << "\n";
	assert(frame.type() == static_cast< uint8_t >(mc::proto::Type::ACK));
	assert(frame.flags() == 0);
	assert(frame.payload_len == 0);
	assert(frame.seq() == seq);
}
static void test_writer_ack_golden_bytes() {
	std::cout << "[TEST] writer_ack_golden_bytes\n";
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const uint16_t seq = 0x1234;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::ACK, 0, seq, nullptr, 0);
	assert(ok);
	const uint8_t expected[] = {0x05, 0x4D, 0x43, 0x01, 0x80, 0x03, 0x34,
								0x12, 0x01, 0x03, 0x67, 0x80, 0x00};
	std::cout << "\tenc_len=" << enc_len << " expected=" << sizeof(expected)
			  << "\n";
	assert(enc_len == sizeof(expected));
	assert(std::memcmp(enc, expected, sizeof(expected)) == 0);
}
static void test_writer_status_roundtrip() {
	std::cout << "[TEST] writer_status_roundtrip\n";
	mc::proto::StatusPayload payload{};
	payload.seq_applied = 0x7B;
	payload.auto_active = 1;
	payload.faults_le = mc::proto::to_le16(0x0005);
	payload.speed_mm_s_le =
		(int16_t)mc::proto::to_le16((uint16_t)(int16_t)-123);
	payload.steer_cdeg_le = (int16_t)mc::proto::to_le16((uint16_t)(int16_t)456);
	payload.age_ms_le = mc::proto::to_le16(250);
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::STATUS, 0, 0x0102,
		reinterpret_cast< const uint8_t * >(&payload), sizeof(payload));
	assert(ok);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < enc_len; ++i) {
		reader.push(enc[i]);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	std::cout << "\texpect len=" << sizeof(payload)
			  << " actual len=" << frame.payload_len << "\n";
	assert(frame.type() == static_cast< uint8_t >(mc::proto::Type::STATUS));
	assert(frame.payload_len == sizeof(payload));
	assert(std::memcmp(frame.payload, &payload, sizeof(payload)) == 0);
}
static void test_writer_log_roundtrip() {
	std::cout << "[TEST] writer_log_roundtrip\n";
	const uint8_t level = 2;
	const char *text = "hello-log";
	const size_t text_len = std::strlen(text);
	uint8_t payload[1 + 16]{};
	payload[0] = level;
	std::memcpy(payload + 1, text, text_len);
	const uint16_t payload_len = (uint16_t)(1 + text_len);
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::LOG, 0, 0x00AA, payload,
		payload_len);
	assert(ok);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < enc_len; ++i) {
		reader.push(enc[i]);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	assert(frame.type() == static_cast< uint8_t >(mc::proto::Type::LOG));
	assert(frame.payload_len == payload_len);
	assert(frame.payload[0] == level);
	assert(std::memcmp(frame.payload + 1, text, text_len) == 0);
}
static void test_writer_ipc_log_record_roundtrip() {
	std::cout << "[TEST] writer_ipc_log_record_roundtrip\n";
	mc::proto::LogRecordPayload header{};
	header.ts_ms = 0x12345678u;
	header.level = 3;
	header.text_len = 6;
	header.flags = 1;
	header.reserved = 0;
	const char *text = "logrec";
	const size_t text_len = std::strlen(text);
	const uint16_t payload_len = (uint16_t)(sizeof(header) + text_len);
	uint8_t payload[64]{};
	std::memcpy(payload, &header, sizeof(header));
	std::memcpy(payload + sizeof(header), text, text_len);
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::IPC_LOG_RECORD, 0, 0x00BB,
		payload, payload_len);
	assert(ok);
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < enc_len; ++i) {
		reader.push(enc[i]);
	}
	assert(reader.hasFrame());
	const auto &frame = reader.frame();
	assert(frame.type() ==
		   static_cast< uint8_t >(mc::proto::Type::IPC_LOG_RECORD));
	assert(frame.payload_len == payload_len);
	mc::proto::LogRecordPayload got{};
	std::memcpy(&got, frame.payload, sizeof(got));
	assert(got.ts_ms == header.ts_ms);
	assert(got.level == header.level);
	assert(got.text_len == header.text_len);
	assert(got.flags == header.flags);
	assert(std::memcmp(frame.payload + sizeof(got), text, text_len) == 0);
}
static void test_writer_rejects_oversize() {
	std::cout << "[TEST] writer_rejects_oversize\n";
	uint8_t payload[mc::proto::MAX_PAYLOAD + 1]{};
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::PING, 0, 0x0001, payload,
		(uint16_t)(mc::proto::MAX_PAYLOAD + 1));
	assert(!ok);
}
static void test_reader_bad_crc() {
	std::cout << "[TEST] reader_bad_crc\n";
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(enc, sizeof(enc), enc_len,
												   mc::proto::Type::PING, 0,
												   0x1234, nullptr, 0);
	assert(ok);
	uint8_t raw[mc::proto::MAX_FRAME_DECODED];
	const size_t raw_len =
		mc::proto::cobs_decode(enc, enc_len - 1, raw, sizeof(raw));
	assert(raw_len >= sizeof(mc::proto::Header) + 2);
	raw[0] ^= 0xFF;
	uint8_t enc_bad[mc::proto::MAX_FRAME_ENCODED];
	const size_t enc_bad_len =
		mc::proto::cobs_encode(raw, raw_len, enc_bad, sizeof(enc_bad));
	assert(enc_bad_len > 0);
	enc_bad[enc_bad_len] = 0x00;
	const size_t total_len = enc_bad_len + 1;
	mc::proto::PacketReader reader;
	for (size_t i = 0; i < total_len; ++i) {
		reader.push(enc_bad[i]);
	}
	assert(!reader.hasFrame());
	assert(reader.badCrc() == 1);
}
int main() {
	test_writer_ack_roundtrip();
	test_writer_ack_golden_bytes();
	test_writer_status_roundtrip();
	test_writer_log_roundtrip();
	test_writer_ipc_log_record_roundtrip();
	test_writer_rejects_oversize();
	test_reader_bad_crc();
	std::cout << "rpi mc_proto tests ok\n";
	return 0;
}
----------------------------------------

----------------------------------------
File: test/rpi/comm/test_placeholder.py
----------------------------------------
import pytest
pytest.skip("placeholder for rpi/comm tests", allow_module_level=True)
----------------------------------------

----------------------------------------
File: test/rpi/comm/test_sender_cpp.py
----------------------------------------
import shutil
import sys
import subprocess
from pathlib import Path
import pytest
@pytest.mark.skipif(
    sys.platform != "linux",
    reason="requires Linux AF_UNIX SOCK_SEQPACKET support",
)
def test_sender_cpp(tmp_path: Path):
    if shutil.which("g++") is None:
        pytest.skip("g++ not available")
    repo_root = Path(__file__).resolve().parents[3]
    test_cpp = repo_root / "test/rpi/comm/cpp/sender_tests.cpp"
    src = [
        repo_root / "rpi/src/Sender.cpp",
        repo_root / "shared/proto/src/mcproto.cpp",
        repo_root / "rpi/lib/mc_ipc/src/UdsSeqPacket.cpp",
        repo_root / "rpi/lib/mc_core/src/Log.cpp",
        repo_root / "rpi/lib/mc_core/src/Time.cpp",
    ]
    output = tmp_path / "sender_tests"
    cmd = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-Wpedantic",
        "-O2",
        "-pthread",
        "-I",
        str(repo_root / "rpi/src"),
        "-I",
        str(repo_root / "shared/proto/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_ipc/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_core/include"),
        str(test_cpp),
        *[str(path) for path in src],
        "-o",
        str(output),
    ]
    build = subprocess.run(cmd, capture_output=True, text=True)
    print("\n[INFO] build cmd:", " ".join(cmd))
    assert build.returncode == 0, build.stdout + build.stderr
    run = subprocess.run([str(output)], capture_output=True, text=True)
    print("\n[INFO] run bin:", output)
    assert run.returncode == 0, (run.stdout or "") + (run.stderr or "")
----------------------------------------

----------------------------------------
File: test/rpi/comm/cpp/sender_tests.cpp
----------------------------------------
#include "Sender.h"
#include <mc/proto/Proto.hpp>
#include <cassert>
#include <chrono>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
namespace {
static const char *kSockPath = "/tmp/seriald_sender.sock";
int make_server_socket() {
	int fd = ::socket(AF_UNIX, MC_IPC_DEFAULT_SOCK_TYPE, 0);
	assert(fd >= 0);
	::unlink(kSockPath);
	sockaddr_un addr{};
	addr.sun_family = AF_UNIX;
	std::snprintf(addr.sun_path, sizeof(addr.sun_path), "%s", kSockPath);
	const int rc = ::bind(fd, (sockaddr *)&addr, sizeof(addr));
	assert(rc == 0);
	const int lrc = ::listen(fd, 1);
	assert(lrc == 0);
	return fd;
}
bool recv_frame(int fd,
				std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > &buf,
				size_t &len, int timeout_ms) {
	fd_set rfds;
	FD_ZERO(&rfds);
	FD_SET(fd, &rfds);
	timeval tv{};
	tv.tv_sec = timeout_ms / 1000;
	tv.tv_usec = (timeout_ms % 1000) * 1000;
	const int r = ::select(fd + 1, &rfds, nullptr, nullptr, &tv);
	if (r <= 0)
		return false;
	len = (size_t)::recv(fd, buf.data(), buf.size(), 0);
	return len > 0;
}
bool decode(const std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > &buf,
			size_t len, mc::proto::Frame &out) {
	std::array< uint8_t, mc::proto::MAX_FRAME_DECODED > decoded{};
	return mc::proto::decode_one(buf.data(), len, out, decoded);
}
bool send_ack(int fd, uint16_t seq) {
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		enc, sizeof(enc), enc_len, mc::proto::Type::ACK, 0, seq, nullptr, 0);
	if (!ok)
		return false;
	const ssize_t sent = ::send(fd, enc, enc_len, 0);
	return sent > 0;
}
std::string hex_bytes(const uint8_t *p, size_t n) {
	static const char *hex = "0123456789abcdef";
	std::string s;
	for (size_t i = 0; i < n; ++i) {
		unsigned v = p[i];
		s.push_back(hex[v >> 4]);
		s.push_back(hex[v & 0x0F]);
	}
	return s;
}
} 
static void test_sender_mode_set_ack() {
	std::cout << "[TEST] sender_mode_set_ack\n";
	const int srv_fd = make_server_socket();
	Sender sender(kSockPath);
	const int cfd = ::accept(srv_fd, nullptr, nullptr);
	assert(cfd >= 0);
	std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > buf{};
	size_t len = 0;
	const bool got = recv_frame(cfd, buf, len, 500);
	assert(got);
	mc::proto::Frame f{};
	const bool ok = decode(buf, len, f);
	assert(ok);
	std::cout << "\tRX type=0x" << std::hex << (unsigned)f.type() << " flags=0x"
			  << (unsigned)f.flags() << " seq=0x" << f.seq() << std::dec
			  << " payload=" << hex_bytes(f.payload, f.payload_len) << "\n";
	assert(f.type() == (uint8_t)mc::proto::Type::MODE_SET);
	assert(f.flags() == mc::proto::FLAG_ACK_REQ);
	assert(f.payload_len == 1);
	const uint16_t seq = f.seq();
	assert(send_ack(cfd, seq));
	sender.poll();
	::close(cfd);
	::close(srv_fd);
	std::cout << "\tACK sent for seq=0x" << std::hex << seq << std::dec << "\n";
}
static void test_sender_auto_disabled_no_drive() {
	std::cout << "[TEST] sender_auto_disabled_no_drive\n";
	const int srv_fd = make_server_socket();
	Sender sender(kSockPath);
	const int cfd = ::accept(srv_fd, nullptr, nullptr);
	assert(cfd >= 0);
	std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > buf{};
	size_t len = 0;
	if (recv_frame(cfd, buf, len, 500)) {
		mc::proto::Frame f{};
		if (decode(buf, len, f) &&
			f.type() == (uint8_t)mc::proto::Type::MODE_SET &&
			(f.flags() & mc::proto::FLAG_ACK_REQ)) {
			send_ack(cfd, f.seq());
			sender.poll();
		}
	}
	sender.sendAutoMode(false);
	if (recv_frame(cfd, buf, len, 500)) {
		mc::proto::Frame f{};
		if (decode(buf, len, f) &&
			f.type() == (uint8_t)mc::proto::Type::MODE_SET &&
			(f.flags() & mc::proto::FLAG_ACK_REQ)) {
			send_ack(cfd, f.seq());
			sender.poll();
		}
	}
	sender.send(100, 10);
	bool saw_drive = false;
	const auto deadline =
		std::chrono::steady_clock::now() + std::chrono::milliseconds(250);
	while (std::chrono::steady_clock::now() < deadline) {
		const bool got = recv_frame(cfd, buf, len, 50);
		if (!got)
			continue;
		mc::proto::Frame f{};
		if (!decode(buf, len, f))
			continue;
		if (f.type() == (uint8_t)mc::proto::Type::DRIVE) {
			saw_drive = true;
			break;
		}
		if (f.type() == (uint8_t)mc::proto::Type::MODE_SET &&
			(f.flags() & mc::proto::FLAG_ACK_REQ)) {
			send_ack(cfd, f.seq());
			sender.poll();
		}
	}
	std::cout << "\tEXPECT no DRIVE, actual=" << (saw_drive ? "drive" : "none")
			  << "\n";
	assert(!saw_drive);
	::close(cfd);
	::close(srv_fd);
}
static void test_sender_ping_interval() {
	std::cout << "[TEST] sender_ping_interval\n";
	const int srv_fd = make_server_socket();
	Sender sender(kSockPath);
	const int cfd = ::accept(srv_fd, nullptr, nullptr);
	assert(cfd >= 0);
	std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > buf{};
	size_t len = 0;
	recv_frame(cfd, buf, len, 500);
	sender.send(0, 0);
	std::this_thread::sleep_for(
		std::chrono::milliseconds(cfg::HEARTBEAT_INTERVAL_MS + 10));
	sender.send(0, 0);
	bool saw_ping = false;
	for (int i = 0; i < 3; ++i) {
		const bool got = recv_frame(cfd, buf, len, 200);
		if (!got)
			break;
		mc::proto::Frame f{};
		if (!decode(buf, len, f))
			continue;
		if (f.type() == (uint8_t)mc::proto::Type::PING)
			saw_ping = true;
		std::cout << "\tRX type=0x" << std::hex << (unsigned)f.type()
				  << std::dec << "\n";
	}
	std::cout << "\tEXPECT ping=true, actual=" << (saw_ping ? "true" : "false")
			  << "\n";
	assert(saw_ping);
	::close(cfd);
	::close(srv_fd);
}
static void test_sender_ack_retry() {
	std::cout << "[TEST] sender_ack_retry\n";
	const int srv_fd = make_server_socket();
	Sender sender(kSockPath);
	const int cfd = ::accept(srv_fd, nullptr, nullptr);
	assert(cfd >= 0);
	std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > buf{};
	size_t len = 0;
	recv_frame(cfd, buf, len, 500); 
	sender.sendKill();
	int count = 0;
	const auto deadline =
		std::chrono::steady_clock::now() + std::chrono::milliseconds(400);
	while (std::chrono::steady_clock::now() < deadline) {
		sender.poll();
		if (recv_frame(cfd, buf, len, 50)) {
			mc::proto::Frame f{};
			if (decode(buf, len, f) &&
				f.type() == (uint8_t)mc::proto::Type::KILL) {
				count++;
			}
		}
		std::this_thread::sleep_for(
			std::chrono::milliseconds(cfg::ACK_TIMEOUT_MS + 5));
	}
	std::cout << "\tEXPECT retries>=2, actual=" << count << "\n";
	assert(count >= 2);
	::close(cfd);
	::close(srv_fd);
}
int main() {
	test_sender_mode_set_ack();
	test_sender_auto_disabled_no_drive();
	test_sender_ping_interval();
	test_sender_ack_retry();
	std::cout << "sender tests ok\n";
	return 0;
}
----------------------------------------

----------------------------------------
File: test/rpi/hils/cpp/racerd_stub.cpp
----------------------------------------
#include <mc/proto/Proto.hpp>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>
#include <string>
static bool send_frame(int fd, mc::proto::Type type, uint16_t seq,
					   const uint8_t *payload, uint16_t payload_len) {
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	if (!mc::proto::PacketWriter::build(enc, sizeof(enc), enc_len, type, 0, seq,
										payload, payload_len)) {
		return false;
	}
	return ::send(fd, enc, enc_len, 0) == (ssize_t)enc_len;
}
int main(int argc, char **argv) {
	if (argc < 2) {
		std::fprintf(stderr, "usage: %s <sock_path>\n", argv[0]);
		return 1;
	}
	const std::string sock_path = argv[1];
	int fd = ::socket(AF_UNIX, SOCK_SEQPACKET, 0);
	if (fd < 0) {
		perror("socket");
		return 1;
	}
	sockaddr_un addr{};
	addr.sun_family = AF_UNIX;
	std::snprintf(addr.sun_path, sizeof(addr.sun_path), "%s",
				  sock_path.c_str());
	if (::connect(fd, reinterpret_cast< sockaddr * >(&addr), sizeof(addr)) !=
		0) {
		perror("connect");
		::close(fd);
		return 1;
	}
	uint8_t mode = 1;
	if (!send_frame(fd, mc::proto::Type::MODE_SET, 1, &mode, 1)) {
		::close(fd);
		return 1;
	}
	mc::proto::DrivePayload drive{};
	drive.steer_cdeg = 100;
	drive.speed_mm_s = 200;
	drive.ttl_ms_le = mc::proto::host_to_le16(50);
	drive.dist_mm_le = 0;
	if (!send_frame(fd, mc::proto::Type::DRIVE, 2,
					reinterpret_cast< const uint8_t * >(&drive),
					sizeof(drive))) {
		::close(fd);
		return 1;
	}
	::close(fd);
	return 0;
}
----------------------------------------

----------------------------------------
File: test/rpi/hils/test_hils_e2e.py
----------------------------------------
import os
import select
import shutil
import socket
import struct
import subprocess
import sys
import threading
import time
from pathlib import Path
import pytest
MAGIC = b"MC"
VER = 1
TYPE_DRIVE = 0x01
TYPE_KILL = 0x02
TYPE_MODE_SET = 0x03
TYPE_PING = 0x04
TYPE_STATUS = 0x11
TYPE_ACK = 0x80
FLAG_ACK_REQ = 1 << 0
FAULT_KILL = 1 << 0
FAULT_TTL = 1 << 2
FAULT_AUTO_INACTIVE = 1 << 3
def crc16_ccitt(data: bytes) -> int:
    crc = 0xFFFF
    for b in data:
        crc ^= (b << 8) & 0xFFFF
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) ^ 0x1021) & 0xFFFF
            else:
                crc = (crc << 1) & 0xFFFF
    return crc
def cobs_encode(inp: bytes) -> bytes:
    out = bytearray()
    out.append(0)
    code = 1
    code_idx = 0
    for b in inp:
        if b == 0:
            out[code_idx] = code
            code = 1
            code_idx = len(out)
            out.append(0)
        else:
            out.append(b)
            code += 1
            if code == 0xFF:
                out[code_idx] = code
                code = 1
                code_idx = len(out)
                out.append(0)
    out[code_idx] = code
    return bytes(out)
def cobs_decode(inp: bytes) -> bytes:
    if not inp:
        return b""
    out = bytearray()
    idx = 0
    while idx < len(inp):
        code = inp[idx]
        if code == 0:
            return b""
        idx += 1
        for _ in range(code - 1):
            if idx >= len(inp):
                return b""
            out.append(inp[idx])
            idx += 1
        if code != 0xFF and idx < len(inp):
            out.append(0)
    return bytes(out)
def build_packet(ptype: int, seq: int, payload: bytes, flags: int = 0) -> bytes:
    hdr = struct.pack(
        "<2sBBBHH", MAGIC, VER, ptype, flags, seq & 0xFFFF, len(payload) & 0xFFFF
    )
    body = hdr + payload
    crc = crc16_ccitt(body)
    decoded = body + struct.pack("<H", crc)
    enc = cobs_encode(decoded) + b"\x00"
    return enc
def decode_packet(enc: bytes):
    if not enc:
        return None
    if enc[-1] == 0:
        enc = enc[:-1]
    raw = cobs_decode(enc)
    if len(raw) < 9 + 2:
        return None
    hdr = raw[:9]
    magic, ver, ptype, flags, seq, plen = struct.unpack("<2sBBBHH", hdr)
    if magic != MAGIC or ver != VER:
        return None
    payload = raw[9:-2]
    if len(payload) != plen:
        return None
    crc_got = struct.unpack("<H", raw[-2:])[0]
    crc_exp = crc16_ccitt(raw[:-2])
    if crc_got != crc_exp:
        return None
    return (ptype, flags, seq, payload)
def wait_for_socket(path: Path, timeout_s: float) -> socket.socket | None:
    end = time.time() + timeout_s
    last_err = ""
    while time.time() < end:
        try:
            uds = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            uds.connect(str(path))
            return uds
        except OSError as e:
            last_err = str(e)
            time.sleep(0.05)
    raise RuntimeError(f"failed to connect socket: {last_err}")
def recv_frame(sock: socket.socket, timeout_s: float) -> bytes:
    end = time.time() + timeout_s
    while time.time() < end:
        r, _, _ = select.select([sock], [], [], 0.05)
        if not r:
            continue
        data = sock.recv(4096)
        if data:
            return data
    return b""
def relay_loop(stop: threading.Event, m1: int, m2: int) -> None:
    while not stop.is_set():
        r, _, _ = select.select([m1, m2], [], [], 0.05)
        for fd in r:
            try:
                data = os.read(fd, 4096)
            except OSError:
                continue
            if not data:
                continue
            other = m2 if fd == m1 else m1
            try:
                os.write(other, data)
            except OSError:
                continue
@pytest.mark.skipif(
    sys.platform != "linux",
    reason="requires Linux AF_UNIX SOCK_SEQPACKET support",
)
@pytest.mark.skipif(shutil.which("g++") is None, reason="g++ not available")
def test_hils_e2e_seriald_sim_esp32d(tmp_path: Path):
    repo_root = Path(__file__).resolve().parents[3]
    seriald_dir = repo_root / "rpi/apps/seriald"
    sim_dir = repo_root / "rpi/apps/sim_esp32d"
    stub_dir = repo_root / "test/rpi/hils/cpp"
    seriald_bin = tmp_path / "seriald"
    sim_bin = tmp_path / "sim_esp32d"
    stub_bin = tmp_path / "racerd_stub"
    build_seriald = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-O2",
        "-pthread",
        "-I",
        str(seriald_dir / "include"),
        "-I",
        str(seriald_dir / "src"),
        "-I",
        str(repo_root / "shared/proto/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_ipc/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_serial/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_core/include"),
        str(seriald_dir / "src/main.cpp"),
        str(repo_root / "shared/proto/src/mcproto.cpp"),
        str(repo_root / "rpi/lib/mc_ipc/src/UdsSeqPacket.cpp"),
        str(repo_root / "rpi/lib/mc_serial/src/Uart.cpp"),
        str(repo_root / "rpi/lib/mc_core/src/Log.cpp"),
        str(repo_root / "rpi/lib/mc_core/src/Time.cpp"),
        "-o",
        str(seriald_bin),
    ]
    build_sim = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-O2",
        "-pthread",
        "-I",
        str(repo_root / "shared/proto/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_serial/include"),
        "-I",
        str(repo_root / "rpi/lib/mc_core/include"),
        str(sim_dir / "src/main.cpp"),
        str(repo_root / "shared/proto/src/mcproto.cpp"),
        str(repo_root / "rpi/lib/mc_serial/src/Uart.cpp"),
        str(repo_root / "rpi/lib/mc_core/src/Log.cpp"),
        str(repo_root / "rpi/lib/mc_core/src/Time.cpp"),
        "-o",
        str(sim_bin),
    ]
    build_stub = [
        "g++",
        "-std=c++17",
        "-Wall",
        "-Wextra",
        "-O2",
        "-I",
        str(repo_root / "shared/proto/include"),
        str(stub_dir / "racerd_stub.cpp"),
        str(repo_root / "shared/proto/src/mcproto.cpp"),
        "-o",
        str(stub_bin),
    ]
    build = subprocess.run(build_seriald, capture_output=True, text=True)
    assert build.returncode == 0, build.stdout + build.stderr
    build = subprocess.run(build_sim, capture_output=True, text=True)
    assert build.returncode == 0, build.stdout + build.stderr
    build = subprocess.run(build_stub, capture_output=True, text=True)
    assert build.returncode == 0, build.stdout + build.stderr
    m1, s1 = os.openpty()
    m2, s2 = os.openpty()
    s1_name = os.ttyname(s1)
    s2_name = os.ttyname(s2)
    stop = threading.Event()
    relay = threading.Thread(target=relay_loop, args=(stop, m1, m2), daemon=True)
    relay.start()
    sock_path = Path("/tmp/seriald.sock")
    log_path = Path("/tmp/seriald.log")
    for p in (sock_path, log_path):
        try:
            p.unlink()
        except FileNotFoundError:
            pass
    seriald_proc = subprocess.Popen(
        [
            str(seriald_bin),
            "--dev",
            s1_name,
            "--baud",
            "115200",
            "--sock",
            str(sock_path),
            "--log",
            str(log_path),
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=str(seriald_dir),
    )
    sim_proc = subprocess.Popen(
        [
            str(sim_bin),
            "--dev",
            s2_name,
            "--baud",
            "115200",
            "--status-ms",
            "20",
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=str(sim_dir),
    )
    uds = None
    try:
        uds = wait_for_socket(sock_path, 2.5)
        stub_run = subprocess.run(
            [str(stub_bin), str(sock_path)], capture_output=True, text=True
        )
        assert stub_run.returncode == 0, stub_run.stdout + stub_run.stderr
        status = None
        last_status = None
        deadline = time.time() + 1.0
        while time.time() < deadline:
            pkt = decode_packet(recv_frame(uds, 0.2))
            if pkt and pkt[0] == TYPE_STATUS:
                last_status = pkt
                _, _, _, payload = pkt
                (
                    seq_applied,
                    auto_active,
                    faults,
                    speed,
                    steer,
                    _age,
                ) = struct.unpack("<BBHhhH", payload)
                if (
                    auto_active == 1
                    and speed == 200
                    and steer == 100
                    and seq_applied == 2
                    and (faults & FAULT_AUTO_INACTIVE) == 0
                ):
                    status = pkt
                    break
        if status is None and last_status is not None:
            _, _, _, payload = last_status
            seq_applied, auto_active, faults, speed, steer, _age = struct.unpack(
                "<BBHhhH", payload
            )
            last_msg = (
                "last STATUS: auto_active="
                + str(auto_active)
                + " speed="
                + str(speed)
                + " steer="
                + str(steer)
                + " seq_applied="
                + str(seq_applied)
                + " faults=0x%04x" % faults
            )
        else:
            last_msg = "no STATUS matching MODE_SET/DRIVE"
        assert status is not None, last_msg
        time.sleep(0.08)
        status = None
        deadline = time.time() + 1.0
        while time.time() < deadline:
            pkt = decode_packet(recv_frame(uds, 0.2))
            if pkt and pkt[0] == TYPE_STATUS:
                status = pkt
                if struct.unpack("<BBHhhH", status[3])[2] & FAULT_TTL:
                    break
        assert status is not None, "no STATUS after TTL"
        _, _, _, payload = status
        _seq_applied, _auto_active, faults, speed, steer, _age = struct.unpack(
            "<BBHhhH", payload
        )
        assert (faults & FAULT_TTL) != 0
        assert speed == 0
        assert steer == 0
        uds.send(build_packet(TYPE_KILL, 3, b"", 0))
        status = None
        deadline = time.time() + 1.0
        while time.time() < deadline:
            pkt = decode_packet(recv_frame(uds, 0.2))
            if pkt and pkt[0] == TYPE_STATUS:
                status = pkt
                if struct.unpack("<BBHhhH", status[3])[2] & FAULT_KILL:
                    break
        assert status is not None, "no STATUS after KILL"
        _, _, _, payload = status
        _seq_applied, _auto_active, faults, speed, steer, _age = struct.unpack(
            "<BBHhhH", payload
        )
        assert (faults & FAULT_KILL) != 0
        assert speed == 0
        assert steer == 0
        uds.send(build_packet(TYPE_PING, 4, b"", FLAG_ACK_REQ))
        ack = None
        deadline = time.time() + 1.0
        while time.time() < deadline:
            pkt = decode_packet(recv_frame(uds, 0.2))
            if pkt and pkt[0] == TYPE_ACK:
                ack = pkt
                break
        assert ack is not None, "no ACK received"
        assert ack[2] == 4
    finally:
        if uds is not None:
            uds.close()
        for proc in (sim_proc, seriald_proc):
            if proc.poll() is None:
                proc.terminate()
                try:
                    proc.communicate(timeout=1)
                except subprocess.TimeoutExpired:
                    proc.kill()
                    proc.communicate(timeout=1)
        stop.set()
        relay.join(timeout=1)
        for fd in (m1, s1, m2, s2):
            try:
                os.close(fd)
            except OSError:
                pass
----------------------------------------

----------------------------------------
File: Makefile
----------------------------------------
OS			:= $(shell uname -s)
USER		:= $(shell whoami)
RM 			:= rm -rf
ifeq ($(OS), Darwin)
ROS2_DISPLAY ?= host.docker.internal:0
ROS2_LIBGL_ALWAYS_SOFTWARE ?= 1
ROS2_QT_XCB_GL_INTEGRATION ?= none
ROS2_XDG_RUNTIME_DIR ?= /tmp/runtime-root
ROS2_GUI_ENV := DISPLAY=$(ROS2_DISPLAY) \
	LIBGL_ALWAYS_SOFTWARE=$(ROS2_LIBGL_ALWAYS_SOFTWARE) \
	QT_XCB_GL_INTEGRATION=$(ROS2_QT_XCB_GL_INTEGRATION) \
	XDG_RUNTIME_DIR=$(ROS2_XDG_RUNTIME_DIR)
else
ROS2_GUI_ENV :=
endif
ROOT				:= .
VENV				:= $(ROOT)/.venv
TEST_DIR			:= $(ROOT)/test
LOG_DIR				:= $(ROOT)/logs
PIO_DIR				:= $(ROOT)/.pio
PIO_ENV				?= esp32dev
PIO_BUILD_DIR		:= $(PIO_DIR)/build/$(PIO_ENV)
PIO_BUILD_SRC_DIR	:= $(PIO_BUILD_DIR)/src
FIRMWARE_DIR		:= $(ROOT)/firmware
FIRMWARE_SRC_DIR	:= $(FIRMWARE_DIR)/src
FIRMWARE			:= $(PIO_BUILD_DIR)/firmware.elf
RPI_SRC_DIR			:= $(ROOT)/rpi/src
RPI_LIB_DIR			:= $(ROOT)/rpi/lib
RPI_BUILD_DIR		:= $(ROOT)/rpi/build
RPI_BUILD_TYPE		?= Release
TSAN				?= 0
ifeq ($(TSAN),1)
  RPI_BUILD_TYPE	:= RelWithDebInfo
  RPI_TSAN			:= -DROBO_RACER_TSAN=ON
else
  RPI_TSAN			:=
endif
RPLIDAR_SDK_DIR		:= $(RPI_LIB_DIR)/rplidar_sdk
RPLIDAR_INC			:= $(RPLIDAR_SDK_DIR)/sdk/include
RPLIDAR_SRC			:= $(RPLIDAR_SDK_DIR)/sdk/src
RPLIDAR_LIB			:= $(RPLIDAR_SDK_DIR)/output/$(OS)/Release
RPLIDAR_SDK_MAKE	:= $(RPLIDAR_SDK_DIR)/Makefile
NAME		:= robo-racer
APP_SERIALD	:= seriald
CMAKE		?= cmake
ifeq ($(OS), Linux)
  UP_PORT	:= /dev/ttyUSB0
else ifeq ($(OS), Darwin)
  UP_PORT	:= /dev/tty.SLAB_USBtoUART
else ifeq ($(OS), Windows_NT)
  UP_PORT	:= COM3
endif
PIO				?= $(VENV)/bin/pio
PIO_ARG_ENV		?= -e $(PIO_ENV)
PIO_ARG_CLEAN	:= -t clean
PIO_ARG_UPLOAD	:= $(PIO_ARG_ENV) -t upload --upload-port $(UP_PORT)
PIO_RUN			:= $(PIO) run -j $(shell nproc)
.PHONY: all
all: pio rpi
	@if [ "$(USER)" = "pi" ]; then $(MAKE) upload; fi
.PHONY: rpi c-rpi
$(NAME): rpi
rpi: | rplidar_sdk $(LOG_DIR)
	$(CMAKE) -S $(ROOT)/rpi -B $(RPI_BUILD_DIR) -DCMAKE_BUILD_TYPE=$(RPI_BUILD_TYPE) -DROBO_RACER_NAME=$(NAME) $(RPI_TSAN)
	$(CMAKE) --build $(RPI_BUILD_DIR) -j $(shell nproc)
c-rpi:
	$(RM) $(RPI_BUILD_DIR)
.PHONY: pio upload monitor c-pio fc-pio
pio:
	$(PIO_RUN) $(PIO_ARG_ENV)
upload:
	$(PIO_RUN) $(PIO_ARG_UPLOAD)
monitor:
	$(PIO) device monitor
c-pio:
	$(RM) $(PIO_BUILD_SRC_DIR)
fc-pio:
	$(PIO_RUN) $(PIO_ARG_CLEAN)
.PHONY: clean fclean re c f r clog
clean: c-rpi fc-pio clog
fclean: clean
	$(MAKE) -C $(RPLIDAR_SDK_DIR) clean
	$(RM) $(PIO_DIR)
	$(RM) $(NAME)
re: fclean all
c: clog c-pio c-rpi
f: c
	$(RM) $(FIRMWARE)
	$(RM) $(NAME)
r: f all
clog:
	$(RM) $(LOG_DIR)/*.log*
$(LOG_DIR):
	@mkdir -p $(LOG_DIR)
.PHONY: test activate hils-build hils-local ros2-up ros2-shell ros2-build ros2-build-clean \
	ros2-mc-bridge ros2-topic-echo \
	ros2-rviz ros2-novnc ros2-bag-record ros2-bag-play ros2-session-up
hils-build:
	$(CMAKE) -S $(ROOT)/rpi -B $(RPI_BUILD_DIR) -DCMAKE_BUILD_TYPE=Release
	$(CMAKE) --build $(RPI_BUILD_DIR) --target seriald sim_esp32d -j $(shell nproc)
hils-local: hils-build $(PYTHON_LOCAL)
	$(PYTHON_LOCAL) $(ROOT)/tools/hils/run_local_e2e.py \
		--seriald $(RPI_BUILD_DIR)/apps/seriald/seriald \
		--sim $(RPI_BUILD_DIR)/apps/sim_esp32d/sim_esp32d
ros2-up:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml up -d
ros2-shell:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm ros2 bash
ros2-build:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm ros2 \
		bash /ws/tools/ros2/scripts/ros2_build.sh
ros2-build-clean:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm ros2 \
		bash -lc "rm -rf /ws/rpi/ros2_ws/build /ws/rpi/ros2_ws/install /ws/rpi/ros2_ws/log && /ws/tools/ros2/scripts/ros2_build.sh"
ros2-mc-bridge:
	@if [ -z "$(HOST)" ]; then \
		echo "Error: HOST パラメータが未設定です。例: make ros2-mc-bridge HOST=100.102.92.54"; \
		exit 1; \
	fi
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm ros2 \
		bash -c "source /opt/ros/humble/setup.bash; source /ws/rpi/ros2_ws/install/setup.bash; \
		ros2 run mc_bridge mc_bridge --ros-args -p telemetry_tcp_host:=$(HOST) -p telemetry_tcp_port:=5001"
ros2-topic-echo:
	@if [ -z "$(TOPIC)" ]; then \
		echo "Error: TOPIC パラメータが未設定です。例: make ros2-topic-echo TOPIC=/mc/status TYPE=mc_msgs/msg/Status ONCE=1"; \
		exit 1; \
	fi; \
	CMD="ros2 topic echo $(TOPIC)"; \
	if [ -n "$(TYPE)" ]; then CMD="$$CMD $(TYPE)"; fi; \
	if [ "$(ONCE)" = "1" ]; then CMD="$$CMD --once"; fi; \
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm ros2 \
		bash -c "source /opt/ros/humble/setup.bash; source /ws/rpi/ros2_ws/install/setup.bash; $$CMD"
ros2-rviz:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm ros2 \
		bash -lc "rviz2 -d /ws/tools/ros2/rviz/default.rviz"
ros2-novnc:
	docker compose -f tools/ros2/compose.yml up ros2-novnc
ros2-bag-record:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm \
		-e RUN_ID -e TOPICS -e PROFILE -e OUT_DIR -e PUBLISH_RUN_ID -e NOTES -e RUN_NOTES \
		-e WAIT_SEC -e REQUIRE_AT_LEAST_ONE \
		ros2 \
		bash /ws/tools/ros2/scripts/bag_record.sh
ros2-bag-play:
	@if [ -z "$(BAG)" ]; then \
		echo "Error: BAG パラメータが未設定です。例: make ros2-bag-play BAG=/path/to/bag"; \
		exit 1; \
	fi
	docker compose -f tools/ros2/compose.yml run --rm ros2 \
		bash /ws/tools/ros2/scripts/bag_play.sh $(BAG)
ros2-session-up:
	$(ROS2_GUI_ENV) docker compose -f tools/ros2/compose.yml run --rm \
		-e RUN_ID -e TOPICS -e PROFILE -e OUT_DIR -e PUBLISH_RUN_ID -e NOTES -e RUN_NOTES \
		-e WAIT_SEC -e REQUIRE_AT_LEAST_ONE -e SESSION_CMD -e SESSION_WAIT_SEC \
		ros2 \
		bash /ws/tools/ros2/scripts/session_up.sh
test: $(PYTHON_LOCAL)
	$(MAKE) all
	$(VENV)/bin/pytest -svv
activate: $(PYTHON_LOCAL)
	@bash -lc 'source "$(VENV)/bin/activate" && exec $$SHELL -l'
.PHONY: debug debug-gdb
debug: OPT		:= -O0 -g3 -ggdb
debug: fclean
	$(PIO) debug $(PIO_ARGS_ENV)
	$(MAKE) $(NAME) -j $(shell nproc) OPT="$(OPT)"
debug-gdb:
	$(PIO) debug -s $(PIO_BUILD_DIR) --interface gdb -p
.PHONY: rplidar_sdk
rplidar_sdk: $(RPLIDAR_SDK_MAKE)
	$(MAKE) -C $(RPLIDAR_SDK_DIR)/sdk CEXTRA=-w CXXEXTRA=-w
$(RPLIDAR_SDK_MAKE):
	@$(RM) $(RPLIDAR_SDK_DIR)
	@echo "[Submodule] Initializing rplidar_sdk..."
	@git submodule update --init --recursive $(RPLIDAR_SDK_DIR)
.PHONY: init setuphooks pysync purge
UV_LOCAL     := $(VENV)/bin/uv
PIP_LOCAL    := $(VENV)/bin/pip
PYTHON_LOCAL := $(VENV)/bin/python
UV_GLOBAL    := $(shell command -v uv 2>/dev/null)
ifeq ($(strip $(UV_GLOBAL)),)
  UV := $(UV_LOCAL)
else
  UV := $(UV_GLOBAL)
endif
init: setuphooks pysync
setuphooks:
	@git config --local core.hooksPath .githooks
	@chmod -R 744 .githooks/
pysync: $(PYTHON_LOCAL)
	@$(UV) sync --all-extras
$(PYTHON_LOCAL):
	@if [ -n "$(UV_GLOBAL)" ]; then \
		"$(UV_GLOBAL)" venv "$(VENV)"; \
	else \
		echo "[Venv] Global 'uv' not found. Using 'python3 -m venv' as fallback..."; \
		python3 -m venv "$(VENV)"; \
		echo "[Venv] Installing 'uv' inside '$(VENV)' using pip..."; \
		"$(PIP_LOCAL)" install --upgrade pip uv; \
	fi
	@echo "[Venv] Virtual environment created successfully."
purge: f
	$(RM) $(VENV)
	$(RM) uv.lock
	@echo "🧹 Clean up complete."
.PHONY: nm nmbin printsrc printobj fill view submodule rplidar_sdk help
nm:
	@nm $(OBJ) | grep ' U ' | awk '{print $$2}' | sort | uniq
nmbin:
	@nm $(NAME) | grep ' U ' | awk '{print $$2}' | sort | uniq
printsrc:
	@echo $(SRC) | tr ' ' '\n' | sort
printobj:
	@echo $(OBJ) | tr ' ' '\n' | sort
fill:
	@./tools/fillEmptyDir.sh
view:
	@./tools/rawCodeViewer.sh
submodule:
	git submodule update --init --recursive
help:
	@echo "Usage: make [target]"
	@echo ""
	@echo "Build Targets:"
	@echo "  all              Build firmware (pio run) and RPi executable"
	@echo "  pio              Build firmware (PlatformIO)"
	@echo "  upload           Upload firmware to the device (pio run -t upload)"
	@echo "  rpi              Build RPi executable (auto-builds RPLIDAR SDK)"
	@echo "  c-rpi            Clean RPi build directory"
	@echo "  clean            Clean RPi builds, PlatformIO build sources, and logs"
	@echo "  c-pio            Clean PlatformIO build source outputs"
	@echo "  fc-pio           PlatformIO full clean (pio run -t clean)"
	@echo "  fclean           Fully clean (clean + remove .pio)"
	@echo "  re               Rebuild (fclean + all)"
	@echo "  clog             Clean log files"
	@echo "  c                Workflow: runs 'clog', 'c-pio', then 'c-rpi'"
	@echo "  f                Workflow: includes 'c', removes firmware + $(NAME)"
	@echo "  r                Workflow: runs 'f', rebuilds everything via 'all'"
	@echo ""
	@echo "Run Targets:"
	@echo "  test             Run Python tests using pytest"
	@echo "  activate         Activate the Python virtual environment"
	@echo "  hils-build       Build seriald + sim_esp32d for HILS"
	@echo "  hils-local       Run local HILS (seriald + sim_esp32d)"
	@echo "  monitor          Open serial monitor (pio device monitor)"
	@echo "  ros2-up          Start ROS2 docker compose"
	@echo "  ros2-shell       Open ROS2 container shell"
	@echo "  ros2-build       Build ROS2 workspace in container"
	@echo "  ros2-rviz        Launch RViz via X11/XQuartz"
	@echo "  ros2-novnc       Launch RViz via noVNC (browser)"
	@echo "  ros2-bag-record  Record rosbag via container"
	@echo "  ros2-bag-play    Play rosbag via container (BAG=... required)"
	@echo "  ros2-session-up  Start ROS2 session + bag record"
	@echo ""
	@echo "Debug Targets:"
	@echo "  debug            Build debug"
	@echo "  debug-gdb        Build GDB debug session"
	@echo ""
	@echo "Environment Setup"
	@echo "  init             Initialize the environment"
	@echo "  setuphooks       Set up git hooks"
	@echo "  pysync           Initialize Python virtual environment with all extras"
	@echo "  purge            Purge the environment"
	@echo ""
	@echo "Misc:"
	@echo "  nm               List undefined symbols in object files"
	@echo "  nmbin            List undefined symbols in the executable"
	@echo "  printsrc         Print source files"
	@echo "  printobj         Print object files"
	@echo "  fill             Fill empty directories"
	@echo "  view             View source code"
	@echo "  submodule        Update and initialize git submodules"
	@echo "  rplidar_sdk      Build the RPLIDAR SDK (auto-inits submodule)"
	@echo "  help             Print this help message"
----------------------------------------

----------------------------------------
File: rpi/CMakeLists.txt
----------------------------------------
cmake_minimum_required(VERSION 3.16)
project(robo_racer_rpi LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

option(ROBO_RACER_TSAN "Enable ThreadSanitizer" OFF)

if(ROBO_RACER_TSAN)
	if(CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
		add_compile_options(-fsanitize=thread -fno-omit-frame-pointer -g)
		add_link_options(-fsanitize=thread)
	endif()
endif()

add_subdirectory(lib/mc_core)
add_subdirectory(lib/mc_proto)
add_subdirectory(lib/mc_serial)
add_subdirectory(lib/mc_ipc)

add_subdirectory(apps/seriald)
add_subdirectory(apps/serialctl)
add_subdirectory(apps/sim_esp32d)
add_subdirectory(apps/metricsd)
add_subdirectory(apps/lidar_received)
add_subdirectory(src)
----------------------------------------

----------------------------------------
File: rpi/config/frames.yaml
----------------------------------------
mc_tf_static:
  ros__parameters:
    parent_frame: base_link
    child_frame: laser
    translation_x: 0.0
    translation_y: 0.0
    translation_z: 0.0
    rotation_roll: 0.0
    rotation_pitch: 0.0
    rotation_yaw: 0.0
----------------------------------------

----------------------------------------
File: rpi/training/src/__init__.py
----------------------------------------
----------------------------------------

----------------------------------------
File: rpi/lib/mc_ipc/CMakeLists.txt
----------------------------------------
add_library(mc_ipc
  src/UdsSeqPacket.cpp
)

target_include_directories(mc_ipc PUBLIC include)
target_compile_options(mc_ipc PRIVATE -Wall -Wextra -Wpedantic)
target_link_libraries(mc_ipc PUBLIC mc_core)
----------------------------------------

----------------------------------------
File: rpi/lib/mc_ipc/include/mc/ipc/UdsSeqPacket.hpp
----------------------------------------
#pragma once
#include <string>
#include <sys/socket.h>
#include <vector>
#define MC_IPC_DEFAULT_SOCK_TYPE SOCK_SEQPACKET
namespace mc::ipc {
class UdsServer {
public:
	explicit UdsServer(int sock_type = MC_IPC_DEFAULT_SOCK_TYPE)
		: sock_type_(sock_type) {}
	~UdsServer();
	bool listen(const std::string &path);
	void close();
	int fd() const { return fd_; }
	int sock_type() const { return sock_type_; }
	std::string path() const { return path_; }
	int accept_client();
	void remove_client(int cfd);
	const std::vector< int > &clients() const { return clients_; }
private:
	int fd_{-1};
	int sock_type_{MC_IPC_DEFAULT_SOCK_TYPE};
	std::string path_;
	std::vector< int > clients_;
};
class UdsClient {
public:
	explicit UdsClient(int sock_type = MC_IPC_DEFAULT_SOCK_TYPE)
		: sock_type_(sock_type) {}
	~UdsClient();
	bool connect(const std::string &path);
	void close();
	int fd() const { return fd_; }
private:
	int fd_{-1};
	int sock_type_{MC_IPC_DEFAULT_SOCK_TYPE};
	std::string bound_path_;
};
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_ipc/src/UdsSeqPacket.cpp
----------------------------------------
#include <mc/core/Log.hpp>
#include <mc/ipc/UdsSeqPacket.hpp>
#include <cstring>
#include <errno.h>
#include <string.h>
#include <atomic>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
namespace mc::ipc {
static std::string make_client_path() {
	static std::atomic< unsigned int > counter{0};
	const unsigned int id = counter.fetch_add(1);
	const int pid = ::getpid();
	return "/tmp/mc_ipc_client_" + std::to_string(pid) + "_" +
		   std::to_string(id) + ".sock";
}
static bool set_nonblock(int fd) {
	int fl = fcntl(fd, F_GETFL, 0);
	if (fl < 0)
		return false;
	return fcntl(fd, F_SETFL, fl | O_NONBLOCK) == 0;
}
UdsServer::~UdsServer() { close(); }
bool UdsServer::listen(const std::string &path) {
	close();
	path_ = path;
	fd_ = ::socket(AF_UNIX, sock_type_, 0);
	if (fd_ < 0) {
		MC_LOGE("uds", "socket failed: " + std::string(::strerror(errno)));
		return false;
	}
	set_nonblock(fd_);
	::unlink(path.c_str());
	sockaddr_un addr{};
	addr.sun_family = AF_UNIX;
	snprintf(addr.sun_path, sizeof(addr.sun_path), "%s", path.c_str());
	if (::bind(fd_, (sockaddr *)&addr, sizeof(addr)) != 0) {
		MC_LOGE("uds", "bind failed: " + std::string(::strerror(errno)));
		close();
		return false;
	}
	if (sock_type_ == SOCK_SEQPACKET) {
		if (::listen(fd_, 16) != 0) {
			MC_LOGE("uds", "listen failed: " + std::string(::strerror(errno)));
			close();
			return false;
		}
	}
	return true;
}
void UdsServer::close() {
	for (int c : clients_)
		::close(c);
	clients_.clear();
	if (fd_ >= 0) {
		::close(fd_);
		fd_ = -1;
	}
	if (!path_.empty()) {
		::unlink(path_.c_str());
		path_.clear();
	}
}
int UdsServer::accept_client() {
	if (fd_ < 0)
		return -1;
	if (sock_type_ != SOCK_SEQPACKET)
		return -1;
	int cfd = ::accept(fd_, nullptr, nullptr);
	if (cfd < 0) {
		if (errno == EAGAIN || errno == EWOULDBLOCK)
			return -1;
		MC_LOGE("uds", "accept failed: " + std::string(::strerror(errno)));
		return -1;
	}
	set_nonblock(cfd);
	clients_.push_back(cfd);
	return cfd;
}
void UdsServer::remove_client(int cfd) {
	for (size_t i = 0; i < clients_.size(); ++i) {
		if (clients_[i] == cfd) {
			::close(cfd);
			clients_.erase(clients_.begin() + (long)i);
			return;
		}
	}
}
UdsClient::~UdsClient() { close(); }
bool UdsClient::connect(const std::string &path) {
	close();
	fd_ = ::socket(AF_UNIX, sock_type_, 0);
	if (fd_ < 0) {
		MC_LOGE("uds", "socket failed: " + std::string(::strerror(errno)));
		return false;
	}
	if (sock_type_ == SOCK_DGRAM) {
		bound_path_ = make_client_path();
		::unlink(bound_path_.c_str());
		sockaddr_un local{};
		local.sun_family = AF_UNIX;
		snprintf(local.sun_path, sizeof(local.sun_path), "%s",
				 bound_path_.c_str());
		if (::bind(fd_, (sockaddr *)&local, sizeof(local)) != 0) {
			MC_LOGE("uds", "bind failed: " + std::string(::strerror(errno)));
			close();
			return false;
		}
	}
	sockaddr_un addr{};
	addr.sun_family = AF_UNIX;
	snprintf(addr.sun_path, sizeof(addr.sun_path), "%s", path.c_str());
	if (::connect(fd_, (sockaddr *)&addr, sizeof(addr)) != 0) {
		MC_LOGE("uds", "connect failed: " + std::string(::strerror(errno)));
		close();
		return false;
	}
	set_nonblock(fd_);
	return true;
}
void UdsClient::close() {
	if (fd_ >= 0) {
		::close(fd_);
		fd_ = -1;
	}
	if (!bound_path_.empty()) {
		::unlink(bound_path_.c_str());
		bound_path_.clear();
	}
}
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_proto/CMakeLists.txt
----------------------------------------
add_library(mc_proto
  ${CMAKE_SOURCE_DIR}/../shared/proto/src/mcproto.cpp
)

target_include_directories(mc_proto PUBLIC
	${CMAKE_SOURCE_DIR}/../shared/proto/include
	${CMAKE_SOURCE_DIR}/../shared/proto
)
target_compile_options(mc_proto PRIVATE -Wall -Wextra -Wpedantic)
target_link_libraries(mc_proto PUBLIC mc_core)
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/CMakeLists.txt
----------------------------------------
add_library(mc_core
  src/Log.cpp
  src/Time.cpp
  src/Process.cpp
)

target_include_directories(mc_core PUBLIC include)
target_compile_options(mc_core PRIVATE -Wall -Wextra -Wpedantic)
target_link_libraries(mc_core PRIVATE pthread)
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/include/mc/core/Time.hpp
----------------------------------------
#pragma once
#include <cstdint>
namespace mc::core {
struct Time {
	static uint64_t us();
	static uint32_t ms();
};
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/include/mc/core/Path.hpp
----------------------------------------
#pragma once
#include <cerrno>
#include <cstdio>
#include <cstring>
#include <string>
#include <sys/stat.h>
namespace mc::core {
inline void ensure_dir(const std::string &path) {
	if (path.empty())
		return;
	std::string cur;
	size_t i = 0;
	if (!path.empty() && path[0] == '/') {
		cur = "/";
		i = 1;
	}
	while (i <= path.size()) {
		const size_t next = path.find('/', i);
		const size_t end = (next == std::string::npos) ? path.size() : next;
		const std::string part = path.substr(i, end - i);
		i = (next == std::string::npos) ? path.size() + 1 : next + 1;
		if (part.empty() || part == ".")
			continue;
		if (!cur.empty() && cur.back() != '/')
			cur += "/";
		if (part == "..") {
			cur += part;
			continue;
		}
		cur += part;
		const int rc = mkdir(cur.c_str(), 0755);
		if (rc == 0 || errno == EEXIST)
			continue;
		const int err = errno;
		std::fprintf(stderr,
					 "ensure_dir: failed to create directory '%s': %s "
					 "(errno=%d)\n",
					 cur.c_str(), std::strerror(err), err);
		return;
	}
}
inline std::string dir_of(const std::string &path) {
	const size_t pos = path.find_last_of('/');
	if (pos == std::string::npos || pos == 0)
		return std::string();
	return path.substr(0, pos);
}
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/include/mc/core/Result.hpp
----------------------------------------
#pragma once
#include <cstdint>
namespace mc::core {
enum class Errc : uint8_t {
	Ok = 0,
	Timeout,
	Bus,
	Invalid,
	NotReady,
	Range,
	Internal
};
struct Result {
	Errc code;
	const char *msg;
	constexpr bool ok() const { return code == Errc::Ok; }
	static constexpr Result Ok() { return {Errc::Ok, ""}; }
	static constexpr Result Fail(Errc c, const char *m) { return {c, m}; }
};
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/include/mc/core/Endian.hpp
----------------------------------------
#pragma once
#include <cstddef>
#include <cstdint>
namespace mc::endian {
static inline uint16_t rd16le(const uint8_t *p) {
	return (uint16_t)p[0] | ((uint16_t)p[1] << 8);
}
static inline uint32_t rd32le(const uint8_t *p) {
	return (uint32_t)p[0] | ((uint32_t)p[1] << 8) | ((uint32_t)p[2] << 16) |
		   ((uint32_t)p[3] << 24);
}
static inline void wr16le(uint8_t *p, uint16_t v) {
	p[0] = (uint8_t)(v & 0xFF);
	p[1] = (uint8_t)((v >> 8) & 0xFF);
}
static inline void wr32le(uint8_t *p, uint32_t v) {
	p[0] = (uint8_t)(v & 0xFF);
	p[1] = (uint8_t)((v >> 8) & 0xFF);
	p[2] = (uint8_t)((v >> 16) & 0xFF);
	p[3] = (uint8_t)((v >> 24) & 0xFF);
}
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/include/mc/core/Log.hpp
----------------------------------------
#pragma once
#include <atomic>
#include <condition_variable>
#include <cstdint>
#include <deque>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <vector>
namespace mc::core {
enum class LogLevel : uint8_t { Trace = 0, Debug, Info, Warn, Error, Fatal };
struct LogRecord {
	uint64_t ts_us{};
	LogLevel level{};
	std::string tag;
	std::string msg;
};
struct ILogSink {
	virtual ~ILogSink() = default;
	virtual void write(const LogRecord &r) = 0;
};
class ConsoleSink final : public ILogSink {
public:
	void write(const LogRecord &r) override;
};
class FileSink final : public ILogSink {
public:
	explicit FileSink(std::string path);
	void write(const LogRecord &r) override;
private:
	std::string path_;
};
class Logger {
public:
	static Logger &instance();
	void addSink(std::shared_ptr< ILogSink > sink);
	void setConsoleEnabled(bool enabled);
	void setLevel(LogLevel lv) { level_.store((uint8_t)lv); }
	LogLevel level() const { return (LogLevel)level_.load(); }
	void log(LogLevel lv, std::string tag, std::string msg);
	void shutdown();
private:
	Logger();
	~Logger();
	void worker_();
	std::atomic< uint8_t > level_{(uint8_t)LogLevel::Info};
	std::atomic< bool > running_{true};
	std::mutex mtx_;
	std::condition_variable cv_;
	std::deque< LogRecord > q_;
	std::vector< std::shared_ptr< ILogSink > > sinks_;
	std::shared_ptr< ConsoleSink > console_sink_;
	std::atomic< bool > console_enabled_{true};
	std::thread th_;
};
} 
#define MC_LOGT(tag, msg)                                                      \
	::mc::core::Logger::instance().log(::mc::core::LogLevel::Trace, (tag),     \
									   (msg))
#define MC_LOGD(tag, msg)                                                      \
	::mc::core::Logger::instance().log(::mc::core::LogLevel::Debug, (tag),     \
									   (msg))
#define MC_LOGI(tag, msg)                                                      \
	::mc::core::Logger::instance().log(::mc::core::LogLevel::Info, (tag), (msg))
#define MC_LOGW(tag, msg)                                                      \
	::mc::core::Logger::instance().log(::mc::core::LogLevel::Warn, (tag), (msg))
#define MC_LOGE(tag, msg)                                                      \
	::mc::core::Logger::instance().log(::mc::core::LogLevel::Error, (tag),     \
									   (msg))
#define MC_LOGF(tag, msg)                                                      \
	::mc::core::Logger::instance().log(::mc::core::LogLevel::Fatal, (tag),     \
									   (msg))
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/include/mc/core/Process.hpp
----------------------------------------
#pragma once
#include <string>
#include <sys/types.h>
#include <vector>
namespace mc::core {
class Process {
public:
	static pid_t spawn(const std::string &path,
					   const std::vector< std::string > &args);
	static bool isRunning(pid_t pid);
	static void terminate(pid_t pid);
};
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/src/Log.cpp
----------------------------------------
#include <mc/core/Log.hpp>
#include <mc/core/Time.hpp>
#include <algorithm>
#include <cstdio>
#include <fstream>
namespace mc::core {
static const char *level_str(LogLevel lv) {
	switch (lv) {
	case LogLevel::Trace:
		return "TRACE";
	case LogLevel::Debug:
		return "DEBUG";
	case LogLevel::Info:
		return "INFO";
	case LogLevel::Warn:
		return "WARN";
	case LogLevel::Error:
		return "ERROR";
	case LogLevel::Fatal:
		return "FATAL";
	}
	return "UNK";
}
void ConsoleSink::write(const LogRecord &r) {
	std::fprintf(stderr, "[%llu] %-5s [%s] %s\n", (unsigned long long)r.ts_us,
				 level_str(r.level), r.tag.c_str(), r.msg.c_str());
}
FileSink::FileSink(std::string path) : path_(std::move(path)) {}
void FileSink::write(const LogRecord &r) {
	std::ofstream ofs(path_, std::ios::app);
	ofs << "[" << r.ts_us << "] " << level_str(r.level) << " [" << r.tag << "] "
		<< r.msg << "\n";
}
Logger &Logger::instance() {
	static Logger g;
	return g;
}
Logger::Logger() : th_([this] { worker_(); }) {
	console_sink_ = std::make_shared< ConsoleSink >();
	sinks_.push_back(console_sink_);
}
Logger::~Logger() { shutdown(); }
void Logger::addSink(std::shared_ptr< ILogSink > sink) {
	std::lock_guard< std::mutex > lk(mtx_);
	sinks_.push_back(std::move(sink));
}
void Logger::setConsoleEnabled(bool enabled) {
	std::lock_guard< std::mutex > lk(mtx_);
	if (enabled) {
		if (!console_enabled_) {
			sinks_.push_back(console_sink_);
			console_enabled_ = true;
		}
		return;
	}
	if (!console_enabled_)
		return;
	auto it = std::remove(sinks_.begin(), sinks_.end(), console_sink_);
	sinks_.erase(it, sinks_.end());
	console_enabled_ = false;
}
void Logger::log(LogLevel lv, std::string tag, std::string msg) {
	if ((uint8_t)lv < level_.load())
		return;
	LogRecord r;
	r.ts_us = Time::us();
	r.level = lv;
	r.tag = std::move(tag);
	r.msg = std::move(msg);
	{
		std::lock_guard< std::mutex > lk(mtx_);
		constexpr size_t MAX_Q = 4096;
		if (q_.size() >= MAX_Q)
			q_.pop_front();
		q_.push_back(std::move(r));
	}
	cv_.notify_one();
}
void Logger::shutdown() {
	bool expected = true;
	if (!running_.compare_exchange_strong(expected, false))
		return;
	cv_.notify_one();
	if (th_.joinable())
		th_.join();
}
void Logger::worker_() {
	while (running_.load()) {
		std::deque< LogRecord > local;
		{
			std::unique_lock< std::mutex > lk(mtx_);
			cv_.wait(lk, [&] { return !running_.load() || !q_.empty(); });
			local.swap(q_);
		}
		for (auto &r : local) {
			std::vector< std::shared_ptr< ILogSink > > sinks_copy;
			{
				std::lock_guard< std::mutex > lk(mtx_);
				sinks_copy = sinks_;
			}
			for (auto &s : sinks_copy)
				s->write(r);
		}
	}
	std::deque< LogRecord > local;
	{
		std::lock_guard< std::mutex > lk(mtx_);
		local.swap(q_);
	}
	for (auto &r : local) {
		for (auto &s : sinks_)
			s->write(r);
	}
}
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/src/Process.cpp
----------------------------------------
#include <mc/core/Process.hpp>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
namespace mc::core {
pid_t Process::spawn(const std::string &path,
					 const std::vector< std::string > &args) {
	pid_t pid = fork();
	if (pid != 0)
		return pid;
	std::vector< char * > argv;
	argv.reserve(args.size() + 2);
	argv.push_back(const_cast< char * >(path.c_str()));
	for (const auto &a : args)
		argv.push_back(const_cast< char * >(a.c_str()));
	argv.push_back(nullptr);
	execv(path.c_str(), argv.data());
	_exit(127);
}
bool Process::isRunning(pid_t pid) {
	if (pid <= 0)
		return false;
	return kill(pid, 0) == 0;
}
void Process::terminate(pid_t pid) {
	if (pid <= 0)
		return;
	kill(pid, SIGTERM);
	waitpid(pid, nullptr, 0);
}
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_core/src/Time.cpp
----------------------------------------
#include <mc/core/Time.hpp>
#include <time.h>
namespace mc::core {
uint64_t Time::us() {
	timespec ts{};
	clock_gettime(CLOCK_MONOTONIC, &ts);
	return (uint64_t)ts.tv_sec * 1000000ULL + (uint64_t)ts.tv_nsec / 1000ULL;
}
uint32_t Time::ms() { return (uint32_t)(us() / 1000ULL); }
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_serial/CMakeLists.txt
----------------------------------------
add_library(mc_serial
  src/Uart.cpp
)

target_include_directories(mc_serial PUBLIC include)
target_compile_options(mc_serial PRIVATE -Wall -Wextra -Wpedantic)
target_link_libraries(mc_serial PUBLIC mc_core)
----------------------------------------

----------------------------------------
File: rpi/lib/mc_serial/include/mc/serial/Uart.hpp
----------------------------------------
#pragma once
#include <cstdint>
#include <string>
namespace mc::serial {
class Uart {
public:
	Uart() = default;
	~Uart();
	bool open(const std::string &dev, int baud);
	void close();
	int fd() const { return _fd; }
	int read(uint8_t *buf, int cap);
	int write(const uint8_t *buf, int len);
private:
	int _fd = -1;
};
} 
----------------------------------------

----------------------------------------
File: rpi/lib/mc_serial/src/Uart.cpp
----------------------------------------
#include <mc/serial/Uart.hpp>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
namespace mc::serial {
static speed_t toSpeed(int baud) {
	switch (baud) {
	case 115200:
		return B115200;
	case 230400:
		return B230400;
#ifdef B460800
	case 460800:
		return B460800;
#endif
#ifdef B921600
	case 921600:
		return B921600;
#endif
	default:
#ifdef B921600
		return B921600;
#else
		return B115200;
#endif
	}
}
Uart::~Uart() { close(); }
bool Uart::open(const std::string &dev, int baud) {
	close();
	_fd = ::open(dev.c_str(), O_RDWR | O_NOCTTY | O_NONBLOCK);
	if (_fd < 0)
		return false;
	termios tio{};
	if (tcgetattr(_fd, &tio) != 0)
		return false;
	cfmakeraw(&tio);
	tio.c_cflag |= (CLOCAL | CREAD);
	tio.c_cflag &= ~CRTSCTS;
	tio.c_cflag &= ~CSTOPB;
	tio.c_cflag &= ~PARENB;
	tio.c_cflag &= ~CSIZE;
	tio.c_cflag |= CS8;
	speed_t sp = toSpeed(baud);
	cfsetispeed(&tio, sp);
	cfsetospeed(&tio, sp);
	tio.c_cc[VTIME] = 0;
	tio.c_cc[VMIN] = 0;
	if (tcsetattr(_fd, TCSANOW, &tio) != 0)
		return false;
	return true;
}
void Uart::close() {
	if (_fd >= 0)
		::close(_fd);
	_fd = -1;
}
int Uart::read(uint8_t *buf, int cap) {
	if (_fd < 0)
		return -1;
	int n = (int)::read(_fd, buf, (size_t)cap);
	if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK))
		return 0;
	return n;
}
int Uart::write(const uint8_t *buf, int len) {
	if (_fd < 0)
		return -1;
	const uint8_t *p = (const uint8_t *)buf;
	int off = 0;
	while (off < len) {
		int n = (int)::write(_fd, p + off, (size_t)(len - off));
		if (n > 0) {
			off += n;
			continue;
		}
		if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
			pollfd pfd{_fd, POLLOUT, 0};
			int r = ::poll(&pfd, 1, 50);
			if (r <= 0)
				return off;
			continue;
		}
		return -1;
	}
	return off;
}
} 
----------------------------------------

----------------------------------------
File: rpi/apps/metricsd/CMakeLists.txt
----------------------------------------
add_executable(metricsd
  src/main.cpp
)

target_link_libraries(metricsd
  mc_core
  mc_proto
  mc_ipc
)

target_compile_options(metricsd PRIVATE -Wall -Wextra -Wpedantic)
----------------------------------------

----------------------------------------
File: rpi/apps/metricsd/config/Config.h
----------------------------------------
#pragma once
namespace metricsd_cfg {
static constexpr const char *DEFAULT_LOG = "./logs/metricsd.log";
} 
----------------------------------------

----------------------------------------
File: rpi/apps/metricsd/src/main.cpp
----------------------------------------
#include "../config/Config.h"
#include <mc/core/Log.hpp>
#include <mc/core/Path.hpp>
#include <mc/core/Time.hpp>
#include <mc/ipc/UdsSeqPacket.hpp>
#include <mc/proto/Proto.hpp>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <memory>
#include <string>
#include <sys/socket.h>
#include <thread>
#include <unistd.h>
namespace {
struct MetricsSample {
	uint16_t cpu_temp_cdeg = 0;
	uint16_t cpu_usage_permille = 0;
	uint32_t mem_used_kb = 0;
	uint32_t mem_total_kb = 0;
};
struct Thresholds {
	uint16_t temp_warn_cdeg = 7000;
	uint16_t temp_crit_cdeg = 8000;
	uint16_t cpu_warn_permille = 800;
	uint16_t cpu_crit_permille = 950;
};
bool read_cpu_temp_cdeg(uint16_t &out) {
	std::ifstream ifs("/sys/class/thermal/thermal_zone0/temp");
	if (!ifs.is_open())
		return false;
	int temp_mdeg = 0;
	ifs >> temp_mdeg;
	if (!ifs.good())
		return false;
	out = (uint16_t)(temp_mdeg / 10);
	return true;
}
bool read_mem_kb(uint32_t &used_kb, uint32_t &total_kb) {
	std::ifstream ifs("/proc/meminfo");
	if (!ifs.is_open())
		return false;
	std::string key;
	uint64_t value = 0;
	std::string unit;
	uint64_t mem_total = 0;
	uint64_t mem_avail = 0;
	while (ifs >> key >> value >> unit) {
		if (key == "MemTotal:")
			mem_total = value;
		else if (key == "MemAvailable:")
			mem_avail = value;
	}
	if (mem_total == 0)
		return false;
	total_kb = (uint32_t)mem_total;
	used_kb = (uint32_t)(mem_total - mem_avail);
	return true;
}
struct CpuTimes {
	uint64_t idle = 0;
	uint64_t total = 0;
};
bool read_cpu_times(CpuTimes &out) {
	std::ifstream ifs("/proc/stat");
	if (!ifs.is_open())
		return false;
	std::string cpu;
	uint64_t user = 0, nice = 0, system = 0, idle = 0, iowait = 0;
	uint64_t irq = 0, softirq = 0, steal = 0;
	ifs >> cpu >> user >> nice >> system >> idle >> iowait >> irq >> softirq >>
		steal;
	if (!ifs.good())
		return false;
	const uint64_t idle_all = idle + iowait;
	const uint64_t non_idle = user + nice + system + irq + softirq + steal;
	out.idle = idle_all;
	out.total = idle_all + non_idle;
	return true;
}
uint16_t compute_cpu_permille(const CpuTimes &prev, const CpuTimes &cur) {
	const uint64_t totald = cur.total - prev.total;
	const uint64_t idled = cur.idle - prev.idle;
	if (totald == 0)
		return 0;
	const uint64_t used = totald - idled;
	uint64_t permille = (used * 1000u) / totald;
	if (permille > 1000)
		permille = 1000;
	return (uint16_t)permille;
}
bool send_metrics(mc::ipc::UdsClient &ipc, const MetricsSample &m,
				  uint32_t ts_ms) {
	mc::proto::MetricsPayload payload{};
	payload.ts_ms = ts_ms;
	payload.cpu_temp_cdeg = m.cpu_temp_cdeg;
	payload.cpu_usage_permille = m.cpu_usage_permille;
	payload.mem_used_kb = m.mem_used_kb;
	payload.mem_total_kb = m.mem_total_kb;
	uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
	size_t enc_len = 0;
	if (!mc::proto::PacketWriter::build(
			enc, sizeof(enc), enc_len, mc::proto::Type::IPC_METRICS, 0, 0,
			reinterpret_cast< const uint8_t * >(&payload), sizeof(payload))) {
		return false;
	}
	return ::send(ipc.fd(), enc, enc_len, 0) == (ssize_t)enc_len;
}
} 
int main(int argc, char **argv) {
	uint32_t interval_ms = 1000;
	std::string log_path = metricsd_cfg::DEFAULT_LOG;
	std::string sock_path;
	Thresholds th;
	for (int i = 1; i < argc; ++i) {
		std::string a = argv[i];
		if (a == "--interval-ms" && i + 1 < argc) {
			interval_ms = (uint32_t)std::atoi(argv[++i]);
		} else if (a == "--log" && i + 1 < argc) {
			log_path = argv[++i];
		} else if (a == "--sock" && i + 1 < argc) {
			sock_path = argv[++i];
		} else if (a == "--temp-warn-cdeg" && i + 1 < argc) {
			th.temp_warn_cdeg = (uint16_t)std::atoi(argv[++i]);
		} else if (a == "--temp-crit-cdeg" && i + 1 < argc) {
			th.temp_crit_cdeg = (uint16_t)std::atoi(argv[++i]);
		} else if (a == "--cpu-warn-permille" && i + 1 < argc) {
			th.cpu_warn_permille = (uint16_t)std::atoi(argv[++i]);
		} else if (a == "--cpu-crit-permille" && i + 1 < argc) {
			th.cpu_crit_permille = (uint16_t)std::atoi(argv[++i]);
		}
	}
	if (interval_ms == 0)
		interval_ms = 1000;
	auto &logger = mc::core::Logger::instance();
	if (!log_path.empty()) {
		mc::core::ensure_dir(mc::core::dir_of(log_path));
		logger.addSink(std::make_shared< mc::core::FileSink >(log_path));
	}
	mc::ipc::UdsClient ipc;
	bool has_ipc = false;
	if (!sock_path.empty()) {
		has_ipc = ipc.connect(sock_path);
	}
	CpuTimes prev{};
	(void)read_cpu_times(prev);
	while (true) {
		MetricsSample m{};
		const bool temp_ok = read_cpu_temp_cdeg(m.cpu_temp_cdeg);
		const bool mem_ok = read_mem_kb(m.mem_used_kb, m.mem_total_kb);
		if (!mem_ok) {
			m.mem_used_kb = 0;
			m.mem_total_kb = 0;
		}
		CpuTimes cur{};
		const bool cpu_ok = read_cpu_times(cur);
		if (cpu_ok) {
			m.cpu_usage_permille = compute_cpu_permille(prev, cur);
			prev = cur;
		}
		logger.log(mc::core::LogLevel::Info, "metrics",
				   "temp_cdeg=" + std::to_string(m.cpu_temp_cdeg) +
					   " cpu_permille=" + std::to_string(m.cpu_usage_permille) +
					   " mem_kb=" + std::to_string(m.mem_used_kb) + "/" +
					   std::to_string(m.mem_total_kb));
		if (temp_ok) {
			if (m.cpu_temp_cdeg >= th.temp_crit_cdeg) {
				logger.log(mc::core::LogLevel::Error, "metrics",
						   "cpu_temp_crit cdeg=" +
							   std::to_string(m.cpu_temp_cdeg));
			} else if (m.cpu_temp_cdeg >= th.temp_warn_cdeg) {
				logger.log(mc::core::LogLevel::Warn, "metrics",
						   "cpu_temp_warn cdeg=" +
							   std::to_string(m.cpu_temp_cdeg));
			}
		}
		if (cpu_ok) {
			if (m.cpu_usage_permille >= th.cpu_crit_permille) {
				logger.log(mc::core::LogLevel::Error, "metrics",
						   "cpu_usage_crit permille=" +
							   std::to_string(m.cpu_usage_permille));
			} else if (m.cpu_usage_permille >= th.cpu_warn_permille) {
				logger.log(mc::core::LogLevel::Warn, "metrics",
						   "cpu_usage_warn permille=" +
							   std::to_string(m.cpu_usage_permille));
			}
		}
		if (has_ipc) {
			const uint32_t ts_ms = mc::core::Time::ms();
			(void)send_metrics(ipc, m, ts_ms);
		}
		std::this_thread::sleep_for(std::chrono::milliseconds(interval_ms));
	}
	logger.shutdown();
	return 0;
}
----------------------------------------

----------------------------------------
File: rpi/apps/serialctl/CMakeLists.txt
----------------------------------------
add_executable(serialctl main.cpp)

target_link_libraries(serialctl
  mc_proto
  mc_ipc
)

target_compile_options(serialctl PRIVATE -Wall -Wextra -Wpedantic)
----------------------------------------

----------------------------------------
File: rpi/apps/serialctl/config/Config.h
----------------------------------------
#pragma once
namespace serialctl_cfg {
static constexpr const char *DEFAULT_LOG = "./logs/serialctl.log";
} 
----------------------------------------

----------------------------------------
File: rpi/apps/serialctl/main.cpp
----------------------------------------
#include "config/Config.h"
#include <mc/core/Log.hpp>
#include <mc/core/Path.hpp>
#include <mc/ipc/UdsSeqPacket.hpp>
#include <mc/proto/Proto.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <sys/socket.h>
#include <vector>
static void usage() {
	std::cerr
		<< "serialctl --uds /tmp/roboracer/seriald.sock [--log path] "
		   "[drive|kill|mode] ...\n"
		   "  drive --seq N --steer_cdeg X --speed_mm_s V --ttl_ms T --dist_mm "
		   "D\n"
		   "  kill  --seq N\n"
		   "  mode  --seq N --mode 0|1\n";
}
static int argi(int &i, int argc, char **argv) {
	if (i + 1 >= argc)
		return 0;
	return std::stoi(argv[++i]);
}
int main(int argc, char **argv) {
	using mc::core::Logger;
	Logger::instance().setLevel(mc::core::LogLevel::Info);
	std::string uds = "/tmp/roboracer/seriald.sock";
	std::string log_path = serialctl_cfg::DEFAULT_LOG;
	std::string cmd;
	for (int i = 1; i < argc; ++i) {
		std::string a = argv[i];
		if (a == "--uds" && i + 1 < argc)
			uds = argv[++i];
		else if (a == "--log" && i + 1 < argc)
			log_path = argv[++i];
		else if (a == "drive" || a == "kill" || a == "mode")
			cmd = a;
	}
	if (cmd.empty()) {
		usage();
		return 1;
	}
	if (!log_path.empty()) {
		mc::core::ensure_dir(mc::core::dir_of(log_path));
		Logger::instance().addSink(
			std::make_shared< mc::core::FileSink >(log_path));
	}
	uint16_t seq = 1;
	int steer_cdeg = 0;
	int speed_mm_s = 0;
	int ttl_ms = 100;
	int dist_mm = 0;
	int mode = 1;
	for (int i = 1; i < argc; ++i) {
		std::string a = argv[i];
		if (a == "--seq")
			seq = (uint16_t)argi(i, argc, argv);
		else if (a == "--steer_cdeg")
			steer_cdeg = argi(i, argc, argv);
		else if (a == "--speed_mm_s")
			speed_mm_s = argi(i, argc, argv);
		else if (a == "--ttl_ms")
			ttl_ms = argi(i, argc, argv);
		else if (a == "--dist_mm")
			dist_mm = argi(i, argc, argv);
		else if (a == "--mode")
			mode = argi(i, argc, argv);
	}
	mc::ipc::UdsClient c;
	if (!c.connect(uds)) {
		MC_LOGF("serialctl", "connect failed: " + uds);
		return 1;
	}
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	if (cmd == "kill") {
		uint8_t payload[2] = {0, 0};
		if (!mc::proto::PacketWriter::build(out, sizeof(out), out_len,
											mc::proto::Type::KILL, 0, seq,
											payload, sizeof(payload))) {
			MC_LOGF("serialctl", "build kill failed");
			return 1;
		}
	} else if (cmd == "mode") {
		uint8_t payload[1] = {(uint8_t)mode};
		if (!mc::proto::PacketWriter::build(out, sizeof(out), out_len,
											mc::proto::Type::MODE_SET, 0, seq,
											payload, sizeof(payload))) {
			MC_LOGF("serialctl", "build mode failed");
			return 1;
		}
	} else if (cmd == "drive") {
		uint8_t payload[8]{};
		auto put_i16 = [&](int off, int v) {
			int16_t x = (int16_t)v;
			payload[off + 0] = (uint8_t)(x & 0xFF);
			payload[off + 1] = (uint8_t)((x >> 8) & 0xFF);
		};
		auto put_u16 = [&](int off, int v) {
			uint16_t x = (uint16_t)v;
			payload[off + 0] = (uint8_t)(x & 0xFF);
			payload[off + 1] = (uint8_t)((x >> 8) & 0xFF);
		};
		put_i16(0, steer_cdeg);
		put_i16(2, speed_mm_s);
		put_u16(4, ttl_ms);
		put_u16(6, dist_mm);
		if (!mc::proto::PacketWriter::build(out, sizeof(out), out_len,
											mc::proto::Type::DRIVE, 0, seq,
											payload, sizeof(payload))) {
			MC_LOGF("serialctl", "build drive failed");
			return 1;
		}
	}
	ssize_t w = ::send(c.fd(), out, out_len, MSG_NOSIGNAL);
	if (w < 0) {
		MC_LOGF("serialctl", "send failed");
		return 1;
	}
	MC_LOGI("serialctl", "sent bytes=" + std::to_string((int)w));
	Logger::instance().shutdown();
	return 0;
}
----------------------------------------

----------------------------------------
File: rpi/apps/sim_esp32d/CMakeLists.txt
----------------------------------------
add_executable(sim_esp32d
  src/main.cpp
)

target_link_libraries(sim_esp32d
  mc_proto
  mc_serial
  mc_core
)

target_compile_options(sim_esp32d PRIVATE -Wall -Wextra -Wpedantic)
----------------------------------------

----------------------------------------
File: rpi/apps/sim_esp32d/config/Config.h
----------------------------------------
#pragma once
namespace sim_esp32d_cfg {
static constexpr const char *DEFAULT_LOG = "./logs/sim_esp32d.log";
} 
----------------------------------------

----------------------------------------
File: rpi/apps/sim_esp32d/src/main.cpp
----------------------------------------
#include "../config/Config.h"
#include <atomic>
#include <csignal>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <poll.h>
#include <unistd.h>
#include <mc/core/Log.hpp>
#include <mc/core/Path.hpp>
#include <mc/core/Time.hpp>
#include <mc/proto/Proto.hpp>
#include <mc/serial/Uart.hpp>
namespace {
static std::atomic< bool > g_run{true};
void on_sigint(int) { g_run.store(false); }
static inline uint16_t rd16u(const uint8_t *p) {
	return (uint16_t)p[0] | ((uint16_t)p[1] << 8);
}
static inline int16_t rd16s(const uint8_t *p) { return (int16_t)rd16u(p); }
static inline void wr16(uint8_t *p, uint16_t v) {
	p[0] = (uint8_t)(v & 0xFFu);
	p[1] = (uint8_t)(v >> 8);
}
struct SimState {
	bool auto_mode = false;
	bool kill_latched = false;
	bool has_drive = false;
	uint32_t status_seq = 0;
	uint16_t last_drive_seq = 0;
	uint32_t last_drive_ms = 0;
	uint32_t last_ping_ms = 0;
	int16_t target_steer_cdeg = 0;
	int16_t target_speed_mm_s = 0;
	uint16_t target_ttl_ms = 0;
};
struct Config {
	std::string dev;
	std::string log_path;
	int baud = 921600;
	uint32_t status_interval_ms = 50;
	uint32_t status_delay_ms = 0;
	uint32_t status_drop_every = 0;
	uint32_t status_corrupt_every = 0;
	uint32_t hb_timeout_ms = 200;
};
bool send_status(mc::serial::Uart &uart, SimState &st, uint32_t now_ms,
				 uint32_t hb_timeout_ms, bool corrupt) {
	uint8_t payload[sizeof(mc::proto::StatusPayload)]{};
	const bool hb_timeout =
		st.last_ping_ms > 0 &&
		(uint32_t)(now_ms - st.last_ping_ms) > hb_timeout_ms;
	bool ttl_expired = false;
	if (st.has_drive && st.auto_mode && !st.kill_latched) {
		if (st.target_ttl_ms == 0) {
			ttl_expired = true;
		} else if ((uint32_t)(now_ms - st.last_drive_ms) > st.target_ttl_ms) {
			ttl_expired = true;
		}
	}
	const bool auto_inactive = st.has_drive && !st.auto_mode;
	const bool applied =
		st.auto_mode && !st.kill_latched && st.has_drive && !ttl_expired;
	uint16_t faults = 0;
	if (st.kill_latched)
		faults |= 1u << 0;
	if (hb_timeout)
		faults |= 1u << 1;
	if (ttl_expired)
		faults |= 1u << 2;
	if (auto_inactive)
		faults |= 1u << 3;
	const int16_t speed_now = applied ? st.target_speed_mm_s : 0;
	const int16_t steer_now = applied ? st.target_steer_cdeg : 0;
	uint16_t age_ms = 0xFFFF;
	if (st.has_drive) {
		const uint32_t age = now_ms - st.last_drive_ms;
		age_ms = (age > 0xFFFFu) ? 0xFFFFu : (uint16_t)age;
	}
	payload[0] = applied ? (uint8_t)(st.last_drive_seq & 0xFFu) : 0;
	payload[1] = st.auto_mode ? 1 : 0;
	wr16(payload + 2, faults);
	wr16(payload + 4, (uint16_t)speed_now);
	wr16(payload + 6, (uint16_t)steer_now);
	wr16(payload + 8, age_ms);
	uint8_t frame[mc::proto::MAX_FRAME_ENCODED];
	size_t frame_len = 0;
	if (!mc::proto::PacketWriter::build(frame, sizeof(frame), frame_len,
										mc::proto::Type::STATUS, 0, 0, payload,
										sizeof(payload))) {
		return false;
	}
	if (corrupt && frame_len > 2) {
		frame[1] ^= 0xFF;
	}
	return uart.write(frame, (int)frame_len) > 0;
}
bool send_ack(mc::serial::Uart &uart, uint16_t seq) {
	uint8_t frame[mc::proto::MAX_FRAME_ENCODED];
	size_t frame_len = 0;
	if (!mc::proto::PacketWriter::build(frame, sizeof(frame), frame_len,
										mc::proto::Type::ACK, 0, seq, nullptr,
										0)) {
		return false;
	}
	return uart.write(frame, (int)frame_len) > 0;
}
void handle_frame(const mc::proto::FrameView &f, SimState &st, uint32_t now_ms,
				  mc::serial::Uart &uart) {
	switch (static_cast< mc::proto::Type >(f.type())) {
	case mc::proto::Type::DRIVE: {
		if (f.payload_len != 8)
			break;
		st.target_steer_cdeg = rd16s(f.payload + 0);
		st.target_speed_mm_s = rd16s(f.payload + 2);
		st.target_ttl_ms = rd16u(f.payload + 4);
		st.last_drive_ms = now_ms;
		st.last_drive_seq = f.seq();
		st.has_drive = true;
		break;
	}
	case mc::proto::Type::MODE_SET: {
		if (f.payload_len != 1)
			break;
		st.auto_mode = (f.payload[0] == 1);
		break;
	}
	case mc::proto::Type::KILL:
		st.kill_latched = true;
		break;
	case mc::proto::Type::PING:
		st.last_ping_ms = now_ms;
		break;
	default:
		break;
	}
	if ((f.flags() & mc::proto::FLAG_ACK_REQ) ||
		f.type() == (uint8_t)mc::proto::Type::PING) {
		(void)send_ack(uart, f.seq());
	}
}
Config parse_args(int argc, char **argv) {
	Config cfg;
	cfg.dev = "/dev/ttyUSB0";
	cfg.log_path = sim_esp32d_cfg::DEFAULT_LOG;
	for (int i = 1; i < argc; ++i) {
		std::string a = argv[i];
		if (a == "--dev" && i + 1 < argc) {
			cfg.dev = argv[++i];
		} else if (a == "--log" && i + 1 < argc) {
			cfg.log_path = argv[++i];
		} else if (a == "--baud" && i + 1 < argc) {
			cfg.baud = std::atoi(argv[++i]);
		} else if (a == "--status-ms" && i + 1 < argc) {
			cfg.status_interval_ms = (uint32_t)std::atoi(argv[++i]);
		} else if (a == "--status-delay-ms" && i + 1 < argc) {
			cfg.status_delay_ms = (uint32_t)std::atoi(argv[++i]);
		} else if (a == "--status-drop-every" && i + 1 < argc) {
			cfg.status_drop_every = (uint32_t)std::atoi(argv[++i]);
		} else if (a == "--status-corrupt-every" && i + 1 < argc) {
			cfg.status_corrupt_every = (uint32_t)std::atoi(argv[++i]);
		} else if (a == "--hb-ms" && i + 1 < argc) {
			cfg.hb_timeout_ms = (uint32_t)std::atoi(argv[++i]);
		}
	}
	if (cfg.status_interval_ms == 0)
		cfg.status_interval_ms = 50;
	return cfg;
}
} 
int main(int argc, char **argv) {
	std::signal(SIGINT, on_sigint);
	std::signal(SIGTERM, on_sigint);
	const Config cfg = parse_args(argc, argv);
	auto &logger = mc::core::Logger::instance();
	if (!cfg.log_path.empty()) {
		mc::core::ensure_dir(mc::core::dir_of(cfg.log_path));
		logger.addSink(std::make_shared< mc::core::FileSink >(cfg.log_path));
	}
	logger.log(mc::core::LogLevel::Info, "sim_esp32d",
			   "start dev=" + cfg.dev + " baud=" + std::to_string(cfg.baud));
	mc::serial::Uart uart;
	if (!uart.open(cfg.dev, cfg.baud)) {
		logger.log(mc::core::LogLevel::Fatal, "sim_esp32d",
				   "failed to open dev " + cfg.dev);
		return 1;
	}
	SimState st;
	mc::proto::PacketReader pr;
	uint32_t next_status_ms = mc::core::Time::ms();
	while (g_run.load()) {
		const uint32_t now_ms = mc::core::Time::ms();
		int timeout_ms = 0;
		if ((int32_t)(next_status_ms - now_ms) > 0) {
			timeout_ms = (int)(next_status_ms - now_ms);
		}
		pollfd pfd{uart.fd(), POLLIN, 0};
		(void)::poll(&pfd, 1, timeout_ms);
		if (pfd.revents & POLLIN) {
			uint8_t buf[512];
			int n = uart.read(buf, (int)sizeof(buf));
			if (n > 0) {
				for (int i = 0; i < n; ++i) {
					if (pr.push(buf[i]) && pr.hasFrame()) {
						handle_frame(pr.frame(), st, now_ms, uart);
						pr.consumeFrame();
					}
				}
			}
		}
		if ((int32_t)(now_ms - next_status_ms) >= 0) {
			st.status_seq++;
			if (cfg.status_delay_ms > 0) {
				usleep(cfg.status_delay_ms * 1000u);
			}
			const bool drop = cfg.status_drop_every > 0 &&
							  (st.status_seq % cfg.status_drop_every) == 0;
			const bool corrupt =
				cfg.status_corrupt_every > 0 &&
				(st.status_seq % cfg.status_corrupt_every) == 0;
			const uint32_t send_ms = mc::core::Time::ms();
			if (!drop) {
				(void)send_status(uart, st, send_ms, cfg.hb_timeout_ms,
								  corrupt);
			}
			next_status_ms = send_ms + cfg.status_interval_ms;
		}
	}
	uart.close();
	logger.log(mc::core::LogLevel::Info, "sim_esp32d", "shutdown");
	logger.shutdown();
	return 0;
}
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/CMakeLists.txt
----------------------------------------
add_executable(seriald
  src/main.cpp
)

target_include_directories(seriald PRIVATE include src)
target_compile_options(seriald PRIVATE -Wall -Wextra -Wpedantic)
target_link_libraries(seriald PRIVATE mc_proto mc_ipc mc_serial mc_core)
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/config/Config.h
----------------------------------------
#pragma once
namespace seriald_cfg {
static constexpr const char *DEFAULT_DEV = "/dev/ttyAMA0";
static constexpr int DEFAULT_BAUD = 921600;
static constexpr const char *DEFAULT_CONTROL_SOCK =
	"/tmp/roboracer/seriald.sock";
static constexpr const char *DEFAULT_TELEMETRY_SOCK =
	"/tmp/roboracer/seriald.telemetry.sock";
static constexpr int DEFAULT_TELEMETRY_TCP_PORT = 5001;
static constexpr const char *DEFAULT_COMPAT_CONTROL_SOCK =
	"/tmp/roboracer/seriald.sock";
static constexpr const char *DEFAULT_COMPAT_TELEMETRY_SOCK =
	"/tmp/roboracer/seriald.telemetry.sock";
static constexpr const char* DEFAULT_LOG = "./logs/seriald.log";
static constexpr int POLL_TIMEOUT_MS = 10;
static constexpr int TX_IDLE_US = 1000;
static constexpr int MAX_CLIENT_FDS = 64;
} 
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/Makefile
----------------------------------------
CXX      := g++
CXXFLAGS := -O2 -std=c++17 -Wall -Wextra -Wno-psabi -pthread
LDFLAGS  := -pthread
BIN := seriald
SRC := \
  src/main.cpp \
  src/async_logger.cpp \
  src/sink_stdout.cpp \
  src/sink_file.cpp \
  ../../shared/proto/src/mcproto.cpp \
  ../../lib/mc_ipc/src/UdsSeqPacket.cpp \
  ../../lib/mc_serial/src/Uart.cpp
all: $(BIN)
$(BIN): $(SRC)
	$(CXX) $(CXXFLAGS) -Iinclude -Isrc -I../../shared/proto/include -I../../shared/proto -I../../lib/mc_ipc/include -I../../lib/mc_serial/include -I../../lib/mc_core/include -o $@ $(SRC) $(LDFLAGS)
clean:
	rm -f $(BIN)
.PHONY: all clean
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/seriald_client.py
----------------------------------------
import argparse
import select
import socket
import struct
import time
MAGIC = b"MC"
VER = 1
TYPE_DRIVE = 0x01
TYPE_KILL = 0x02
TYPE_MODE = 0x03
TYPE_PING = 0x04
TYPE_LOG = 0x10
TYPE_STATUS = 0x11
TYPE_ACK = 0x80
FLAG_ACK_REQ = 1 << 0
def crc16_ccitt(data: bytes) -> int:
    crc = 0xFFFF
    for b in data:
        crc ^= (b << 8) & 0xFFFF
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) ^ 0x1021) & 0xFFFF
            else:
                crc = (crc << 1) & 0xFFFF
    return crc
def cobs_encode(inp: bytes) -> bytes:
    out = bytearray()
    out.append(0)
    code = 1
    code_idx = 0
    for b in inp:
        if b == 0:
            out[code_idx] = code
            code = 1
            code_idx = len(out)
            out.append(0)
        else:
            out.append(b)
            code += 1
            if code == 0xFF:
                out[code_idx] = code
                code = 1
                code_idx = len(out)
                out.append(0)
    out[code_idx] = code
    return bytes(out)
def cobs_decode(inp: bytes) -> bytes:
    if not inp:
        return b""
    out = bytearray()
    idx = 0
    while idx < len(inp):
        code = inp[idx]
        if code == 0:
            return b""
        idx += 1
        for _ in range(code - 1):
            if idx >= len(inp):
                return b""
            out.append(inp[idx])
            idx += 1
        if code != 0xFF and idx < len(inp):
            out.append(0)
    return bytes(out)
def build_packet(ptype: int, seq: int, payload: bytes, flags: int = 0) -> bytes:
    hdr = struct.pack(
        "<2sBBBHH", MAGIC, VER, ptype, flags, seq & 0xFFFF, len(payload) & 0xFFFF
    )
    body = hdr + payload
    crc = crc16_ccitt(body)
    decoded = body + struct.pack("<H", crc)
    enc = cobs_encode(decoded) + b"\x00"
    return enc
def decode_packet(enc: bytes):
    if not enc:
        return None
    if enc[-1] == 0:
        enc = enc[:-1]
    raw = cobs_decode(enc)
    if len(raw) < 9 + 2:
        return None
    hdr = raw[:9]
    magic, ver, ptype, flags, seq, plen = struct.unpack("<2sBBBHH", hdr)
    if magic != MAGIC or ver != VER:
        return None
    payload = raw[9:-2]
    if len(payload) != plen:
        return None
    crc_got = struct.unpack("<H", raw[-2:])[0]
    crc_exp = crc16_ccitt(raw[:-2])
    if crc_got != crc_exp:
        return None
    return (ptype, flags, seq, payload)
def wait_for_ack(sock: socket.socket, seq: int, timeout_ms: int) -> bool:
    deadline = time.time() + (timeout_ms / 1000.0)
    while True:
        remaining = deadline - time.time()
        if remaining <= 0:
            return False
        r, _, _ = select.select([sock], [], [], remaining)
        if not r:
            return False
        data = sock.recv(4096)
        dec = decode_packet(data)
        if not dec:
            continue
        ptype, _, rseq, payload = dec
        if ptype == TYPE_ACK and rseq == (seq & 0xFFFF) and len(payload) == 0:
            return True
def print_frame(dec):
    ptype, flags, seq, payload = dec
    if ptype == TYPE_STATUS and len(payload) == 10:
        seq_applied, auto_active, faults, speed, steer, age_ms = struct.unpack(
            "<BBHhhH", payload
        )
        print(
            f"STATUS seq={seq_applied} auto={auto_active} speed_mm_s={speed} steer_cdeg={steer} age_ms={age_ms} faults=0x{faults:04x}"
        )
    elif ptype == TYPE_LOG and len(payload) >= 1:
        lv = payload[0]
        msg = payload[1:].decode("utf-8", errors="replace")
        print(f"LOG lv={lv} msg={msg}")
    elif ptype == TYPE_ACK and len(payload) == 0:
        print(f"ACK seq={seq}")
    else:
        print(f"RX type=0x{ptype:02x} flags=0x{flags:02x} seq={seq} len={len(payload)}")
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--sock", default="/tmp/roboracer/seriald.sock")
    sub = ap.add_subparsers(dest="cmd", required=True)
    s1 = sub.add_parser("drive")
    s1.add_argument("--steer-cdeg", type=int, required=True)
    s1.add_argument("--speed-mm-s", type=int, required=True)
    s1.add_argument("--ttl-ms", type=int, default=100)
    s1.add_argument("--dist-mm", type=int, default=0)
    s1.add_argument("--seq", type=int, default=1)
    s2 = sub.add_parser("kill")
    s2.add_argument("--seq", type=int, default=1)
    s2.add_argument("--wait-ack", action="store_true")
    s2.add_argument("--timeout-ms", type=int, default=200)
    s3 = sub.add_parser("mode")
    s3.add_argument("--mode", choices=["manual", "auto"], required=True)
    s3.add_argument("--seq", type=int, default=1)
    s3.add_argument("--wait-ack", action="store_true")
    s3.add_argument("--timeout-ms", type=int, default=200)
    s4 = sub.add_parser("listen")
    s4.add_argument("--timeout-ms", type=int, default=0)
    args = ap.parse_args()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    sock.connect(args.sock)
    if args.cmd == "listen":
        timeout = None if args.timeout_ms == 0 else args.timeout_ms / 1000.0
        start = time.time()
        while True:
            if timeout is not None and (time.time() - start) > timeout:
                break
            r, _, _ = select.select([sock], [], [], 0.5)
            if not r:
                continue
            data = sock.recv(4096)
            dec = decode_packet(data)
            if dec:
                print_frame(dec)
        return
    if args.cmd == "drive":
        payload = struct.pack(
            "<hhHH", args.steer_cdeg, args.speed_mm_s, args.ttl_ms, args.dist_mm
        )
        pkt = build_packet(TYPE_DRIVE, args.seq, payload, 0)
        sock.send(pkt)
    elif args.cmd == "kill":
        payload = b"\x00\x00"
        flags = FLAG_ACK_REQ if args.wait_ack else 0
        pkt = build_packet(TYPE_KILL, args.seq, payload, flags)
        sock.send(pkt)
        if args.wait_ack:
            ok = wait_for_ack(sock, args.seq, args.timeout_ms)
            print("ACK" if ok else "ACK TIMEOUT")
    else:
        mode = 0 if args.mode == "manual" else 1
        payload = bytes([mode])
        flags = FLAG_ACK_REQ if args.wait_ack else 0
        pkt = build_packet(TYPE_MODE, args.seq, payload, flags)
        sock.send(pkt)
        if args.wait_ack:
            ok = wait_for_ack(sock, args.seq, args.timeout_ms)
            print("ACK" if ok else "ACK TIMEOUT")
if __name__ == "__main__":
    main()
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/sink_stdout.h
----------------------------------------
#pragma once
#include "async_logger.h"
class StdoutSink : public ILogSink {
public:
	void write(const LogEvent& e) override;
};
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/async_logger.cpp
----------------------------------------
#include "async_logger.h"
#include <chrono>
void AsyncLogger::addSink(std::unique_ptr< ILogSink > s) {
	_sinks.emplace_back(std::move(s));
}
uint64_t AsyncLogger::nowNs_() {
	using namespace std::chrono;
	return (uint64_t)duration_cast< nanoseconds >(
			   steady_clock::now().time_since_epoch())
		.count();
}
void AsyncLogger::start() {
	_run = true;
	_th = std::thread([this] { loop_(); });
}
void AsyncLogger::stop() {
	_run = false;
	_cv.notify_all();
	if (_th.joinable())
		_th.join();
}
void AsyncLogger::log(LogLevel lv, const std::string &msg) {
	if (!_run)
		return;
	{
		std::lock_guard< std::mutex > lk(_mu);
		_q.push(LogEvent{nowNs_(), lv, msg});
	}
	_cv.notify_one();
}
void AsyncLogger::loop_() {
	while (_run) {
		LogEvent e{};
		{
			std::unique_lock< std::mutex > lk(_mu);
			_cv.wait(lk, [&] { return !_q.empty() || !_run; });
			if (!_run && _q.empty())
				break;
			e = std::move(_q.front());
			_q.pop();
		}
		for (auto &s : _sinks)
			s->write(e);
	}
}
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/async_logger.h
----------------------------------------
#pragma once
#include <atomic>
#include <condition_variable>
#include <mutex>
#include <queue>
#include <string>
#include <thread>
#include <vector>
#include <memory>
#include <stdint.h>
enum class LogLevel : uint8_t { TRACE=0, DEBUG=1, INFO=2, WARN=3, ERROR=4, FATAL=5 };
struct LogEvent {
	uint64_t ts_ns;
	LogLevel level;
	std::string text;
};
class ILogSink {
public:
	virtual ~ILogSink() {}
	virtual void write(const LogEvent& e) = 0;
};
class AsyncLogger {
public:
	void addSink(std::unique_ptr<ILogSink> s);
	void start();
	void stop();
	void log(LogLevel lv, const std::string& msg);
private:
	std::vector<std::unique_ptr<ILogSink>> _sinks;
	std::mutex _mu;
	std::condition_variable _cv;
	std::queue<LogEvent> _q;
	std::atomic<bool> _run{false};
	std::thread _th;
	void loop_();
	static uint64_t nowNs_();
};
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/sink_file.cpp
----------------------------------------
#include "sink_file.h"
#include <stdio.h>
static const char *lvStr(LogLevel lv) {
	switch (lv) {
	case LogLevel::TRACE:
		return "TRACE";
	case LogLevel::DEBUG:
		return "DEBUG";
	case LogLevel::INFO:
		return "INFO";
	case LogLevel::WARN:
		return "WARN";
	case LogLevel::ERROR:
		return "ERROR";
	case LogLevel::FATAL:
		return "FATAL";
	}
	return "UNK";
}
FileSink::FileSink(const std::string &path) : _path(path) {
	_fp = fopen(_path.c_str(), "a");
}
FileSink::~FileSink() {
	if (_fp)
		fclose(_fp);
}
void FileSink::write(const LogEvent &e) {
	if (!_fp)
		return;
	fprintf(_fp, "[%s] %s\n", lvStr(e.level), e.text.c_str());
	fflush(_fp);
}
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/sink_stdout.cpp
----------------------------------------
#include "sink_stdout.h"
#include <stdio.h>
static const char *lvStr(LogLevel lv) {
	switch (lv) {
	case LogLevel::TRACE:
		return "TRACE";
	case LogLevel::DEBUG:
		return "DEBUG";
	case LogLevel::INFO:
		return "INFO";
	case LogLevel::WARN:
		return "WARN";
	case LogLevel::ERROR:
		return "ERROR";
	case LogLevel::FATAL:
		return "FATAL";
	}
	return "UNK";
}
void StdoutSink::write(const LogEvent &e) {
	fprintf(stdout, "[%s] %s\n", lvStr(e.level), e.text.c_str());
	fflush(stdout);
}
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/sink_file.h
----------------------------------------
#pragma once
#include "async_logger.h"
#include <string>
#include <stdio.h>
class FileSink : public ILogSink {
public:
	explicit FileSink(const std::string& path);
	~FileSink();
	void write(const LogEvent& e) override;
private:
	std::string _path;
	FILE* _fp = nullptr;
};
----------------------------------------

----------------------------------------
File: rpi/apps/seriald/src/main.cpp
----------------------------------------
#include <atomic>
#include <fcntl.h>
#include <memory>
#include <mutex>
#include <netinet/in.h>
#include <poll.h>
#include <queue>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <sys/socket.h>
#include <sys/un.h>
#include <thread>
#include <unistd.h>
#include <vector>
#include "../config/Config.h"
#include <mc/core/Log.hpp>
#include <mc/core/Path.hpp>
#include <mc/ipc/UdsSeqPacket.hpp>
#include <mc/proto/Proto.hpp>
#include <mc/serial/Uart.hpp>
#pragma pack(push, 1)
struct EspStatusPayload {
	uint8_t seq_applied;
	uint8_t auto_active;
	uint16_t faults_le;
	int16_t speed_mm_s_le;
	int16_t steer_cdeg_le;
	uint16_t age_ms_le;
};
#pragma pack(pop)
static inline uint16_t rd16u(const uint8_t *p) {
	return (uint16_t)p[0] | ((uint16_t)p[1] << 8);
}
static inline int16_t rd16s(const uint8_t *p) { return (int16_t)rd16u(p); }
static mc::core::LogLevel mapEspLv(uint8_t lv) {
	if (lv > 5)
		lv = 5;
	return (mc::core::LogLevel)lv;
}
struct TxMsg {
	uint16_t len;
	uint8_t data[mc::proto::MAX_FRAME_ENCODED];
};
struct ServerEntry {
	mc::ipc::UdsServer *server;
	bool telemetry;
	std::string role;
};
struct TcpClientEntry {
	int fd;
};
static int g_tcp_listen_fd = -1;
static std::vector< TcpClientEntry > g_tcp_clients;
static std::mutex g_tx_mu;
static std::queue< TxMsg > g_tx_q;
static void tx_enqueue(const uint8_t *data, uint16_t len) {
	if (len == 0 || len > sizeof(TxMsg::data))
		return;
	std::lock_guard< std::mutex > lk(g_tx_mu);
	TxMsg m{};
	m.len = len;
	memcpy(m.data, data, len);
	g_tx_q.push(m);
}
static bool tx_dequeue(TxMsg &out) {
	std::lock_guard< std::mutex > lk(g_tx_mu);
	if (g_tx_q.empty())
		return false;
	out = g_tx_q.front();
	g_tx_q.pop();
	return true;
}
static void add_server(std::vector< ServerEntry > &servers,
					   mc::ipc::UdsServer &server, const std::string &path,
					   bool telemetry, const std::string &role,
					   mc::core::Logger &logger) {
	if (path.empty())
		return;
	mc::core::ensure_dir(mc::core::dir_of(path));
	if (!server.listen(path)) {
		logger.log(mc::core::LogLevel::Error, "seriald",
				   "failed to open ipc " + role + " path=" + path);
		return;
	}
	servers.push_back(ServerEntry{&server, telemetry, role});
}
static void
remove_client_from_servers(const std::vector< ServerEntry > &servers, int cfd) {
	for (const auto &entry : servers) {
		entry.server->remove_client(cfd);
	}
}
static void broadcast_to(const std::vector< ServerEntry > &servers,
						 bool telemetry, const uint8_t *data, size_t len) {
	for (const auto &entry : servers) {
		if (entry.telemetry != telemetry)
			continue;
		for (int cfd : entry.server->clients()) {
			(void)::send(cfd, data, len, MSG_NOSIGNAL);
		}
	}
}
static bool setup_tcp_listener(int port, mc::core::Logger &logger) {
	if (port <= 0)
		return false;
	int fd = ::socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0) {
		logger.log(mc::core::LogLevel::Error, "seriald",
				   "failed to create telemetry tcp socket");
		return false;
	}
	int fl = fcntl(fd, F_GETFL, 0);
	if (fl >= 0) {
		(void)fcntl(fd, F_SETFL, fl | O_NONBLOCK);
	}
	int one = 1;
	::setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
	sockaddr_in addr{};
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons(static_cast< uint16_t >(port));
	if (::bind(fd, reinterpret_cast< sockaddr * >(&addr), sizeof(addr)) != 0) {
		logger.log(mc::core::LogLevel::Error, "seriald",
				   "failed to bind telemetry tcp port=" + std::to_string(port));
		::close(fd);
		return false;
	}
	if (::listen(fd, 16) != 0) {
		logger.log(mc::core::LogLevel::Error, "seriald",
				   "failed to listen telemetry tcp port=" +
					   std::to_string(port));
		::close(fd);
		return false;
	}
	g_tcp_listen_fd = fd;
	logger.log(mc::core::LogLevel::Info, "seriald",
			   "telemetry tcp listen port=" + std::to_string(port));
	return true;
}
static void tcp_accept_clients(mc::core::Logger &logger) {
	if (g_tcp_listen_fd < 0)
		return;
	while (true) {
		int cfd = ::accept(g_tcp_listen_fd, nullptr, nullptr);
		if (cfd < 0)
			break;
		g_tcp_clients.push_back(TcpClientEntry{cfd});
		logger.log(mc::core::LogLevel::Info, "seriald",
				   "tcp telemetry client connected fd=" + std::to_string(cfd));
	}
}
static void tcp_remove_client(size_t idx) {
	if (idx >= g_tcp_clients.size())
		return;
	::close(g_tcp_clients[idx].fd);
	g_tcp_clients.erase(g_tcp_clients.begin() + (long)idx);
}
static void tcp_broadcast(const uint8_t *data, size_t len) {
	for (size_t i = 0; i < g_tcp_clients.size();) {
		int fd = g_tcp_clients[i].fd;
		ssize_t w = ::send(fd, data, len, MSG_NOSIGNAL);
		if (w <= 0) {
			tcp_remove_client(i);
			continue;
		}
		++i;
	}
}
static void tcp_close_all() {
	for (const auto &c : g_tcp_clients) {
		::close(c.fd);
	}
	g_tcp_clients.clear();
	if (g_tcp_listen_fd >= 0) {
		::close(g_tcp_listen_fd);
		g_tcp_listen_fd = -1;
	}
}
int main(int argc, char **argv) {
	std::string dev = seriald_cfg::DEFAULT_DEV;
	int baud = seriald_cfg::DEFAULT_BAUD;
	std::string control_sock = seriald_cfg::DEFAULT_CONTROL_SOCK;
	std::string telemetry_sock = seriald_cfg::DEFAULT_TELEMETRY_SOCK;
	int telemetry_tcp_port = seriald_cfg::DEFAULT_TELEMETRY_TCP_PORT;
	std::string logpath = seriald_cfg::DEFAULT_LOG;
	std::string compat_control_sock = seriald_cfg::DEFAULT_COMPAT_CONTROL_SOCK;
	std::string compat_telemetry_sock =
		seriald_cfg::DEFAULT_COMPAT_TELEMETRY_SOCK;
	for (int i = 1; i < argc; i++) {
		std::string a = argv[i];
		if (a == "--dev" && i + 1 < argc)
			dev = argv[++i];
		else if (a == "--baud" && i + 1 < argc)
			baud = atoi(argv[++i]);
		else if ((a == "--sock" || a == "--control-sock") && i + 1 < argc)
			control_sock = argv[++i];
		else if (a == "--telemetry-sock" && i + 1 < argc)
			telemetry_sock = argv[++i];
		else if (a == "--telemetry-tcp-port" && i + 1 < argc)
			telemetry_tcp_port = atoi(argv[++i]);
		else if (a == "--log" && i + 1 < argc)
			logpath = argv[++i];
	}
	mc::core::ensure_dir(mc::core::dir_of(logpath));
	auto &logger = mc::core::Logger::instance();
	logger.addSink(std::make_shared< mc::core::FileSink >(logpath));
	logger.log(mc::core::LogLevel::Info, "seriald",
			   "starting dev=" + dev + " baud=" + std::to_string(baud) +
				   " control_sock=" + control_sock +
				   " telemetry_sock=" + telemetry_sock +
				   " telemetry_tcp_port=" + std::to_string(telemetry_tcp_port));
	mc::serial::Uart uart;
	if (!uart.open(dev, baud)) {
		logger.log(mc::core::LogLevel::Fatal, "seriald",
				   "failed to open uart " + dev);
		return 1;
	}
	mc::ipc::UdsServer control_ipc(SOCK_SEQPACKET);
	mc::ipc::UdsServer control_compat_ipc(SOCK_SEQPACKET);
	mc::ipc::UdsServer telemetry_ipc(SOCK_SEQPACKET);
	mc::ipc::UdsServer telemetry_compat_ipc(SOCK_SEQPACKET);
	std::vector< ServerEntry > servers;
	add_server(servers, control_ipc, control_sock, false, "control", logger);
	if (compat_control_sock != control_sock) {
		add_server(servers, control_compat_ipc, compat_control_sock, false,
				   "control_compat", logger);
	}
	add_server(servers, telemetry_ipc, telemetry_sock, true, "telemetry",
			   logger);
	if (compat_telemetry_sock != telemetry_sock) {
		add_server(servers, telemetry_compat_ipc, compat_telemetry_sock, true,
				   "telemetry_compat", logger);
	}
	bool have_control = false;
	bool have_telemetry = false;
	for (const auto &entry : servers) {
		have_control = have_control || !entry.telemetry;
		have_telemetry = have_telemetry || entry.telemetry;
	}
	if (!have_control || !have_telemetry) {
		logger.log(mc::core::LogLevel::Fatal, "seriald",
				   "failed to open required ipc sockets");
		return 1;
	}
	if (telemetry_tcp_port > 0) {
		setup_tcp_listener(telemetry_tcp_port, logger);
	}
	mc::proto::PacketReader pr;
	std::atomic< bool > run{true};
	std::thread txThread([&] {
		while (run) {
			TxMsg m{};
			if (tx_dequeue(m)) {
				int off = 0;
				while (off < (int)m.len) {
					int w = uart.write(m.data + off, (int)m.len - off);
					if (w < 0) {
						logger.log(mc::core::LogLevel::Error, "seriald",
								   "uart write failed");
						break;
					}
					if (w == 0)
						break;
					off += w;
				}
			} else {
				usleep(seriald_cfg::TX_IDLE_US);
			}
		}
	});
	while (run) {
		std::vector< pollfd > fds;
		fds.reserve(2 + servers.size() + seriald_cfg::MAX_CLIENT_FDS);
		pollfd uart_fd{};
		uart_fd.fd = uart.fd();
		uart_fd.events = POLLIN;
		fds.push_back(uart_fd);
		for (const auto &entry : servers) {
			pollfd srv_fd{};
			srv_fd.fd = entry.server->fd();
			srv_fd.events = POLLIN;
			fds.push_back(srv_fd);
		}
		if (g_tcp_listen_fd >= 0) {
			pollfd tcp_fd{};
			tcp_fd.fd = g_tcp_listen_fd;
			tcp_fd.events = POLLIN;
			fds.push_back(tcp_fd);
		}
		struct ClientEntry {
			int fd;
			bool telemetry;
		};
		std::vector< ClientEntry > client_entries;
		for (const auto &entry : servers) {
			const auto &clients = entry.server->clients();
			size_t client_count = clients.size();
			if (client_count > (size_t)seriald_cfg::MAX_CLIENT_FDS)
				client_count = seriald_cfg::MAX_CLIENT_FDS;
			for (size_t i = 0; i < client_count; ++i) {
				int cfd = clients[i];
				client_entries.push_back(ClientEntry{cfd, entry.telemetry});
				pollfd p{};
				p.fd = cfd;
				p.events = POLLIN;
				fds.push_back(p);
			}
		}
		int r = ::poll(fds.data(), (nfds_t)fds.size(),
					   seriald_cfg::POLL_TIMEOUT_MS);
		if (r < 0)
			continue;
		const size_t server_start = 1;
		for (size_t i = 0; i < servers.size(); ++i) {
			if (!(fds[server_start + i].revents & POLLIN))
				continue;
			while (true) {
				int cfd = servers[i].server->accept_client();
				if (cfd < 0)
					break;
				logger.log(mc::core::LogLevel::Info, "seriald",
						   "client connected role=" + servers[i].role +
							   " fd=" + std::to_string(cfd));
			}
		}
		size_t tcp_poll_idx = server_start + servers.size();
		if (g_tcp_listen_fd >= 0) {
			if (fds[tcp_poll_idx].revents & POLLIN) {
				tcp_accept_clients(logger);
			}
			++tcp_poll_idx;
		}
		if (fds[0].revents & POLLIN) {
			uint8_t buf[1024];
			int n = uart.read(buf, (int)sizeof(buf));
			if (n > 0) {
				for (int i = 0; i < n; i++) {
					if (pr.push(buf[i]) && pr.hasFrame()) {
						const auto &f = pr.frame();
						if (f.type() == (uint8_t)mc::proto::Type::LOG &&
							f.payload_len >= 1) {
							const uint8_t *p = f.payload;
							uint8_t lv = p[0];
							std::string msg;
							if (f.payload_len > 1) {
								msg.assign(
									reinterpret_cast< const char * >(p + 1),
									f.payload_len - 1);
							}
							if (msg.empty()) {
								msg = "ESPLOG (empty)";
							}
							logger.log(mapEspLv(lv), "esp32", msg);
						} else if (f.type() ==
									   (uint8_t)mc::proto::Type::STATUS &&
								   f.payload_len == sizeof(EspStatusPayload)) {
							const uint8_t *p = f.payload;
							uint8_t seq = p[0];
							uint8_t auto_active = p[1];
							uint16_t faults = rd16u(p + 2);
							int16_t vmm = rd16s(p + 4);
							int16_t scd = rd16s(p + 6);
							uint16_t age_ms = rd16u(p + 8);
							logger.log(
								mc::core::LogLevel::Info, "seriald",
								"STATUS seq=" + std::to_string(seq) +
									" auto=" + std::to_string(auto_active) +
									" v_mm_s=" + std::to_string(vmm) +
									" steer_cdeg=" + std::to_string(scd) +
									" age_ms=" + std::to_string(age_ms) +
									" faults=0x" + [](uint16_t x) {
										char b[16];
										snprintf(b, sizeof(b), "%04x", x);
										return std::string(b);
									}(faults));
						} else {
							logger.log(
								mc::core::LogLevel::Debug, "seriald",
								"RX type=0x" +
									[](uint8_t x) {
										char b[8];
										snprintf(b, sizeof(b), "%02x", x);
										return std::string(b);
									}(f.type()) +
									" len=" + std::to_string(f.payload_len));
						}
						uint8_t enc[mc::proto::MAX_FRAME_ENCODED];
						size_t enc_len = 0;
						const uint16_t seq = f.seq();
						if (mc::proto::PacketWriter::build(
								enc, sizeof(enc), enc_len,
								static_cast< mc::proto::Type >(f.type()),
								f.flags(), seq, f.payload, f.payload_len)) {
							broadcast_to(servers, false, enc, enc_len);
							broadcast_to(servers, true, enc, enc_len);
							tcp_broadcast(enc, enc_len);
						}
						pr.consumeFrame();
					}
				}
			}
		}
		const size_t client_start = tcp_poll_idx;
		for (size_t i = client_start; i < fds.size(); ++i) {
			if (!(fds[i].revents & POLLIN))
				continue;
			const ClientEntry &entry = client_entries[i - client_start];
			uint8_t buf[mc::proto::MAX_FRAME_ENCODED];
			ssize_t n = ::recv(fds[i].fd, buf, sizeof(buf), 0);
			if (n <= 0) {
				remove_client_from_servers(servers, fds[i].fd);
				continue;
			}
			if (entry.telemetry) {
				logger.log(mc::core::LogLevel::Warn, "seriald",
						   "telemetry client attempted send; disconnect fd=" +
							   std::to_string(fds[i].fd));
				remove_client_from_servers(servers, fds[i].fd);
				continue;
			}
			tx_enqueue(buf, (uint16_t)n);
			broadcast_to(servers, true, buf, (size_t)n);
			tcp_broadcast(buf, (size_t)n);
			logger.log(mc::core::LogLevel::Debug, "seriald",
					   "IPC->UART forward bytes=" + std::to_string(n));
		}
		for (size_t i = 0; i < g_tcp_clients.size();) {
			pollfd tcp_client{};
			tcp_client.fd = g_tcp_clients[i].fd;
			tcp_client.events = POLLIN;
			int rcv = ::poll(&tcp_client, 1, 0);
			if (rcv > 0 && (tcp_client.revents & POLLIN)) {
				uint8_t dummy[64];
				(void)::recv(g_tcp_clients[i].fd, dummy, sizeof(dummy), 0);
				logger.log(
					mc::core::LogLevel::Warn, "seriald",
					"tcp telemetry client attempted send; disconnect fd=" +
						std::to_string(g_tcp_clients[i].fd));
				tcp_remove_client(i);
				continue;
			}
			++i;
		}
	}
	run = false;
	if (txThread.joinable())
		txThread.join();
	tcp_close_all();
	uart.close();
	logger.shutdown();
	return 0;
}
----------------------------------------

----------------------------------------
File: rpi/apps/lidar_received/CMakeLists.txt
----------------------------------------
add_executable(lidar_received
  main.cpp
  LidarScanData.cpp
  ../../src/Process.cpp
  ../../src/Telemetry.cpp
  ../../src/Sender.cpp
  ../../src/LidarReceiver.cpp
  ../../src/lidar_to_esp.cpp
)

target_include_directories(lidar_received PRIVATE
  ${CMAKE_CURRENT_SOURCE_DIR}
  ${CMAKE_CURRENT_SOURCE_DIR}/config
  ../../src
  ../../src/config
  ../../lib/mc_core/include
)
target_include_directories(lidar_received SYSTEM PRIVATE
  ../../lib/rplidar_sdk/sdk/include
)

target_compile_options(lidar_received PRIVATE -Wall -Wextra -Wpedantic
  -Wno-zero-length-array)

set(RPLIDAR_LIB_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../../lib/rplidar_sdk/output/${CMAKE_SYSTEM_NAME}/Release")
find_library(RPLIDAR_LIB sl_lidar_sdk PATHS ${RPLIDAR_LIB_DIR})

target_link_libraries(lidar_received PRIVATE
  ${RPLIDAR_LIB}
  mc_ipc
  mc_proto
  pthread
)
----------------------------------------

----------------------------------------
File: rpi/apps/lidar_received/config/Config.h
----------------------------------------
#pragma once
namespace lidar_received_cfg {
static constexpr const char *DEFAULT_LOG = "./logs/lidar_received.log";
} 
----------------------------------------

----------------------------------------
File: rpi/apps/lidar_received/LidarScanData.hpp
----------------------------------------
#ifndef LIDARSCANDATA_HPP
#define LIDARSCANDATA_HPP
#include <cstdint>
class LidarScanData {
private:
	int32_t distance_mm[181];
public:
	LidarScanData();
	~LidarScanData();
	int32_t getDistance(int32_t angle) const;
	bool setDistance(int32_t angle, int32_t value);
	void clear();
};
#endif
----------------------------------------

----------------------------------------
File: rpi/apps/lidar_received/lidar_recieiver.h
----------------------------------------
#pragma once
#include "../../src/config/Config.h"
#include "LidarScanData.hpp"
#include "sl_lidar.h"
#include "sl_lidar_driver.h"
#include <csignal>
#include <semaphore.h>
#include <unistd.h>
#include <cstdint>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <cmath>
#define LIDAR_UPDATED   1
#define LIDAR_NOUPDATED 0
struct	ShmLidarScanData {
	uint32_t seq;
	int32_t distance_mm[181];
};
----------------------------------------

----------------------------------------
File: rpi/apps/lidar_received/LidarScanData.cpp
----------------------------------------
#include "LidarScanData.hpp"
LidarScanData::LidarScanData() {
	for (int i = 0; i < 181; i++)
		distance_mm[i] = 0;
}
LidarScanData::~LidarScanData() {}
int32_t LidarScanData::getDistance(int32_t angle) const {
	if (angle < -90 || angle > 90)
		return (-1);
	int32_t index = angle + 90;
	return (distance_mm[index]);
}
bool LidarScanData::setDistance(int32_t angle, int32_t value) {
	if (angle < -90 || angle > 90)
		return (false);
	int32_t index = angle + 90;
	distance_mm[index] = value;
	return (true);
}
void LidarScanData::clear() {
	for (int i = 0; i < 181; i++)
		distance_mm[i] = 0;
}
----------------------------------------

----------------------------------------
File: rpi/apps/lidar_received/main.cpp
----------------------------------------
#include "config/Config.h"
#include "lidar_recieiver.h"
#include <mc/core/Log.hpp>
#include <cerrno>
#include <memory>
#include <string>
#include <sys/stat.h>
static sl::ILidarDriver *g_lidar = 0;
static sl::IChannel *g_ch = 0;
static int g_shm_fd = -1;
static ShmLidarScanData *g_shm = 0;
static sem_t *g_sem = SEM_FAILED;
static bool g_shm_owner = false;
static bool g_sem_owner = false;
static const char *SHM_NAME = "/lidar_scan";
static const char *SEM_NAME = "/lidar_scan_sem";
static volatile sig_atomic_t g_stop = 0;
static void on_sig(int sig) {
	(void)sig;
	g_stop = 1;
}
static void cleanup_lidar_partial() {
	if (g_lidar) {
		g_lidar->stop();
		g_lidar->disconnect();
		delete g_lidar;
		g_lidar = 0;
	}
	if (g_ch) {
		delete g_ch;
		g_ch = 0;
	}
}
bool start_lidar() {
	const char *dev = cfg::DEFAULT_LIDAR_DEVICE;
	int baud = cfg::DEFAULT_LIDAR_BAUD;
	auto channelRes = sl::createSerialPortChannel(std::string(dev), baud);
	if (!channelRes)
		return (MC_LOGE("lidar_received",
						"createSerialPortChannel failed dev=" +
							std::string(dev) + " baud=" + std::to_string(baud)),
				cleanup_lidar_partial(), false);
	g_ch = channelRes.value;
	auto lidarRes = sl::createLidarDriver();
	if (!lidarRes)
		return (MC_LOGE("lidar_received", "createLidarDriver failed"),
				cleanup_lidar_partial(), false);
	g_lidar = lidarRes.value;
	if (SL_IS_FAIL(g_lidar->connect(g_ch)))
		return (MC_LOGE("lidar_received", "lidar connect failed"),
				cleanup_lidar_partial(), false);
	sl_lidar_response_device_info_t info;
	if (SL_IS_FAIL(g_lidar->getDeviceInfo(info)))
		return (MC_LOGE("lidar_received", "getDeviceInfo failed"),
				cleanup_lidar_partial(), false);
	sl_lidar_response_device_health_t health;
	if (SL_IS_FAIL(g_lidar->getHealth(health)))
		return (MC_LOGE("lidar_received", "getHealth failed"),
				cleanup_lidar_partial(), false);
	if (SL_IS_FAIL(g_lidar->setMotorSpeed()))
		return (MC_LOGE("lidar_received", "setMotorSpeed failed"),
				cleanup_lidar_partial(), false);
	sl::LidarScanMode scanMode;
	if (SL_IS_FAIL(g_lidar->startScan(false, true, 0, &scanMode)))
		return (MC_LOGE("lidar_received", "startScan failed"),
				cleanup_lidar_partial(), false);
	MC_LOGI("lidar_received", "lidar started dev=" + std::string(dev) +
								  " baud=" + std::to_string(baud));
	return (true);
}
void cleanup_sem() {
	if (g_sem != SEM_FAILED && g_sem != 0) {
		sem_close(g_sem);
		g_sem = SEM_FAILED;
	}
	if (g_shm && g_shm != MAP_FAILED) {
		munmap(g_shm, sizeof(ShmLidarScanData));
		g_shm = 0;
	}
	if (g_shm_fd >= 0) {
		close(g_shm_fd);
		g_shm_fd = -1;
	}
	if (g_sem_owner) {
		sem_unlink(SEM_NAME);
		g_sem_owner = false;
	}
	if (g_shm_owner) {
		shm_unlink(SHM_NAME);
		g_shm_owner = false;
	}
}
bool init_sem() {
	g_shm_fd = shm_open(SHM_NAME, O_CREAT | O_EXCL | O_RDWR, 0666);
	if (g_shm_fd < 0) {
		if (errno != EEXIST)
			return (MC_LOGE("lidar_received", "shm_open failed"), cleanup_sem(),
					false);
		g_shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);
		if (g_shm_fd < 0)
			return (MC_LOGE("lidar_received", "shm_open existing failed"),
					cleanup_sem(), false);
		g_shm_owner = false;
	} else {
		g_shm_owner = true;
	}
	if (g_shm_owner) {
		if (ftruncate(g_shm_fd, (off_t)sizeof(ShmLidarScanData)) < 0)
			return (MC_LOGE("lidar_received", "ftruncate failed"),
					cleanup_sem(), false);
	}
	void *p = mmap(NULL, sizeof(ShmLidarScanData), PROT_READ | PROT_WRITE,
				   MAP_SHARED, g_shm_fd, 0);
	if (p == MAP_FAILED)
		return (MC_LOGE("lidar_received", "mmap failed"), cleanup_sem(), false);
	g_shm = (ShmLidarScanData *)p;
	g_sem = sem_open(SEM_NAME, O_CREAT | O_EXCL, 0666, 1);
	if (g_sem == SEM_FAILED) {
		if (errno != EEXIST)
			return (MC_LOGE("lidar_received", "sem_open failed"), cleanup_sem(),
					false);
		g_sem = sem_open(SEM_NAME, 0);
		if (g_sem == SEM_FAILED)
			return (MC_LOGE("lidar_received", "sem_open existing failed"),
					cleanup_sem(), false);
		g_sem_owner = false;
	} else {
		g_sem_owner = true;
	}
	if (g_shm_owner || g_sem_owner) {
		while (sem_wait(g_sem) == -1) {
			if (errno == EINTR) {
				if (g_stop)
					return (MC_LOGE("lidar_received",
									"sem_wait interrupted during init"),
							cleanup_sem(), false);
				continue;
			}
			return (MC_LOGE("lidar_received", "sem_wait failed"), cleanup_sem(),
					false);
		}
		g_shm->seq = LIDAR_NOUPDATED;
		for (int i = 0; i < 181; ++i)
			g_shm->distance_mm[i] = 0;
		sem_post(g_sem);
	}
	MC_LOGI("lidar_received", std::string("shared memory ready owner=") +
								  (g_shm_owner ? "1" : "0") +
								  " sem_owner=" + (g_sem_owner ? "1" : "0"));
	return (true);
}
static inline float normalize_deg_180(float deg) {
	while (deg >= 180.f)
		deg -= 360.f;
	while (deg < -180.f)
		deg += 360.f;
	return (deg);
}
static bool receiveScanData(LidarScanData *scan_data) {
	sl_lidar_response_measurement_node_hq_t nodes[cfg::LIDAR_NODE_MAX];
	size_t nodeCount = sizeof(nodes) / sizeof(nodes[0]);
	sl_result ans = g_lidar->grabScanDataHq(nodes, nodeCount);
	if (!SL_IS_OK(ans) || nodeCount == 0)
		return (false);
	ans = g_lidar->ascendScanData(nodes, nodeCount);
	if (!SL_IS_OK(ans))
		return (false);
	for (int i = -90; i <= 90; ++i)
		scan_data->setDistance(i, 0);
	for (size_t i = 0; i < nodeCount; i++) {
		if (nodes[i].dist_mm_q2 == 0)
			continue;
		float angle = (float)nodes[i].angle_z_q14 * 90.f / 16384.f;
		angle = normalize_deg_180(angle);
		int32_t angle_i = static_cast< int32_t >(std::roundf(angle));
		if (angle_i < -90 || angle_i > 90)
			continue;
		int32_t dist = (int32_t)(nodes[i].dist_mm_q2 >> 2);
		if (dist <= 0)
			continue;
		int32_t old_data = scan_data->getDistance(angle_i);
		if (old_data > dist || old_data <= 0)
			scan_data->setDistance(angle_i, dist);
	}
	return (true);
}
void write_to_mem(const LidarScanData &scan_data) {
	while (sem_wait(g_sem) == -1) {
		if (errno == EINTR)
			continue;
		MC_LOGE("lidar_received", "sem_wait failed in write_to_mem");
		return;
	}
	for (int i = -90; i <= 90; ++i)
		g_shm->distance_mm[i + 90] = scan_data.getDistance(i);
	if (g_shm->seq == UINT32_MAX)
		g_shm->seq = 1;
	else
		g_shm->seq++;
	sem_post(g_sem);
}
static void ensure_dir_for(const std::string &path) {
	if (path.empty())
		return;
	const size_t pos = path.find_last_of('/');
	if (pos == std::string::npos || pos == 0)
		return;
	const std::string dir = path.substr(0, pos);
	const int rc = mkdir(dir.c_str(), 0755);
	if (rc == 0 || errno == EEXIST)
		return;
	MC_LOGW("lidar_received", "mkdir failed for log dir: " + dir);
}
int main(int argc, char **argv) {
	signal(SIGINT, on_sig);
	signal(SIGTERM, on_sig);
	std::string log_path = lidar_received_cfg::DEFAULT_LOG;
	for (int i = 1; i < argc; ++i) {
		std::string a = argv[i];
		if (a == "--log" && i + 1 < argc) {
			log_path = argv[++i];
		}
	}
	auto &logger = mc::core::Logger::instance();
	if (!log_path.empty()) {
		ensure_dir_for(log_path);
		logger.addSink(std::make_shared< mc::core::FileSink >(log_path));
	}
	MC_LOGI("lidar_received", "starting");
	if (!start_lidar() || !init_sem()) {
		logger.shutdown();
		return (1);
	}
	LidarScanData scan_data;
	while (!g_stop) {
		if (receiveScanData(&scan_data))
			write_to_mem(scan_data);
		else
			usleep(1000);
	}
	MC_LOGI("lidar_received", "shutdown");
	cleanup_lidar_partial();
	cleanup_sem();
	logger.shutdown();
	return (0);
}
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/lidar_bridge/lidar_bridge/__init__.py
----------------------------------------
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/lidar_bridge/lidar_bridge/bridge_node.py
----------------------------------------
import mmap
import struct
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
SHM_PATH = "/dev/shm/lidar_scan"
POINTS = 181
ANGLE_MIN = -1.5707963267948966
ANGLE_MAX = 1.5707963267948966
ANGLE_INCREMENT = 3.141592653589793 / 180.0
RANGE_MIN = 0.005
RANGE_MAX = 20.0
def _read_scan(mm: mmap.mmap):
    raw = mm.read(4 + POINTS * 4)
    mm.seek(0)
    if len(raw) < 4 + POINTS * 4:
        return None
    seq = struct.unpack_from("<I", raw, 0)[0]
    distances = struct.unpack_from("<" + "i" * POINTS, raw, 4)
    return seq, distances
class LidarBridge(Node):
    def __init__(self) -> None:
        super().__init__("lidar_bridge")
        self._pub = self.create_publisher(LaserScan, "/scan", 10)
        self._last_seq = 0
        self._mm = None
        self._declare_params()
        self._timer = self.create_timer(0.05, self._tick)
    def _declare_params(self) -> None:
        self.declare_parameter("shm_path", SHM_PATH)
        self.declare_parameter("range_min", RANGE_MIN)
        self.declare_parameter("range_max", RANGE_MAX)
        self.declare_parameter("frame_id", "laser")
    def _connect(self) -> bool:
        if self._mm is not None:
            return True
        path = str(self.get_parameter("shm_path").value)
        try:
            with open(path, "rb") as f:
                self._mm = mmap.mmap(f.fileno(), 4 + POINTS * 4, access=mmap.ACCESS_READ)
            self.get_logger().info(f"connected shm {path}")
            return True
        except FileNotFoundError:
            return False
        except OSError as exc:
            self.get_logger().warning(f"failed to open shm {path}: {exc}")
            return False
    def _tick(self) -> None:
        if not self._connect():
            return
        scan = _read_scan(self._mm)
        if scan is None:
            return
        seq, distances = scan
        if seq == 0 or seq == self._last_seq:
            return
        self._last_seq = seq
        msg = LaserScan()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = str(self.get_parameter("frame_id").value)
        msg.angle_min = ANGLE_MIN
        msg.angle_max = ANGLE_MAX
        msg.angle_increment = ANGLE_INCREMENT
        msg.range_min = float(self.get_parameter("range_min").value)
        msg.range_max = float(self.get_parameter("range_max").value)
        ranges = []
        range_max = msg.range_max
        for dist_mm in distances:
            if dist_mm <= 0:
                ranges.append(float("inf"))
            else:
                ranges.append(min(dist_mm / 1000.0, range_max))
        msg.ranges = ranges
        self._pub.publish(msg)
    def shutdown(self) -> None:
        if self._mm is not None:
            self._mm.close()
            self._mm = None
def main() -> int:
    node: LidarBridge | None = None
    try:
        rclpy.init()
        node = LidarBridge()
        rclpy.spin(node)
        return 0
    except Exception as exc:
        logger = rclpy.logging.get_logger("lidar_bridge")
        logger.error(f"fatal error: {exc}")
        return 1
    finally:
        if node is not None:
            node.shutdown()
            node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()
if __name__ == "__main__":
    raise SystemExit(main())
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/lidar_bridge/setup.py
----------------------------------------
from setuptools import setup
package_name = "lidar_bridge"
setup(
    name=package_name,
    version="0.0.1",
    packages=[package_name],
    data_files=[
        ("share/ament_index/resource_index/packages", [f"resource/{package_name}"]),
        ("share/" + package_name, ["package.xml"]),
    ],
    install_requires=["setuptools"],
    zip_safe=True,
    maintainer="dev",
    maintainer_email="dev@example.com",
    description="Bridge SHM lidar_scan to ROS2 LaserScan.",
    license="MIT",
    entry_points={
        "console_scripts": [
            "lidar_bridge = lidar_bridge.bridge_node:main",
        ],
    },
)
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_bridge/mc_bridge/mc_proto_codec.py
----------------------------------------
import struct
from typing import Optional, Tuple
MAGIC = b"MC"
VER = 1
TYPE_DRIVE = 0x01
TYPE_KILL = 0x02
TYPE_MODE_SET = 0x03
TYPE_PING = 0x04
TYPE_LOG = 0x10
TYPE_STATUS = 0x11
TYPE_HILS_STATE = 0x12
TYPE_ACK = 0x80
FLAG_ACK_REQ = 1 << 0
def crc16_ccitt(data: bytes) -> int:
    crc = 0xFFFF
    for b in data:
        crc ^= (b << 8) & 0xFFFF
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) ^ 0x1021) & 0xFFFF
            else:
                crc = (crc << 1) & 0xFFFF
    return crc
def cobs_decode(inp: bytes) -> bytes:
    if not inp:
        return b""
    out = bytearray()
    idx = 0
    while idx < len(inp):
        code = inp[idx]
        if code == 0:
            return b""
        idx += 1
        for _ in range(code - 1):
            if idx >= len(inp):
                return b""
            out.append(inp[idx])
            idx += 1
        if code != 0xFF and idx < len(inp):
            out.append(0)
    return bytes(out)
def decode_packet(enc: bytes) -> Tuple[Optional[Tuple[int, int, int, bytes]], str]:
    if not enc:
        return None, "empty"
    if enc[-1] == 0:
        enc = enc[:-1]
    raw = cobs_decode(enc)
    if len(raw) < 11:
        return None, "cobs"
    hdr = raw[:9]
    magic, ver, ptype, flags, seq, plen = struct.unpack("<2sBBBHH", hdr)
    if magic != MAGIC or ver != VER:
        return None, "header"
    payload = raw[9:-2]
    if len(payload) != plen:
        return None, "length"
    crc_got = struct.unpack("<H", raw[-2:])[0]
    crc_exp = crc16_ccitt(raw[:-2])
    if crc_got != crc_exp:
        return None, "crc"
    return (ptype, flags, seq, payload), ""
def decode_status(payload: bytes):
    if len(payload) != 10:
        return None
    seq_applied, auto_active, faults, speed, steer, age_ms = struct.unpack(
        "<BBHhhH", payload
    )
    return seq_applied, auto_active, faults, speed, steer, age_ms
def decode_drive(payload: bytes):
    if len(payload) != 8:
        return None
    steer, speed, ttl_ms, dist_mm = struct.unpack("<hhHH", payload)
    return steer, speed, ttl_ms, dist_mm
def decode_hils_state(payload: bytes):
    if len(payload) != 9:
        return None
    ts_ms, throttle_raw, steer_cdeg, flags = struct.unpack("<IhhB", payload)
    return ts_ms, throttle_raw, steer_cdeg, flags
def decode_log(payload: bytes):
    if len(payload) < 1:
        return None
    level = payload[0]
    text = payload[1:].decode("utf-8", errors="replace")
    return level, text
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_bridge/mc_bridge/__init__.py
----------------------------------------
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_bridge/mc_bridge/bridge_node.py
----------------------------------------
import socket
import threading
import time
import rclpy
from rclpy.node import Node
from rclpy.qos import (
    QoSDurabilityPolicy,
    QoSHistoryPolicy,
    QoSProfile,
    QoSReliabilityPolicy,
)
from std_msgs.msg import String
from mc_msgs.msg import DriveCmd, HilsState, LogRecord, Status
from .mc_proto_codec import (
    TYPE_DRIVE,
    TYPE_HILS_STATE,
    TYPE_LOG,
    TYPE_STATUS,
    decode_drive,
    decode_hils_state,
    decode_log,
    decode_packet,
    decode_status,
)
class RunIdCache:
    def __init__(self, node: Node) -> None:
        qos = QoSProfile(depth=1)
        qos.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL
        qos.reliability = QoSReliabilityPolicy.RELIABLE
        qos.history = QoSHistoryPolicy.KEEP_LAST
        self._node = node
        self._lock = threading.Lock()
        self._run_id = ""
        self._sub = node.create_subscription(
            String,
            "/mc/run_id",
            self._on_run_id,
            qos,
        )
    @property
    def run_id(self) -> str:
        with self._lock:
            return self._run_id
    def _on_run_id(self, msg: String) -> None:
        if msg.data:
            with self._lock:
                self._run_id = msg.data
class LogPublisher:
    def __init__(self, node: Node, run_id_cache: RunIdCache) -> None:
        qos = QoSProfile(depth=10)
        qos.reliability = QoSReliabilityPolicy.BEST_EFFORT
        qos.history = QoSHistoryPolicy.KEEP_LAST
        self._node = node
        self._run_id_cache = run_id_cache
        self._pub = node.create_publisher(LogRecord, "/mc/log", qos)
        self._last_warn_ns = 0
    def publish(self, level: int, text: str, ts_ms: int) -> bool:
        run_id = self._run_id_cache.run_id
        if not run_id:
            now_ns = self._node.get_clock().now().nanoseconds
            if now_ns - self._last_warn_ns > 5_000_000_000:
                self._node.get_logger().warning("run_id not set; dropping /mc/log")
                self._last_warn_ns = now_ns
            return False
        msg = LogRecord()
        msg.ts_ms = ts_ms
        msg.level = level
        msg.text = text
        msg.run_id = run_id
        self._pub.publish(msg)
        return True
class BridgeNode(Node):
    def __init__(self) -> None:
        super().__init__("mc_bridge")
        self._run_id_cache = RunIdCache(self)
        self._log_pub = LogPublisher(self, self._run_id_cache)
        self._decode_errors = 0
        self._crc_errors = 0
        self._last_decode_warn_ns = 0
        self._last_crc_warn_ns = 0
        self.declare_parameter("demo_log", False)
        self.declare_parameter("demo_period_sec", 1.0)
        self.declare_parameter(
            "telemetry_sock", "/tmp/roboracer/seriald.telemetry.sock"
        )
        self.declare_parameter(
            "telemetry_compat_sock", "/run/roboracer/seriald.telemetry.sock"
        )
        self.declare_parameter("telemetry_tcp_host", "")
        self.declare_parameter("telemetry_tcp_port", 0)
        qos_reliable = QoSProfile(depth=10)
        qos_reliable.reliability = QoSReliabilityPolicy.RELIABLE
        qos_reliable.history = QoSHistoryPolicy.KEEP_LAST
        self._status_pub = self.create_publisher(Status, "/mc/status", qos_reliable)
        self._drive_pub = self.create_publisher(DriveCmd, "/mc/drive_cmd", qos_reliable)
        self._hils_pub = self.create_publisher(HilsState, "/mc/hils_state", qos_reliable)
        self._stop_evt = threading.Event()
        self._telemetry_thread = threading.Thread(
            target=self._telemetry_loop, name="mc_bridge_telemetry", daemon=True
        )
        self._telemetry_thread.start()
        if self.get_parameter("demo_log").value:
            period = float(self.get_parameter("demo_period_sec").value)
            if period <= 0.0:
                raise ValueError("demo_period_sec must be > 0 when demo_log is true")
            self.create_timer(period, self._demo_log)
    def _demo_log(self) -> None:
        ts_ms = int(self.get_clock().now().nanoseconds / 1_000_000)
        self._log_pub.publish(1, "demo log", ts_ms)
    def _warn_decode(self, msg: str, crc: bool) -> None:
        now_ns = self.get_clock().now().nanoseconds
        if crc:
            self._crc_errors += 1
            if now_ns - self._last_crc_warn_ns > 5_000_000_000:
                self.get_logger().warning(msg)
                self._last_crc_warn_ns = now_ns
        else:
            self._decode_errors += 1
            if now_ns - self._last_decode_warn_ns > 5_000_000_000:
                self.get_logger().warning(msg)
                self._last_decode_warn_ns = now_ns
        ts_ms = int(now_ns / 1_000_000)
        self._log_pub.publish(2, msg, ts_ms)
    def _connect_telemetry(self) -> tuple[socket.socket | None, bool]:
        tcp_host = str(self.get_parameter("telemetry_tcp_host").value)
        tcp_port = int(self.get_parameter("telemetry_tcp_port").value)
        if tcp_host and tcp_port > 0:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1.0)
                sock.connect((tcp_host, tcp_port))
                self.get_logger().info(
                    f"connected telemetry tcp: {tcp_host}:{tcp_port}"
                )
                return sock, True
            except OSError:
                try:
                    sock.close()
                except Exception:
                    pass
                return None, False
        primary = str(self.get_parameter("telemetry_sock").value)
        compat = str(self.get_parameter("telemetry_compat_sock").value)
        for path in (primary, compat):
            try:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                sock.settimeout(0.5)
                sock.connect(path)
                self.get_logger().info(f"connected telemetry socket: {path}")
                return sock, False
            except OSError:
                try:
                    sock.close()
                except Exception:
                    pass
        return None, False
    def _telemetry_loop(self) -> None:
        while not self._stop_evt.is_set():
            sock, is_stream = self._connect_telemetry()
            if sock is None:
                time.sleep(0.5)
                continue
            buf = bytearray()
            try:
                while not self._stop_evt.is_set():
                    try:
                        data = sock.recv(4096)
                    except socket.timeout:
                        continue
                    except OSError:
                        break
                    if not data:
                        break
                    frames = []
                    if is_stream:
                        buf.extend(data)
                        while True:
                            try:
                                end = buf.index(0)
                            except ValueError:
                                break
                            frame = bytes(buf[: end + 1])
                            del buf[: end + 1]
                            frames.append(frame)
                    else:
                        frames.append(data)
                    for frame in frames:
                        pkt, err = decode_packet(frame)
                        if pkt is None:
                            self._warn_decode(f"decode_error: {err}", err == "crc")
                            continue
                        ptype, _flags, _seq, payload = pkt
                        now_ns = self.get_clock().now().nanoseconds
                        if ptype == TYPE_STATUS:
                            dec = decode_status(payload)
                            if dec is None:
                                self._warn_decode("decode_error: status_len", False)
                                continue
                            msg = Status()
                            (
                                msg.seq_applied,
                                msg.auto_active,
                                msg.faults,
                                msg.speed_mm_s,
                                msg.steer_cdeg,
                                msg.age_ms,
                            ) = dec
                            self._status_pub.publish(msg)
                        elif ptype == TYPE_DRIVE:
                            dec = decode_drive(payload)
                            if dec is None:
                                self._warn_decode("decode_error: drive_len", False)
                                continue
                            msg = DriveCmd()
                            msg.steer_cdeg, msg.speed_mm_s, msg.ttl_ms, msg.dist_mm = dec
                            self._drive_pub.publish(msg)
                        elif ptype == TYPE_HILS_STATE:
                            dec = decode_hils_state(payload)
                            if dec is None:
                                self._warn_decode("decode_error: hils_len", False)
                                continue
                            msg = HilsState()
                            msg.timestamp, msg.throttle_raw, msg.steer_cdeg, msg.flags = dec
                            self._hils_pub.publish(msg)
                        elif ptype == TYPE_LOG:
                            dec = decode_log(payload)
                            if dec is None:
                                self._warn_decode("decode_error: log_len", False)
                                continue
                            level, text = dec
                            ts_ms = int(now_ns / 1_000_000)
                            self._log_pub.publish(level, text, ts_ms)
            finally:
                try:
                    sock.close()
                except Exception:
                    pass
    def shutdown(self) -> None:
        self._stop_evt.set()
        if self._telemetry_thread.is_alive():
            self._telemetry_thread.join(timeout=1.0)
def main() -> int:
    node: BridgeNode | None = None
    try:
        rclpy.init()
        node = BridgeNode()
        rclpy.spin(node)
        return 0
    except Exception as exc:
        logger = rclpy.logging.get_logger("mc_bridge")
        logger.error(f"fatal error: {exc}")
        return 1
    finally:
        if node is not None:
            node.shutdown()
            node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()
if __name__ == "__main__":
    raise SystemExit(main())
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_bridge/setup.py
----------------------------------------
from setuptools import setup
package_name = "mc_bridge"
setup(
    name=package_name,
    version="0.1.0",
    packages=[package_name],
    data_files=[
        ("share/ament_index/resource_index/packages", ["resource/" + package_name]),
        ("share/" + package_name, ["package.xml"]),
    ],
    install_requires=["setuptools"],
    zip_safe=True,
    maintainer="Robo Racer",
    maintainer_email="tetsuro997@gmail.com",
    description="Robo Racer mc_bridge skeleton",
    license="MIT",
    entry_points={
        "console_scripts": [
            "mc_bridge = mc_bridge.bridge_node:main",
        ],
    },
)
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_tf_static/setup.py
----------------------------------------
from setuptools import setup
package_name = "mc_tf_static"
setup(
    name=package_name,
    version="0.1.0",
    packages=[package_name],
    data_files=[
        ("share/ament_index/resource_index/packages", ["resource/" + package_name]),
        ("share/" + package_name, ["package.xml"]),
    ],
    install_requires=["setuptools"],
    zip_safe=True,
    maintainer="Robo Racer",
    maintainer_email="tetsuro997@gmail.com",
    description="Static TF publisher for base_link to laser",
    license="MIT",
    entry_points={
        "console_scripts": [
            "mc_tf_static = mc_tf_static.static_tf_node:main",
        ],
    },
)
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_tf_static/mc_tf_static/static_tf_node.py
----------------------------------------
import math
import sys
import rclpy
from geometry_msgs.msg import TransformStamped
from rclpy.node import Node
from tf2_ros import StaticTransformBroadcaster
def euler_to_quaternion(roll: float, pitch: float, yaw: float) -> tuple[float, float, float, float]:
    cy = math.cos(yaw * 0.5)
    sy = math.sin(yaw * 0.5)
    cp = math.cos(pitch * 0.5)
    sp = math.sin(pitch * 0.5)
    cr = math.cos(roll * 0.5)
    sr = math.sin(roll * 0.5)
    w = cr * cp * cy + sr * sp * sy
    x = sr * cp * cy - cr * sp * sy
    y = cr * sp * cy + sr * cp * sy
    z = cr * cp * sy - sr * sp * cy
    return x, y, z, w
class StaticTfNode(Node):
    def __init__(self) -> None:
        super().__init__("mc_tf_static")
        self.declare_parameter("parent_frame", "base_link")
        self.declare_parameter("child_frame", "laser")
        self.declare_parameter("translation_x", 0.0)
        self.declare_parameter("translation_y", 0.0)
        self.declare_parameter("translation_z", 0.0)
        self.declare_parameter("rotation_roll", 0.0)
        self.declare_parameter("rotation_pitch", 0.0)
        self.declare_parameter("rotation_yaw", 0.0)
        self._broadcaster = StaticTransformBroadcaster(self)
        self._publish_transform()
    def _publish_transform(self) -> None:
        parent_frame = str(self.get_parameter("parent_frame").value)
        child_frame = str(self.get_parameter("child_frame").value)
        tx = float(self.get_parameter("translation_x").value)
        ty = float(self.get_parameter("translation_y").value)
        tz = float(self.get_parameter("translation_z").value)
        roll = float(self.get_parameter("rotation_roll").value)
        pitch = float(self.get_parameter("rotation_pitch").value)
        yaw = float(self.get_parameter("rotation_yaw").value)
        if not parent_frame:
            raise ValueError("parent_frame must be non-empty")
        if not child_frame:
            raise ValueError("child_frame must be non-empty")
        qx, qy, qz, qw = euler_to_quaternion(roll, pitch, yaw)
        transform = TransformStamped()
        transform.header.stamp = self.get_clock().now().to_msg()
        transform.header.frame_id = parent_frame
        transform.child_frame_id = child_frame
        transform.transform.translation.x = tx
        transform.transform.translation.y = ty
        transform.transform.translation.z = tz
        transform.transform.rotation.x = qx
        transform.transform.rotation.y = qy
        transform.transform.rotation.z = qz
        transform.transform.rotation.w = qw
        self._broadcaster.sendTransform(transform)
        self.get_logger().info(
            f"publishing static TF {parent_frame} -> {child_frame}"
        )
def main() -> int:
    node: StaticTfNode | None = None
    try:
        rclpy.init()
        node = StaticTfNode()
        rclpy.spin(node)
        return 0
    except Exception as exc:
        logger = rclpy.logging.get_logger("mc_tf_static")
        logger.error(f"fatal error: {exc}")
        return 1
    finally:
        if node is not None:
            node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()
if __name__ == "__main__":
    raise SystemExit(main())
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_tf_static/mc_tf_static/__init__.py
----------------------------------------
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_demo_pub/setup.py
----------------------------------------
from setuptools import setup
package_name = "mc_demo_pub"
setup(
    name=package_name,
    version="0.1.0",
    packages=[package_name],
    data_files=[
        ("share/ament_index/resource_index/packages", ["resource/" + package_name]),
        ("share/" + package_name, ["package.xml"]),
    ],
    install_requires=["setuptools"],
    zip_safe=True,
    maintainer="Robo Racer",
    maintainer_email="tetsuro997@gmail.com",
    description="Demo LaserScan publisher for RViz",
    license="MIT",
    entry_points={
        "console_scripts": [
            "mc_demo_pub = mc_demo_pub.demo_pub_node:main",
        ],
    },
)
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_demo_pub/mc_demo_pub/demo_pub_node.py
----------------------------------------
import math
import sys
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
def clamp(value: float, min_value: float, max_value: float) -> float:
    return max(min_value, min(value, max_value))
class DemoPubNode(Node):
    def __init__(self) -> None:
        super().__init__("mc_demo_pub")
        self.declare_parameter("topic", "/scan")
        self.declare_parameter("frame_id", "laser")
        self.declare_parameter("publish_rate", 5.0)
        self.declare_parameter("angle_min", -math.pi)
        self.declare_parameter("angle_max", math.pi)
        self.declare_parameter("angle_increment", math.radians(1.0))
        self.declare_parameter("range_min", 0.05)
        self.declare_parameter("range_max", 10.0)
        self.declare_parameter("range_mean", 3.0)
        self.declare_parameter("range_variation", 0.25)
        self._topic = str(self.get_parameter("topic").value)
        self._frame_id = str(self.get_parameter("frame_id").value)
        self._publish_rate = float(self.get_parameter("publish_rate").value)
        self._angle_min = float(self.get_parameter("angle_min").value)
        self._angle_max = float(self.get_parameter("angle_max").value)
        self._angle_increment = float(self.get_parameter("angle_increment").value)
        self._range_min = float(self.get_parameter("range_min").value)
        self._range_max = float(self.get_parameter("range_max").value)
        self._range_mean = float(self.get_parameter("range_mean").value)
        self._range_variation = float(self.get_parameter("range_variation").value)
        if self._publish_rate <= 0.0:
            raise ValueError("publish_rate must be > 0")
        if self._angle_increment <= 0.0:
            raise ValueError("angle_increment must be > 0")
        if self._angle_max <= self._angle_min:
            raise ValueError("angle_max must be > angle_min")
        if self._range_max <= self._range_min:
            raise ValueError("range_max must be > range_min")
        self._count = int(round((self._angle_max - self._angle_min) / self._angle_increment)) + 1
        if self._count <= 0:
            raise ValueError("computed scan count is invalid")
        self._scan_time = 1.0 / self._publish_rate
        self._time_increment = self._scan_time / float(self._count)
        self._phase = 0.0
        self._pub = self.create_publisher(LaserScan, self._topic, 10)
        self.create_timer(self._scan_time, self._publish_scan)
        self.get_logger().info(
            f"publishing demo LaserScan on {self._topic} ({self._count} beams)"
        )
    def _publish_scan(self) -> None:
        msg = LaserScan()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = self._frame_id
        msg.angle_min = self._angle_min
        msg.angle_max = self._angle_max
        msg.angle_increment = self._angle_increment
        msg.time_increment = self._time_increment
        msg.scan_time = self._scan_time
        msg.range_min = self._range_min
        msg.range_max = self._range_max
        phase = self._phase
        self._phase += 0.15
        ranges = []
        for i in range(self._count):
            value = self._range_mean + self._range_variation * math.sin(phase + i * 0.08)
            ranges.append(clamp(value, self._range_min, self._range_max))
        msg.ranges = ranges
        self._pub.publish(msg)
def main() -> int:
    node: DemoPubNode | None = None
    try:
        rclpy.init()
        node = DemoPubNode()
        rclpy.spin(node)
        return 0
    except Exception as exc:
        logger = rclpy.logging.get_logger("mc_demo_pub")
        logger.error(f"fatal error: {exc}")
        return 1
    finally:
        if node is not None:
            node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()
if __name__ == "__main__":
    raise SystemExit(main())
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_demo_pub/mc_demo_pub/__init__.py
----------------------------------------
----------------------------------------

----------------------------------------
File: rpi/ros2_ws/src/mc_msgs/CMakeLists.txt
----------------------------------------
cmake_minimum_required(VERSION 3.8)
project(mc_msgs)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/DriveCmd.msg"
  "msg/Status.msg"
  "msg/HilsState.msg"
  "msg/LogRecord.msg"
)

ament_export_dependencies(rosidl_default_runtime)
ament_package()
----------------------------------------

----------------------------------------
File: rpi/src/Sender.cpp
----------------------------------------
#include "Sender.h"
#include "Telemetry.h"
#include "mc/core/Log.hpp"
#include <array>
#include <cerrno>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <sys/socket.h>
#include <time.h>
namespace {
uint32_t now_ms() {
	struct timespec ts;
	clock_gettime(CLOCK_MONOTONIC, &ts);
	const uint64_t ms = static_cast< uint64_t >(ts.tv_sec) * 1000ULL +
						static_cast< uint64_t >(ts.tv_nsec) / 1000000ULL;
	return static_cast< uint32_t >(ms & 0xFFFFFFFFu);
}
int16_t clamp_speed_input(int speed) {
	if (speed > cfg::SPEED_INPUT_LIMIT) {
		speed = cfg::SPEED_INPUT_LIMIT;
	} else if (speed < -cfg::SPEED_INPUT_LIMIT) {
		speed = -cfg::SPEED_INPUT_LIMIT;
	}
	return static_cast< int16_t >(speed);
}
int16_t clamp_cdeg(int32_t cdeg) {
	if (cdeg > cfg::STEER_CDEG_MAX) {
		cdeg = cfg::STEER_CDEG_MAX;
	} else if (cdeg < -cfg::STEER_CDEG_MAX) {
		cdeg = -cfg::STEER_CDEG_MAX;
	}
	return static_cast< int16_t >(cdeg);
}
} 
Sender::Sender(const char *sock_path, TelemetryEmitter *telemetry)
	: telemetry_(telemetry) {
	_init(sock_path);
}
Sender::~Sender() {
	if (auto_enabled_) {
		sendAutoMode(false);
	}
}
void Sender::send(int speed, int angle) {
	poll();
	sendHeartbeatIfDue();
	if (!auto_enabled_) {
		return;
	}
	mc::proto::DrivePayload payload{};
	payload.steer_cdeg =
		clamp_cdeg(static_cast< int32_t >(angle) * cfg::STEER_CDEG_SCALE);
	const int16_t speed_input = clamp_speed_input(speed);
	const int32_t speed_mm_s =
		(int32_t)speed_input * cfg::SPEED_MM_S_MAX / cfg::SPEED_INPUT_LIMIT;
	payload.speed_mm_s = static_cast< int16_t >(speed_mm_s);
	payload.ttl_ms_le = mc::proto::to_le16(cfg::AUTO_TTL_MS);
	payload.dist_mm_le = mc::proto::to_le16(0);
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const uint16_t seq = nextSeq();
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, mc::proto::Type::DRIVE, 0, seq,
		reinterpret_cast< const uint8_t * >(&payload), sizeof(payload));
	if (!ok || ::send(ipc_.fd(), out, out_len, MSG_NOSIGNAL) <= 0) {
		MC_LOGW("sender", "DRIVE send failed");
	}
}
void Sender::sendHeartbeatIfDue() {
	const uint32_t now = now_ms();
	if ((uint32_t)(now - last_hb_ms_) < cfg::HEARTBEAT_INTERVAL_MS) {
		return;
	}
	last_hb_ms_ = now;
	const uint16_t seq = nextSeq();
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, mc::proto::Type::PING, 0, seq, nullptr, 0);
	if (!ok || ::send(ipc_.fd(), out, out_len, MSG_NOSIGNAL) <= 0) {
		MC_LOGW("sender", "PING send failed");
	}
}
void Sender::sendAutoMode(bool enable) {
	uint8_t mode = enable ? 1 : 0;
	const uint16_t seq = nextSeq();
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, mc::proto::Type::MODE_SET,
		mc::proto::FLAG_ACK_REQ, seq, &mode, 1);
	if (!ok || ::send(ipc_.fd(), out, out_len, MSG_NOSIGNAL) <= 0) {
		MC_LOGW("sender", "AUTO_MODE send failed");
		return;
	}
	trackPending(seq, out, (uint16_t)out_len);
	auto_enabled_ = enable;
}
void Sender::sendKill() {
	uint8_t payload[2] = {0, 0};
	const uint16_t seq = nextSeq();
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	const bool ok = mc::proto::PacketWriter::build(
		out, sizeof(out), out_len, mc::proto::Type::KILL,
		mc::proto::FLAG_ACK_REQ, seq, payload, sizeof(payload));
	if (!ok || ::send(ipc_.fd(), out, out_len, MSG_NOSIGNAL) <= 0) {
		MC_LOGW("sender", "KILL send failed");
		return;
	}
	trackPending(seq, out, (uint16_t)out_len);
}
void Sender::poll() {
	checkPending();
	checkStatusLiveness();
	uint8_t buf[mc::proto::MAX_FRAME_ENCODED];
	while (true) {
		int n = (int)::recv(ipc_.fd(), buf, (int)sizeof(buf), 0);
		if (n <= 0)
			break;
		mc::proto::Frame frame{};
		std::array< uint8_t, mc::proto::MAX_FRAME_DECODED > decoded{};
		if (mc::proto::decode_one(buf, (size_t)n, frame, decoded)) {
			handleFrame(frame);
		}
	}
	checkPending();
	checkStatusLiveness();
}
void Sender::_init(const char *sock_path) {
	if (!ipc_.connect(sock_path)) {
		MC_LOGE("sender",
				std::string("Failed to connect seriald socket: ") + sock_path);
		exit(1);
	}
	sendAutoMode(true);
}
void Sender::handleFrame(const mc::proto::Frame &frame) {
	if (frame.type() == (uint8_t)mc::proto::Type::STATUS &&
		frame.payload_len == sizeof(mc::proto::StatusPayload)) {
		mc::proto::StatusPayload payload{};
		memcpy(&payload, frame.payload, sizeof(payload));
		handleStatus(payload);
	} else if (frame.type() == (uint8_t)mc::proto::Type::ACK &&
			   frame.payload_len == 0) {
		const uint16_t seq = frame.seq();
		handleAck(seq);
	}
}
void Sender::handleStatus(const mc::proto::StatusPayload &payload) {
	last_status_ = payload;
	has_status_ = true;
	last_status_ms_ = now_ms();
	status_stale_ = false;
	const uint32_t now = now_ms();
	if ((uint32_t)(now - last_status_log_ms_) < cfg::STATUS_LOG_INTERVAL_MS) {
		return;
	}
	last_status_log_ms_ = now;
	const uint8_t seq = payload.seq_applied;
	const uint8_t auto_active = payload.auto_active;
	const uint16_t faults = mc::proto::from_le16(payload.faults_le);
	const int16_t speed =
		(int16_t)mc::proto::from_le16((uint16_t)payload.speed_mm_s_le);
	const int16_t steer =
		(int16_t)mc::proto::from_le16((uint16_t)payload.steer_cdeg_le);
	const uint16_t age_ms = mc::proto::from_le16(payload.age_ms_le);
	std::ostringstream ss;
	ss << "STATUS seq=" << (unsigned)seq << " auto=" << (unsigned)auto_active
	   << " speed_mm_s=" << speed << " steer_cdeg=" << steer
	   << " age_ms=" << age_ms << " faults=0x" << std::hex << faults
	   << std::dec;
	MC_LOGI("status", ss.str());
	if (telemetry_) {
		telemetry_->updateStatus(auto_active, faults, speed, steer, age_ms);
	}
}
void Sender::handleAck(uint16_t seq) {
	auto it = pending_.find(seq);
	if (it != pending_.end()) {
		pending_.erase(it);
	}
}
void Sender::trackPending(uint16_t seq, const uint8_t *data, uint16_t len) {
	if (len == 0 || len > mc::proto::MAX_FRAME_ENCODED)
		return;
	PendingTx p{};
	p.deadline_ms = now_ms() + cfg::ACK_TIMEOUT_MS;
	p.retries = 0;
	p.len = len;
	memcpy(p.data.data(), data, len);
	pending_[seq] = p;
}
void Sender::checkPending() {
	if (pending_.empty())
		return;
	const uint32_t now = now_ms();
	for (auto it = pending_.begin(); it != pending_.end();) {
		PendingTx &p = it->second;
		if ((int32_t)(now - p.deadline_ms) < 0) {
			++it;
			continue;
		}
		if (p.retries >= cfg::ACK_MAX_RETRY) {
			MC_LOGW("sender", "ACK timeout seq=" + std::to_string(it->first));
			it = pending_.erase(it);
			continue;
		}
		if (::send(ipc_.fd(), p.data.data(), p.len, MSG_NOSIGNAL) <= 0) {
			MC_LOGW("sender",
					"ACK retry send failed seq=" + std::to_string(it->first));
		}
		p.retries = (uint8_t)(p.retries + 1);
		p.deadline_ms = now + cfg::ACK_TIMEOUT_MS;
		++it;
	}
}
void Sender::checkStatusLiveness() {
	if (!has_status_)
		return;
	const uint32_t now = now_ms();
	if ((uint32_t)(now - last_status_ms_) > cfg::STATUS_DEAD_MS) {
		if (!status_stale_) {
			status_stale_ = true;
			MC_LOGW("status", "STATUS stale (> " +
								  std::to_string(cfg::STATUS_DEAD_MS) + " ms)");
		}
	}
}
uint16_t Sender::nextSeq() {
	const uint16_t s = seq_;
	seq_ = (uint16_t)(seq_ + 1);
	return s;
}
----------------------------------------

----------------------------------------
File: rpi/src/LidarReceiver.cpp
----------------------------------------
#include "LidarReceiver.h"
#include "mc/core/Log.hpp"
#include "config/Config.h"
#include "sl_lidar.h"
#include "sl_lidar_driver.h"
#include <array>
#include <cerrno>
#include <cmath>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <string>
#include <unistd.h>
namespace {
float normalize(double angle) {
	double a =
		fmod(angle + cfg::LIDAR_ANGLE_WRAP_DEG, cfg::LIDAR_ANGLE_FULL_DEG);
	if (a < 0)
		a += cfg::LIDAR_ANGLE_FULL_DEG;
	return static_cast< float >(a - cfg::LIDAR_ANGLE_WRAP_DEG);
}
} 
LidarReceiver::LidarReceiver(const char *lidar_dev_c, int lidar_baud)
	: _channel(nullptr), _lidar(nullptr), _isReceiving(false) {
	_init(lidar_dev_c, lidar_baud);
}
LidarReceiver::~LidarReceiver() {
	stopReceivingThread();
	if (_lidar) {
		_lidar->stop();
		_lidar->setMotorSpeed(0);
		_lidar->disconnect();
	}
	delete _channel;
	delete _lidar;
}
std::vector< LidarData > LidarReceiver::_receiveOnce() {
	sl_lidar_response_measurement_node_hq_t nodes[cfg::LIDAR_NODE_MAX];
	size_t nodeCount = sizeof(nodes) / sizeof(nodes[0]);
	sl_result ans = _lidar->grabScanDataHq(nodes, nodeCount);
	if (!SL_IS_OK(ans) || nodeCount == 0) {
		return {};
	}
	ans = _lidar->ascendScanData(nodes, nodeCount);
	if (!SL_IS_OK(ans)) {
		return {};
	}
	std::vector< LidarData > res;
	res.reserve(nodeCount);
	for (size_t i = 0; i < nodeCount; i++) {
		if (nodes[i].dist_mm_q2 == 0)
			continue;
		float angle = (static_cast< float >(nodes[i].angle_z_q14) *
					   cfg::LIDAR_ANGLE_Q14_SCALE_DEG) /
					  cfg::LIDAR_ANGLE_Q14_DENOM;
		angle = normalize(angle);
		unsigned int dist =
			static_cast< unsigned int >(nodes[i].dist_mm_q2 >> 2);
		if (dist < cfg::LIDAR_DIST_MIN_MM)
			continue;
		res.emplace_back(dist, angle);
	}
	return res;
}
std::vector< LidarData > LidarReceiver::receive() { return _receiveOnce(); }
void LidarReceiver::startReceivingThread() {
	if (_isReceiving) {
		if (_receivingThread.joinable()) {
			return;
		}
		_isReceiving = false;
	}
	if (_receivingThread.joinable()) {
		_receivingThread.join();
	}
	_isReceiving = true;
	_receivingThread = std::thread(&LidarReceiver::_receivingThreadLoop, this);
	MC_LOGI("lidar", "receiving thread started");
}
void LidarReceiver::stopReceivingThread() {
	if (!_isReceiving)
		return;
	_isReceiving = false;
	if (_receivingThread.joinable()) {
		_receivingThread.join();
	}
	MC_LOGI("lidar", "receiving thread stopped");
}
bool LidarReceiver::getLatestData(std::vector< LidarData > &out) {
	std::lock_guard< std::mutex > lock(_dataMutex);
	if (_dataQueue.empty())
		return false;
	out = _dataQueue.front();
	_dataQueue.pop();
	return true;
}
void LidarReceiver::_receivingThreadLoop() {
	while (_isReceiving) {
		std::vector< LidarData > data = _receiveOnce();
		if (!data.empty()) {
			{
				std::lock_guard< std::mutex > lock(_dataMutex);
				if (!_dataQueue.empty()) {
					_dataQueue.pop();
				}
				_dataQueue.push(data);
			}
			_dataCV.notify_one();
		}
	}
}
void LidarReceiver::_init(const char *lidar_dev_c, int lidar_baud) {
	auto channelRes =
		sl::createSerialPortChannel(std::string(lidar_dev_c), lidar_baud);
	if (!channelRes) {
		MC_LOGF("lidar", std::string("Failed to create serial channel (") +
							 lidar_dev_c + ", " + std::to_string(lidar_baud) +
							 ")");
		exit(1);
	}
	_channel = channelRes.value;
	auto lidarRes = sl::createLidarDriver();
	if (!lidarRes) {
		MC_LOGF("lidar", "Failed to create lidar driver");
		exit(1);
	}
	_lidar = lidarRes.value;
	sl_result res = _lidar->connect(_channel);
	if (!SL_IS_OK(res)) {
		MC_LOGF("lidar", "Failed to connect to LIDAR: " +
							 std::to_string((unsigned int)res));
		exit(1);
	}
	sl_lidar_response_device_info_t devinfo;
	res = _lidar->getDeviceInfo(devinfo);
	if (!SL_IS_OK(res)) {
		MC_LOGF("lidar",
				"getDeviceInfo failed: " + std::to_string((unsigned int)res));
		exit(1);
	}
	sl_lidar_response_device_health_t health;
	res = _lidar->getHealth(health);
	if (!SL_IS_OK(res) || health.status == SL_LIDAR_STATUS_ERROR) {
		MC_LOGF("lidar", "getHealth failed or unhealthy: " +
							 std::to_string((unsigned int)res) + " status=" +
							 std::to_string((unsigned int)health.status));
		exit(1);
	}
	res = _lidar->setMotorSpeed();
	if (!SL_IS_OK(res)) {
		MC_LOGF("lidar",
				"setMotorSpeed failed: " + std::to_string((unsigned int)res));
		exit(1);
	}
	sl::LidarScanMode scanMode;
	res = _lidar->startScan(false, true, 0, &scanMode);
	MC_LOGI("lidar", "startScan result=" + std::to_string((unsigned int)res) +
						 " mode=" + std::string(scanMode.scan_mode));
	if (!SL_IS_OK(res)) {
		MC_LOGF("lidar",
				"startScan failed: " + std::to_string((unsigned int)res));
		exit(1);
	}
}
----------------------------------------

----------------------------------------
File: rpi/src/Process.cpp
----------------------------------------
#include "Process.h"
#include "config/Config.h"
#include "mc/core/Time.hpp"
#include <algorithm>
#include <array>
#include <cmath>
#include <optional>
#include <vector>
namespace {
struct CandidateScore {
	float angle_deg{};
	int distance_mm{};
	float score{};
};
} 
Process::Process(TelemetryEmitter *telemetry) : telemetry_(telemetry) {}
Process::~Process() {}
ProcResult Process::proc(const std::vector< LidarData > &lidarData,
						 float lastSteerAngle, uint64_t tick, uint64_t scan_id,
						 const std::string &run_id) const {
	const uint64_t t0_us = mc::core::Time::us();
	float max = 0;
	int maxDistance = -1;
	float minHandleAngle = 0;
	int minHandleDistance = INT32_MAX;
	int minObstacleOnPath = INT32_MAX;
	std::vector< CandidateScore > candidates;
	std::array< float, TELEMETRY_HEAT_BINS > heat_bins{};
	std::array< int, TELEMETRY_COMPASS_BINS > lidar_bins{};
	lidar_bins.fill(-1);
	bool lidar_bins_valid = false;
	for (auto &v : heat_bins)
		v = 0.0f;
	float clampedSteerAngle = lastSteerAngle;
	if (clampedSteerAngle > cfg::STEER_ANGLE_MAX_DEG) {
		clampedSteerAngle = cfg::STEER_ANGLE_MAX_DEG;
	} else if (clampedSteerAngle < -cfg::STEER_ANGLE_MAX_DEG) {
		clampedSteerAngle = -cfg::STEER_ANGLE_MAX_DEG;
	}
	float pathCheckMin = clampedSteerAngle - cfg::PROCESS_STEER_WINDOW_HALF_DEG;
	float pathCheckMax = clampedSteerAngle + cfg::PROCESS_STEER_WINDOW_HALF_DEG;
	for (const auto &i : lidarData) {
		if (cfg::PROCESS_HANDLE_ANGLE_MIN_DEG <= i.angle &&
			i.angle <= cfg::PROCESS_HANDLE_ANGLE_MAX_DEG) {
			const float ratio = (i.angle - cfg::PROCESS_HANDLE_ANGLE_MIN_DEG) /
								(cfg::PROCESS_HANDLE_ANGLE_MAX_DEG -
								 cfg::PROCESS_HANDLE_ANGLE_MIN_DEG);
			int idx =
				(int)std::lround(ratio * (float)(TELEMETRY_COMPASS_BINS - 1));
			if (idx < 0)
				idx = 0;
			if (idx >= (int)TELEMETRY_COMPASS_BINS)
				idx = (int)TELEMETRY_COMPASS_BINS - 1;
			if (lidar_bins[idx] < 0 || i.distance < lidar_bins[idx]) {
				lidar_bins[idx] = i.distance;
			}
			lidar_bins_valid = true;
			candidates.push_back(CandidateScore{.angle_deg = i.angle,
												.distance_mm = i.distance,
												.score = 0.0f});
			if (maxDistance < i.distance) {
				max = i.angle;
				maxDistance = i.distance;
			}
			if (i.distance < minHandleDistance) {
				minHandleAngle = i.angle;
				minHandleDistance = i.distance;
			}
		}
		if (pathCheckMin <= i.angle && i.angle <= pathCheckMax) {
			if (i.distance < minObstacleOnPath) {
				minObstacleOnPath = i.distance;
			}
		}
	}
	if (maxDistance < 0) {
		const uint64_t ts_us = mc::core::Time::us();
		if (telemetry_)
			telemetry_->emitNoLidar(ts_us, run_id, tick, scan_id);
		return ProcResult(0, 0);
	}
	for (auto &c : candidates) {
		c.score = (maxDistance > 0) ? (float)c.distance_mm / (float)maxDistance
									: 0.0f;
		const float step = 180.0f / (float)(TELEMETRY_HEAT_BINS - 1);
		int idx = (int)std::round((c.angle_deg + 90.0f) / step);
		if (idx < 0)
			idx = 0;
		if (idx >= (int)TELEMETRY_HEAT_BINS)
			idx = (int)TELEMETRY_HEAT_BINS - 1;
		if (c.score > heat_bins[(size_t)idx])
			heat_bins[(size_t)idx] = c.score;
	}
	int baseSpeed = maxDistance / cfg::PROCESS_SPEED_DIV;
	baseSpeed = (baseSpeed > cfg::PROCESS_MAX_SPEED) ? cfg::PROCESS_MAX_SPEED
													 : baseSpeed;
	float steerSourceAngle =
		(minHandleDistance == INT32_MAX) ? 0.0f : minHandleAngle;
	if (minHandleDistance != INT32_MAX) {
		float angleDiff = std::abs(steerSourceAngle - clampedSteerAngle);
		float directionWeight =
			1.0f - (angleDiff / 90.0f) * cfg::PROCESS_DIRECTION_WEIGHT;
		steerSourceAngle = steerSourceAngle * (1.0f - directionWeight) +
						   clampedSteerAngle * directionWeight;
	}
	float calculatedAngle = steerSourceAngle * cfg::PROCESS_MIN_ANGLE_SIGN *
							cfg::PROCESS_STEER_GAIN;
	float absAngle = std::fabs(calculatedAngle);
	float curve_ratio = 1.0f;
	int limitedSpeed = baseSpeed;
	std::string override_reason = "NONE";
	if (minObstacleOnPath <= cfg::PROCESS_MIN_DIST_STOP_MM) {
		limitedSpeed = 0;
		override_reason = "STOP";
	} else if (minObstacleOnPath < cfg::PROCESS_MIN_DIST_SAFE_MM) {
		limitedSpeed = (int)(baseSpeed * cfg::PROCESS_MIN_DIST_SPEED_FACTOR);
		override_reason = "SLOW";
	}
	if (absAngle > cfg::STEER_ANGLE_MAX_DEG) {
		curve_ratio = (float)cfg::STEER_ANGLE_MAX_DEG / absAngle;
		float curveFactor = cfg::STEER_CURVE_SPEED_FACTOR * curve_ratio;
		int curveReducedSpeed = (int)(limitedSpeed * curveFactor);
		limitedSpeed = curveReducedSpeed;
		if (override_reason == "NONE") {
			override_reason = "CURVE";
		} else {
			override_reason += "+CURVE";
		}
	}
	int roundedAngle = static_cast< int >(std::round(calculatedAngle));
	const float speed_factor =
		(baseSpeed > 0) ? (float)limitedSpeed / (float)baseSpeed : 0.0f;
	std::partial_sort(
		candidates.begin(),
		candidates.begin() + std::min< size_t >(3, candidates.size()),
		candidates.end(), [](const CandidateScore &a, const CandidateScore &b) {
			return a.score > b.score;
		});
	if (telemetry_) {
		static bool has_last_best = false;
		static float last_best_angle = 0.0f;
		std::optional< float > best_delta;
		if (has_last_best) {
			best_delta = max - last_best_angle;
		}
		last_best_angle = max;
		has_last_best = true;
		const bool include_candidates =
			(override_reason != "NONE") ||
			(best_delta &&
			 std::fabs(*best_delta) >= cfg::TELEMETRY_CANDIDATE_EVENT_DEG);
		std::string override_detail = override_reason;
		if (override_reason == "STOP") {
			override_detail =
				"STOP<=" + std::to_string(cfg::PROCESS_MIN_DIST_STOP_MM) + "mm";
		} else if (override_reason == "SLOW") {
			override_detail =
				"SLOW<" + std::to_string(cfg::PROCESS_MIN_DIST_SAFE_MM) + "mm";
		}
		if (override_reason.find("CURVE") != std::string::npos) {
			override_detail += " curve_ratio=" + std::to_string(curve_ratio);
		}
		TelemetrySample sample;
		sample.ts_us = mc::core::Time::us();
		sample.run_id = run_id;
		sample.tick = tick;
		sample.scan_id = scan_id;
		sample.best_delta_deg = best_delta;
		sample.include_candidates = include_candidates;
		sample.best_angle_deg = max;
		sample.best_dist_mm = maxDistance;
		sample.best_score = 1.0f;
		sample.score_obstacle = std::nullopt;
		sample.score_width = std::nullopt;
		sample.score_goal = std::nullopt;
		sample.score_curvature = std::nullopt;
		sample.score_stability = std::nullopt;
		sample.score_map_conf = std::nullopt;
		sample.min_handle_angle_deg = minHandleAngle;
		sample.min_handle_dist_mm = minHandleDistance;
		sample.path_obst_mm = minObstacleOnPath;
		sample.front_dist_mm = std::nullopt;
		sample.side_dist_mm = std::nullopt;
		sample.base_speed = baseSpeed;
		sample.limited_speed = limitedSpeed;
		sample.steer_deg = roundedAngle;
		sample.raw_steer_deg = calculatedAngle;
		sample.curve_ratio = curve_ratio;
		sample.speed_factor = speed_factor;
		sample.steer_clamp_deg = cfg::STEER_ANGLE_MAX_DEG;
		sample.override_kind = override_reason;
		sample.override_detail = override_detail;
		sample.th_stop_mm = cfg::PROCESS_MIN_DIST_STOP_MM;
		sample.th_safe_mm = cfg::PROCESS_MIN_DIST_SAFE_MM;
		sample.scan_age_ms = std::nullopt;
		const uint64_t t1_us = mc::core::Time::us();
		sample.planner_latency_ms = (uint32_t)((t1_us - t0_us) / 1000);
		sample.control_latency_ms = std::nullopt;
		sample.ttl_ms = cfg::AUTO_TTL_MS;
		sample.lidar_points = lidarData.size();
		sample.lidar_expected = 181;
		sample.heat_bins = heat_bins;
		sample.lidar_dist_bins = lidar_bins;
		sample.lidar_dist_valid = lidar_bins_valid;
		const size_t top_n = std::min< size_t >(3, candidates.size());
		sample.top_count = top_n;
		for (size_t i = 0; i < top_n; ++i) {
			sample.top[i] = {candidates[i].angle_deg, candidates[i].distance_mm,
							 candidates[i].score};
		}
		if (include_candidates) {
			sample.candidates.clear();
			sample.candidates.reserve(candidates.size());
			for (const auto &c : candidates) {
				sample.candidates.push_back(
					{c.angle_deg, c.distance_mm, c.score});
			}
		}
		telemetry_->emit(sample);
	}
	return ProcResult(limitedSpeed, roundedAngle);
}
----------------------------------------

----------------------------------------
File: rpi/src/CMakeLists.txt
----------------------------------------
file(GLOB RPI_SRCS CONFIGURE_DEPENDS
  "*.cpp"
)

set(ROBO_RACER_NAME "robo-racer" CACHE STRING "Output binary name")
add_executable(${ROBO_RACER_NAME} ${RPI_SRCS})

target_include_directories(${ROBO_RACER_NAME} SYSTEM PRIVATE
  ${CMAKE_CURRENT_SOURCE_DIR}/../lib/rplidar_sdk/sdk/include
  ${CMAKE_CURRENT_SOURCE_DIR}/../lib/rplidar_sdk/sdk/src
)
target_include_directories(${ROBO_RACER_NAME} PRIVATE
  ${CMAKE_CURRENT_SOURCE_DIR}
  ${CMAKE_CURRENT_SOURCE_DIR}/../lib/mc_core/include
  ${CMAKE_CURRENT_SOURCE_DIR}/../../shared/proto/include
  ${CMAKE_CURRENT_SOURCE_DIR}/../../shared/proto
  ${CMAKE_CURRENT_SOURCE_DIR}/../lib/mc_ipc/include
)

target_compile_options(${ROBO_RACER_NAME} PRIVATE -Wall -Wextra -Wpedantic
  -Wno-zero-length-array)

set(RPLIDAR_LIB_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../lib/rplidar_sdk/output/${CMAKE_SYSTEM_NAME}/Release")
find_library(RPLIDAR_LIB sl_lidar_sdk PATHS ${RPLIDAR_LIB_DIR})
if (RPLIDAR_LIB)
  target_link_libraries(${ROBO_RACER_NAME} PRIVATE ${RPLIDAR_LIB})
endif()

target_link_libraries(${ROBO_RACER_NAME} PRIVATE mc_proto mc_ipc dl m)

set_target_properties(${ROBO_RACER_NAME} PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../.."
)
----------------------------------------

----------------------------------------
File: rpi/src/LidarReceiver.h
----------------------------------------
#pragma once
#include "sl_lidar.h"
#include "sl_lidar_driver.h"
#include <condition_variable>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>
struct LidarData {
	int distance;
	float angle;
	LidarData(int distance, float angle) : distance(distance), angle(angle) {}
};
class LidarReceiver {
public:
	LidarReceiver(const char *lidar_dev_c, int lidar_baud);
	~LidarReceiver();
	std::vector< LidarData > receive();
	void startReceivingThread();
	void stopReceivingThread();
	bool getLatestData(std::vector< LidarData > &out);
protected:
	void _receivingThreadLoop();
	sl::IChannel *_channel;
	sl::ILidarDriver *_lidar;
	std::thread _receivingThread;
	std::mutex _dataMutex;
	std::condition_variable _dataCV;
	std::queue< std::vector< LidarData > > _dataQueue;
	bool _isReceiving;
	std::vector< LidarData > _receiveOnce();
private:
	void _init(const char *lidar_dev_c, int lidar_baud);
};
----------------------------------------

----------------------------------------
File: rpi/src/config/Config.h
----------------------------------------
#pragma once
#include <cstddef>
#include <stdint.h>
namespace cfg {
static constexpr const char* DEFAULT_LIDAR_DEVICE = "/dev/ttyAMA2";
static constexpr const char* DEFAULT_ESP_DEVICE   = "/dev/ttyAMA0";
static constexpr const char* DEFAULT_SERIALD_SOCK = "/tmp/roboracer/seriald.sock";
static constexpr const char* DEFAULT_PROCESS_LOG  = "./logs/process_telemetry.jsonl";
static constexpr const char* DEFAULT_METRICSD_LOG = "./logs/metricsd.log";
static constexpr int DEFAULT_LIDAR_BAUD = 460800;
static constexpr int DEFAULT_ESP_BAUD   = 921600;
static constexpr uint16_t AUTO_TTL_MS            = 100;
static constexpr uint32_t HEARTBEAT_INTERVAL_MS  = 50;
static constexpr uint32_t STATUS_LOG_INTERVAL_MS = 1000;
static constexpr uint32_t ACK_TIMEOUT_MS         = 50;
static constexpr uint8_t ACK_MAX_RETRY           = 3;
static constexpr uint32_t STATUS_DEAD_MS         = 300;
static constexpr int SPEED_INPUT_LIMIT           = 255;
static constexpr int SPEED_MM_S_MAX              = 2000;
static constexpr int STEER_CDEG_SCALE            = 100;
static constexpr int STEER_CDEG_MAX              = 3000;
static constexpr size_t UART_READ_BUF_SIZE       = 256;
static constexpr size_t LIDAR_NODE_MAX           = 8192;
static constexpr float LIDAR_ANGLE_Q14_SCALE_DEG = 90.0f;
static constexpr float LIDAR_ANGLE_Q14_DENOM     = 16384.0f;
static constexpr float LIDAR_ANGLE_WRAP_DEG      = 180.0f;
static constexpr float LIDAR_ANGLE_FULL_DEG      = 360.0f;
static constexpr unsigned int LIDAR_DIST_MIN_MM  = 5;
static constexpr float PROCESS_HANDLE_ANGLE_MIN_DEG = -90.0f; 
static constexpr float PROCESS_HANDLE_ANGLE_MAX_DEG = 90.0f;
static constexpr float PROCESS_SLOW_ANGLE_MIN_DEG   = -70.0f; 
static constexpr float PROCESS_SLOW_ANGLE_MAX_DEG   = 70.0f;
static constexpr int PROCESS_SPEED_DIV           = 50;
static constexpr int PROCESS_MAX_SPEED           = 100;  
static constexpr float PROCESS_MIN_ANGLE_SIGN    = -1.0f;
static constexpr float PROCESS_STEER_GAIN        = 1.2f;
static constexpr int PROCESS_MIN_DIST_SAFE_MM    = 400;   
static constexpr int PROCESS_MIN_DIST_STOP_MM    = 150;   
static constexpr float PROCESS_MIN_DIST_SPEED_FACTOR = 0.5f; 
static constexpr int STEER_ANGLE_MAX_DEG         = 30;    
static constexpr float STEER_CURVE_SPEED_FACTOR  = 0.7f;  
static constexpr float PROCESS_STEER_WINDOW_HALF_DEG = 25.0f;  
static constexpr float PROCESS_DIRECTION_WEIGHT = 0.5f;  
static constexpr double TELEMETRY_DEFAULT_HZ = 10.0;
static constexpr float TELEMETRY_CANDIDATE_EVENT_DEG = 10.0f;
static constexpr uint16_t TELEMETRY_CPU_WARN_PERMILLE = 800;
static constexpr uint16_t TELEMETRY_CPU_CRIT_PERMILLE = 950;
static constexpr uint16_t TELEMETRY_TEMP_WARN_CDEG = 7000;
static constexpr uint16_t TELEMETRY_TEMP_CRIT_CDEG = 8000;
static constexpr int TELEMETRY_DIST_BAR_MAX_MM = 12000;
static constexpr size_t TELEMETRY_BAR_WIDTH = 12;
static constexpr size_t TELEMETRY_SPARK_LEN = 20;
static constexpr size_t TELEMETRY_COMPASS_ROWS = 6;
static constexpr size_t TELEMETRY_COMPASS_MIN_WIDTH = 21;
static constexpr int TELEMETRY_NEAR_EMPH_MM = 1000;
static constexpr uint32_t TELEMETRY_SCAN_AGE_WARN_MS = 100;
static constexpr uint32_t TELEMETRY_SCAN_AGE_CRIT_MS = 200;
static constexpr float TELEMETRY_BEST_JUMP_DEG = 15.0f;
static constexpr float TELEMETRY_SLOWDOWN_SF = 0.5f;
static constexpr uint32_t TELEMETRY_LATENCY_WARN_MS = 20;
static constexpr uint32_t TELEMETRY_LATENCY_CRIT_MS = 50;
static constexpr float TELEMETRY_TTL_WARN_FACTOR = 1.0f;
static constexpr float TELEMETRY_TTL_CRIT_FACTOR = 2.0f;
} 
----------------------------------------

----------------------------------------
File: rpi/src/ShmLidarReceiver.cpp
----------------------------------------
#include "ShmLidarReceiver.h"
#include "config/Config.h"
#include <array>
#include <cerrno>
#include <cstring>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
namespace {
static constexpr const char *kShmName = "/lidar_scan";
static constexpr const char *kSemName = "/lidar_scan_sem";
static constexpr uint32_t kSeqNoUpdate = 0;
} 
ShmLidarReceiver::ShmLidarReceiver()
	: _shmFd(-1), _shm(nullptr), _sem(SEM_FAILED), _lastSeq(0),
	  _connected(false) {}
ShmLidarReceiver::~ShmLidarReceiver() { cleanup(); }
bool ShmLidarReceiver::connect() {
	if (_connected)
		return true;
	_shmFd = shm_open(kShmName, O_RDONLY, 0);
	if (_shmFd < 0) {
		cleanup();
		return false;
	}
	void *p =
		mmap(NULL, sizeof(ShmLidarScanData), PROT_READ, MAP_SHARED, _shmFd, 0);
	if (p == MAP_FAILED) {
		cleanup();
		return false;
	}
	_shm = static_cast< ShmLidarScanData * >(p);
	_sem = sem_open(kSemName, 0);
	if (_sem == SEM_FAILED) {
		cleanup();
		return false;
	}
	_lastSeq = 0;
	_connected = true;
	return true;
}
bool ShmLidarReceiver::isConnected() const { return _connected; }
bool ShmLidarReceiver::getLatestData(std::vector< LidarData > &out) {
	if (!_connected)
		return false;
	if (sem_trywait(_sem) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return false;
		return false;
	}
	uint32_t seq = _shm->seq;
	if (seq == kSeqNoUpdate || seq == _lastSeq) {
		sem_post(_sem);
		return false;
	}
	std::array< int32_t, 181 > distances;
	for (size_t i = 0; i < distances.size(); ++i)
		distances[i] = _shm->distance_mm[i];
	sem_post(_sem);
	_lastSeq = seq;
	out.clear();
	out.reserve(distances.size());
	for (int angle = -90; angle <= 90; ++angle) {
		int32_t dist = distances[static_cast< size_t >(angle + 90)];
		if (dist < static_cast< int32_t >(cfg::LIDAR_DIST_MIN_MM))
			continue;
		out.emplace_back(dist, static_cast< float >(angle));
	}
	return !out.empty();
}
void ShmLidarReceiver::cleanup() {
	if (_sem != SEM_FAILED) {
		sem_close(_sem);
		_sem = SEM_FAILED;
	}
	if (_shm && _shm != MAP_FAILED) {
		munmap(_shm, sizeof(ShmLidarScanData));
		_shm = nullptr;
	}
	if (_shmFd >= 0) {
		close(_shmFd);
		_shmFd = -1;
	}
	_connected = false;
}
----------------------------------------

----------------------------------------
File: rpi/src/ShmLidarReceiver.h
----------------------------------------
#pragma once
#include "LidarReceiver.h"
#include <cstdint>
#include <semaphore.h>
#include <vector>
struct ShmLidarScanData {
	uint32_t seq;
	int32_t distance_mm[181];
};
class ShmLidarReceiver {
public:
	ShmLidarReceiver();
	~ShmLidarReceiver();
	bool connect();
	bool isConnected() const;
	bool getLatestData(std::vector< LidarData > &out);
private:
	void cleanup();
	int _shmFd;
	ShmLidarScanData *_shm;
	sem_t *_sem;
	uint32_t _lastSeq;
	bool _connected;
};
----------------------------------------

----------------------------------------
File: rpi/src/Sender.h
----------------------------------------
#pragma once
#include "config/Config.h"
#include <array>
#include <mc/ipc/UdsSeqPacket.hpp>
#include <mc/proto/Proto.hpp>
#include <stdint.h>
#include <unordered_map>
class TelemetryEmitter;
class Sender {
public:
	explicit Sender(const char* sock_path, TelemetryEmitter* telemetry = nullptr);
	~Sender();
	void send(int speed, int angle);
	void sendAutoMode(bool enable);
	void sendKill();
	void poll();
private:
	void _init(const char* sock_path);
	void sendHeartbeatIfDue();
	void handleFrame(const mc::proto::Frame& frame);
	void handleStatus(const mc::proto::StatusPayload& payload);
	void handleAck(uint16_t seq);
	void trackPending(uint16_t seq, const uint8_t* data, uint16_t len);
	void checkPending();
	void checkStatusLiveness();
	uint16_t nextSeq();
	mc::ipc::UdsClient ipc_;
	uint16_t seq_ = 0;
	uint32_t last_status_log_ms_ = 0;
	uint32_t last_status_ms_ = 0;
	uint32_t last_hb_ms_ = 0;
	mc::proto::StatusPayload last_status_{};
	bool has_status_ = false;
	bool status_stale_ = false;
	bool auto_enabled_ = false;
	TelemetryEmitter* telemetry_ = nullptr;
	struct PendingTx {
		uint32_t deadline_ms;
		uint8_t retries;
		uint16_t len;
		std::array< uint8_t, mc::proto::MAX_FRAME_ENCODED > data;
	};
	std::unordered_map< uint16_t, PendingTx > pending_;
};
----------------------------------------

----------------------------------------
File: rpi/src/lidar_to_esp.h
----------------------------------------
#pragma once
int run_lidar_to_esp(const char* lidar_dev, int lidar_baud, const char* esp_dev);
----------------------------------------

----------------------------------------
File: rpi/src/Process.h
----------------------------------------
#pragma once
#include "LidarReceiver.h"
#include "Telemetry.h"
#include <cstdint>
#include <string>
#include <vector>
struct ProcResult {
	int speed;
	int angle;
	ProcResult(int speed, int angle) : speed(speed), angle(angle) {}
};
class Process {
public:
	explicit Process(TelemetryEmitter *telemetry);
	~Process();
	ProcResult proc(const std::vector< LidarData > &lidarData,
					float lastSteerAngle,
					uint64_t tick,
					uint64_t scan_id,
					const std::string &run_id) const;
private:
	TelemetryEmitter *telemetry_;
};
----------------------------------------

----------------------------------------
File: rpi/src/Telemetry.cpp
----------------------------------------
#include "Telemetry.h"
#include "config/Config.h"
#include "mc/core/Log.hpp"
#include "mc/core/Time.hpp"
#include <algorithm>
#include <cctype>
#include <chrono>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
namespace {
std::string colorOverride(const std::string &ovr) {
	if (ovr == "NONE")
		return "\x1b[32mNONE\x1b[0m";
	if (ovr == "STOP")
		return "\x1b[31mSTOP\x1b[0m";
	return "\x1b[33m" + ovr + "\x1b[0m";
}
size_t visibleLen(const std::string &s) {
	size_t len = 0;
	for (size_t i = 0; i < s.size(); ++i) {
		if (s[i] == '\x1b' && i + 1 < s.size() && s[i + 1] == '[') {
			i += 2;
			while (i < s.size() && s[i] != 'm')
				++i;
			continue;
		}
		++len;
	}
	return len;
}
std::string trimVisible(const std::string &s, size_t max_vis) {
	size_t vis = 0;
	std::string out;
	out.reserve(s.size());
	for (size_t i = 0; i < s.size(); ++i) {
		if (s[i] == '\x1b' && i + 1 < s.size() && s[i + 1] == '[') {
			out.push_back(s[i++]);
			out.push_back(s[i++]);
			while (i < s.size()) {
				out.push_back(s[i]);
				if (s[i] == 'm')
					break;
				++i;
			}
			continue;
		}
		if (vis >= max_vis)
			break;
		out.push_back(s[i]);
		++vis;
	}
	return out;
}
std::string fitVisible(const std::string &s, size_t width) {
	std::string out = trimVisible(s, width);
	const size_t vis = visibleLen(out);
	if (vis < width)
		out += std::string(width - vis, ' ');
	return out;
}
std::string colorWrap(const std::string &s, Severity sev) {
	switch (sev) {
	case Severity::Safe:
		return "\x1b[32m" + s + "\x1b[0m";
	case Severity::Warn:
		return "\x1b[33m" + s + "\x1b[0m";
	case Severity::Crit:
		return "\x1b[31m" + s + "\x1b[0m";
	}
	return s;
}
std::string bar(float ratio, size_t width) {
	if (ratio < 0.0f)
		ratio = 0.0f;
	if (ratio > 1.0f)
		ratio = 1.0f;
	const size_t fill = (size_t)std::round(ratio * (float)width);
	return "[" + std::string(fill, '#') + std::string(width - fill, '-') + "]";
}
std::string sparkline(const std::vector< float > &vals, float min_v,
					  float max_v, size_t width) {
	static const char *k = " .:-=+*#@";
	const size_t levels = 8;
	std::string out;
	out.reserve(width);
	if (vals.empty()) {
		out.assign(width, ' ');
		return out;
	}
	const float denom = (max_v - min_v);
	const size_t start = (vals.size() > width) ? (vals.size() - width) : 0;
	const size_t pad = (vals.size() < width) ? (width - vals.size()) : 0;
	out.assign(pad, ' ');
	for (size_t i = start; i < vals.size(); ++i) {
		float v = vals[i];
		float n = (denom <= 0.0f) ? 0.5f : (v - min_v) / denom;
		if (n < 0.0f)
			n = 0.0f;
		if (n > 1.0f)
			n = 1.0f;
		const size_t idx = (size_t)std::round(n * (float)levels);
		out.push_back(k[idx]);
	}
	return out;
}
} 
TelemetryEmitter::TelemetryEmitter() {
	running_.store(true);
	metrics_thread_ = std::thread(&TelemetryEmitter::metricsLoop_, this);
}
TelemetryEmitter::~TelemetryEmitter() {
	running_.store(false);
	if (metrics_thread_.joinable())
		metrics_thread_.join();
	shutdownUi();
}
void TelemetryEmitter::setRateHz(double hz) {
	if (hz <= 0.0) {
		telemetry_interval_us_ = 0;
		return;
	}
	telemetry_interval_us_ = (uint64_t)(1000000.0 / hz);
}
void TelemetryEmitter::setMetricsLogPath(std::string path) {
	std::lock_guard< std::mutex > lk(metrics_mtx_);
	metrics_log_path_ = std::move(path);
}
void TelemetryEmitter::emit(const TelemetrySample &s) {
	const uint64_t now_us = s.ts_us;
	emitOverrideEvent_(s);
	if (telemetry_interval_us_ == 0 ||
		now_us - last_telemetry_us_ >= telemetry_interval_us_) {
		emitJson_(s);
		last_telemetry_us_ = now_us;
	}
	if (ui_enabled_ && (telemetry_interval_us_ == 0 ||
						now_us - last_ui_us_ >= telemetry_interval_us_)) {
		emitUi_(s);
		last_ui_us_ = now_us;
	}
}
void TelemetryEmitter::emitNoLidar(uint64_t ts_us, const std::string &run_id,
								   uint64_t tick, uint64_t scan_id) {
	std::ostringstream json;
	json << "{\"t_us\":" << ts_us << ",\"type\":\"NO_LIDAR\""
		 << ",\"run_id\":\"" << run_id << "\",\"tick\":" << tick
		 << ",\"scan_id\":" << scan_id
		 << ",\"mode\":\"UNKNOWN\",\"cmd\":{\"v\":0,\"steer_deg\":0}}";
	MC_LOGW("event", json.str());
	pushEvent_("NO_LIDAR");
}
void TelemetryEmitter::shutdownUi() {
	if (!ui_initialized_)
		return;
	std::cout << "\x1b[?25h" << std::flush;
}
void TelemetryEmitter::refreshMetrics_() {
	std::string path;
	{
		std::lock_guard< std::mutex > lk(metrics_mtx_);
		path = metrics_log_path_;
	}
	if (path.empty())
		return;
	const uint64_t now_us = mc::core::Time::us();
	if (now_us - metrics_last_read_us_ < 1000 * 1000)
		return;
	metrics_last_read_us_ = now_us;
	std::ifstream ifs(path, std::ios::binary);
	if (!ifs.is_open())
		return;
	ifs.seekg(0, std::ios::end);
	const std::streamoff end_off = ifs.tellg();
	const std::streamoff back = 1024;
	std::streamoff start = end_off - back;
	if (start < 0)
		start = 0;
	ifs.seekg(start);
	std::string buf((size_t)(end_off - start), '\0');
	ifs.read(&buf[0], buf.size());
	size_t last_nl = buf.find_last_of('\n');
	if (last_nl == std::string::npos)
		return;
	size_t prev_nl = buf.find_last_of('\n', last_nl - 1);
	size_t line_start = (prev_nl == std::string::npos) ? 0 : prev_nl + 1;
	std::string line = buf.substr(line_start, last_nl - line_start);
	auto find_num = [&](const char *key, uint64_t &val) -> bool {
		const std::string k = std::string(key);
		const size_t pos = line.find(k);
		if (pos == std::string::npos)
			return false;
		size_t i = pos + k.size();
		size_t end = i;
		while (end < line.size() && std::isdigit(line[end]))
			++end;
		if (end == i)
			return false;
		val = std::stoull(line.substr(i, end - i));
		return true;
	};
	uint64_t temp = 0, cpu = 0, mem_used = 0, mem_total = 0;
	const bool ok = find_num("temp_cdeg=", temp) &&
					find_num("cpu_permille=", cpu) &&
					find_num("mem_kb=", mem_used);
	if (!ok)
		return;
	const size_t slash = line.find('/', line.find("mem_kb="));
	if (slash == std::string::npos)
		return;
	size_t end_pos = slash + 1;
	while (end_pos < line.size() && std::isdigit(line[end_pos]))
		++end_pos;
	if (end_pos == slash + 1)
		return;
	mem_total = std::stoull(line.substr(slash + 1, end_pos - slash - 1));
	{
		std::lock_guard< std::mutex > lk(metrics_mtx_);
		metrics_.valid = true;
		metrics_.cpu_temp_cdeg = (uint16_t)temp;
		metrics_.cpu_usage_permille = (uint16_t)cpu;
		metrics_.mem_used_kb = (uint32_t)mem_used;
		metrics_.mem_total_kb = (uint32_t)mem_total;
	}
}
void TelemetryEmitter::metricsLoop_() {
	using namespace std::chrono_literals;
	while (running_.load()) {
		refreshMetrics_();
		std::this_thread::sleep_for(1s);
	}
}
void TelemetryEmitter::pushEvent_(std::string e) {
	if (e.empty())
		return;
	events_.push_back(std::move(e));
	const size_t max_events = 5;
	if (events_.size() > max_events)
		events_.erase(events_.begin(),
					  events_.begin() + (events_.size() - max_events));
}
void TelemetryEmitter::emitJson_(const TelemetrySample &s) {
	std::ostringstream telemetry;
	telemetry << std::fixed << std::setprecision(2);
	telemetry << "{\"t_us\":" << s.ts_us << ",\"type\":\"telemetry\""
			  << ",\"run_id\":\"" << s.run_id << "\",\"tick\":" << s.tick
			  << ",\"scan_id\":" << s.scan_id << ",\"mode\":\"" << s.mode
			  << "\",\"map_state\":\"" << s.map_state << "\""
			  << ",\"best\":{\"ang_deg\":" << s.best_angle_deg
			  << ",\"dist_mm\":" << s.best_dist_mm
			  << ",\"score\":" << s.best_score << ",\"delta_deg\":"
			  << (s.best_delta_deg ? std::to_string(*s.best_delta_deg) : "null")
			  << ",\"terms\":{\"distance\":" << s.best_score;
	if (level_ == TelemetryLevel::Full) {
		telemetry
			<< ",\"obstacle\":"
			<< (s.score_obstacle ? std::to_string(*s.score_obstacle) : "null")
			<< ",\"width\":"
			<< (s.score_width ? std::to_string(*s.score_width) : "null")
			<< ",\"goal\":"
			<< (s.score_goal ? std::to_string(*s.score_goal) : "null")
			<< ",\"curvature\":"
			<< (s.score_curvature ? std::to_string(*s.score_curvature) : "null")
			<< ",\"stability\":"
			<< (s.score_stability ? std::to_string(*s.score_stability) : "null")
			<< ",\"map_conf\":"
			<< (s.score_map_conf ? std::to_string(*s.score_map_conf) : "null");
	}
	telemetry << "}}"
			  << ",\"min_handle\":{\"ang_deg\":" << s.min_handle_angle_deg
			  << ",\"dist_mm\":" << s.min_handle_dist_mm << "}"
			  << ",\"path_obst_mm\":" << s.path_obst_mm << ",\"front_dist_mm\":"
			  << (s.front_dist_mm ? std::to_string(*s.front_dist_mm) : "null")
			  << ",\"side_dist_mm\":"
			  << (s.side_dist_mm ? std::to_string(*s.side_dist_mm) : "null")
			  << ",\"cmd\":{\"v\":" << s.base_speed
			  << ",\"v_limited\":" << s.limited_speed
			  << ",\"steer_deg\":" << s.steer_deg
			  << ",\"raw_steer_deg\":" << s.raw_steer_deg
			  << ",\"curve_ratio\":" << s.curve_ratio
			  << ",\"speed_factor\":" << s.speed_factor << "}"
			  << ",\"limits\":{\"steer_clamp_deg\":" << s.steer_clamp_deg << "}"
			  << ",\"override\":{\"kind\":\"" << s.override_kind
			  << "\",\"detail\":\"" << s.override_detail << "\"}"
			  << ",\"scan_age_ms\":"
			  << (s.scan_age_ms ? std::to_string(*s.scan_age_ms) : "null")
			  << ",\"latency_ms\":{\"planner\":"
			  << (s.planner_latency_ms ? std::to_string(*s.planner_latency_ms)
									   : "null")
			  << ",\"control\":"
			  << (s.control_latency_ms ? std::to_string(*s.control_latency_ms)
									   : "null")
			  << "}"
			  << ",\"ttl_ms\":"
			  << (s.ttl_ms ? std::to_string(*s.ttl_ms) : "null")
			  << ",\"top\":[";
	for (size_t i = 0; i < s.top_count; ++i) {
		if (i > 0)
			telemetry << ",";
		telemetry << "{\"ang_deg\":" << s.top[i].angle_deg
				  << ",\"dist_mm\":" << s.top[i].distance_mm
				  << ",\"score\":" << s.top[i].score
				  << ",\"terms\":{\"distance\":" << s.top[i].score << "}}";
	}
	telemetry << "]";
	if (level_ == TelemetryLevel::Full && s.include_candidates) {
		telemetry << ",\"candidates\":[";
		for (size_t i = 0; i < s.candidates.size(); ++i) {
			if (i > 0)
				telemetry << ",";
			telemetry << "{\"ang_deg\":" << s.candidates[i].angle_deg
					  << ",\"dist_mm\":" << s.candidates[i].distance_mm
					  << ",\"score\":" << s.candidates[i].score
					  << ",\"terms\":{\"distance\":" << s.candidates[i].score
					  << "}}";
		}
		telemetry << "]";
	}
	if (status_.valid) {
		telemetry << ",\"esp_status\":{\"auto_active\":"
				  << (unsigned)status_.auto_active
				  << ",\"faults\":" << status_.faults
				  << ",\"speed_mm_s\":" << status_.speed_mm_s
				  << ",\"steer_cdeg\":" << status_.steer_cdeg
				  << ",\"age_ms\":" << status_.age_ms << "}";
	} else {
		telemetry << ",\"esp_status\":null";
	}
	telemetry << "}";
	MC_LOGI("telemetry", telemetry.str());
}
void TelemetryEmitter::emitOverrideEvent_(const TelemetrySample &s) {
	if (s.override_kind == last_override_)
		return;
	std::ostringstream event;
	event << "{\"t_us\":" << s.ts_us << ",\"type\":\"OVERRIDE\""
		  << ",\"run_id\":\"" << s.run_id << "\",\"tick\":" << s.tick
		  << ",\"scan_id\":" << s.scan_id << ",\"kind\":\"" << s.override_kind
		  << "\",\"detail\":\"" << s.override_detail
		  << "\",\"path_obst_mm\":" << s.path_obst_mm
		  << ",\"th_stop_mm\":" << s.th_stop_mm
		  << ",\"th_safe_mm\":" << s.th_safe_mm << "}";
	MC_LOGI("event", event.str());
	pushEvent_("OVERRIDE " + s.override_kind);
	last_override_ = s.override_kind;
}
void TelemetryEmitter::emitUi_(const TelemetrySample &s) {
	auto push_hist = [](std::vector< float > &h, float v) {
		h.push_back(v);
		if (h.size() > cfg::TELEMETRY_SPARK_LEN)
			h.erase(h.begin());
	};
	MetricsCache metrics;
	{
		std::lock_guard< std::mutex > lk(metrics_mtx_);
		metrics = metrics_;
	}
	int path_mm = s.path_obst_mm;
	if (path_mm < 0 || path_mm >= (std::numeric_limits< int >::max() / 2)) {
		path_mm = cfg::TELEMETRY_DIST_BAR_MAX_MM;
	}
	if (path_mm > cfg::TELEMETRY_DIST_BAR_MAX_MM)
		path_mm = cfg::TELEMETRY_DIST_BAR_MAX_MM;
	push_hist(spark_best_, s.best_angle_deg);
	push_hist(spark_speed_, (float)s.limited_speed);
	push_hist(spark_dist_, (float)path_mm);
	float best_std = 0.0f;
	if (spark_best_.size() >= 2) {
		float sum = 0.0f;
		for (float v : spark_best_)
			sum += v;
		const float mean = sum / (float)spark_best_.size();
		float var = 0.0f;
		for (float v : spark_best_) {
			const float d = v - mean;
			var += d * d;
		}
		var /= (float)spark_best_.size();
		best_std = std::sqrt(var);
	}
	float jerk = 0.0f;
	if (s.best_delta_deg) {
		if (has_last_delta_) {
			jerk = std::fabs(*s.best_delta_deg - last_delta_);
		}
		last_delta_ = *s.best_delta_deg;
		has_last_delta_ = true;
	}
	Severity cpu_sev = Severity::Safe;
	Severity temp_sev = Severity::Safe;
	if (metrics.valid) {
		if (metrics.cpu_usage_permille >= cfg::TELEMETRY_CPU_CRIT_PERMILLE)
			cpu_sev = Severity::Crit;
		else if (metrics.cpu_usage_permille >= cfg::TELEMETRY_CPU_WARN_PERMILLE)
			cpu_sev = Severity::Warn;
		if (metrics.cpu_temp_cdeg >= cfg::TELEMETRY_TEMP_CRIT_CDEG)
			temp_sev = Severity::Crit;
		else if (metrics.cpu_temp_cdeg >= cfg::TELEMETRY_TEMP_WARN_CDEG)
			temp_sev = Severity::Warn;
	}
	Severity dist_sev = Severity::Safe;
	if (s.path_obst_mm <= cfg::PROCESS_MIN_DIST_STOP_MM) {
		dist_sev = Severity::Crit;
	} else if (s.path_obst_mm < cfg::PROCESS_MIN_DIST_SAFE_MM) {
		dist_sev = Severity::Warn;
	}
	Severity map_sev = Severity::Safe;
	if (s.map_state == "INVALID" || s.map_state == "ERROR")
		map_sev = Severity::Crit;
	else if (s.map_state == "UNKNOWN" || s.map_state == "PARTIAL" ||
			 s.map_state == "BUILDING")
		map_sev = Severity::Warn;
	Severity loc_sev = Severity::Warn;
	if (s.scan_age_ms) {
		if (*s.scan_age_ms >= cfg::TELEMETRY_SCAN_AGE_CRIT_MS)
			loc_sev = Severity::Crit;
		else if (*s.scan_age_ms >= cfg::TELEMETRY_SCAN_AGE_WARN_MS)
			loc_sev = Severity::Warn;
		else
			loc_sev = Severity::Safe;
	}
	float sens_ratio = -1.0f;
	Severity sens_sev = Severity::Warn;
	if (s.lidar_points && s.lidar_expected && *s.lidar_expected > 0) {
		sens_ratio = (float)*s.lidar_points / (float)*s.lidar_expected;
		if (sens_ratio < 0.5f)
			sens_sev = Severity::Crit;
		else if (sens_ratio < 0.8f)
			sens_sev = Severity::Warn;
		else
			sens_sev = Severity::Safe;
	}
	Severity ctrl_sev = Severity::Safe;
	bool ttl_expired = false;
	if (status_.valid && s.ttl_ms) {
		const float ttl = (float)*s.ttl_ms;
		if ((float)status_.age_ms >= ttl * cfg::TELEMETRY_TTL_CRIT_FACTOR) {
			ctrl_sev = Severity::Crit;
			ttl_expired = true;
		} else if ((float)status_.age_ms >=
				   ttl * cfg::TELEMETRY_TTL_WARN_FACTOR) {
			ctrl_sev = Severity::Warn;
			ttl_expired = true;
		}
	}
	if (s.override_kind == "STOP")
		ctrl_sev = Severity::Crit;
	else if (s.override_kind != "NONE")
		ctrl_sev = std::max(ctrl_sev, Severity::Warn);
	if (status_.valid && status_.faults != 0)
		ctrl_sev = std::max(ctrl_sev, Severity::Warn);
	if (s.planner_latency_ms &&
		*s.planner_latency_ms >= cfg::TELEMETRY_LATENCY_CRIT_MS)
		ctrl_sev = std::max(ctrl_sev, Severity::Crit);
	else if (s.planner_latency_ms &&
			 *s.planner_latency_ms >= cfg::TELEMETRY_LATENCY_WARN_MS)
		ctrl_sev = std::max(ctrl_sev, Severity::Warn);
	std::ostringstream l0;
	l0 << "MAP " << colorWrap(s.map_state, map_sev) << " | MODE " << s.mode;
	if (s.scan_age_ms)
		l0 << " | scan_age " << *s.scan_age_ms << "ms";
	l0 << " | run "
	   << (s.run_id.size() >= 6 ? s.run_id.substr(s.run_id.size() - 6)
								: s.run_id)
	   << " | tick " << s.tick;
	std::ostringstream l1;
	l1 << "BADGES " << colorWrap("MAP", map_sev) << "/"
	   << colorWrap("LOC", loc_sev) << "/" << colorWrap("SENS", sens_sev) << "/"
	   << colorWrap("CTRL", ctrl_sev);
	l1 << " | d_best="
	   << (s.best_delta_deg ? std::to_string(*s.best_delta_deg) : "NA")
	   << "deg std=" << std::fixed << std::setprecision(1) << best_std
	   << " jerk=" << std::fixed << std::setprecision(1) << jerk;
	const double hz = (telemetry_interval_us_ > 0)
						  ? (1000000.0 / (double)telemetry_interval_us_)
						  : 0.0;
	l1 << " | lvl=" << (level_ == TelemetryLevel::Full ? "full" : "basic");
	if (hz > 0.0)
		l1 << " hz=" << std::fixed << std::setprecision(1) << hz;
	const size_t frame_width = 102;
	const size_t scale_w = TELEMETRY_COMPASS_BINS;
	const size_t compass_pad = 0;
	const std::string compass_left(compass_pad, ' ');
	auto posFromAngle = [&](float angle_deg) {
		float clamped = angle_deg;
		if (clamped < -90.0f)
			clamped = -90.0f;
		if (clamped > 90.0f)
			clamped = 90.0f;
		const float ratio = (clamped + 90.0f) / 180.0f;
		const int pos = (int)std::lround(ratio * (float)(scale_w - 1));
		return std::max(0, std::min((int)scale_w - 1, pos));
	};
	const int max_dist = cfg::TELEMETRY_DIST_BAR_MAX_MM;
	std::ostringstream comp_title;
	comp_title << "LIDAR HEATMAP (max " << std::fixed << std::setprecision(1)
			   << (max_dist / 1000.0f)
			   << "m, near<=" << cfg::TELEMETRY_NEAR_EMPH_MM
			   << "mm) B=best T=target A=applied";
	const std::string top_compass =
		compass_left + "+" + fitVisible(comp_title.str(), scale_w) + "+";
	std::vector< std::string > heat_rows;
	const size_t rows = cfg::TELEMETRY_COMPASS_ROWS;
	heat_rows.reserve(rows);
	std::vector< std::string > grid(rows,
									std::string(TELEMETRY_COMPASS_BINS, ' '));
	if (s.lidar_dist_valid && rows > 0) {
		static const char *levels = "@#*+=-:.";
		const size_t levels_len = 8;
		const float band = (rows > 0) ? (float)max_dist / (float)rows : 1.0f;
		for (size_t c = 0; c < TELEMETRY_COMPASS_BINS; ++c) {
			int dist = s.lidar_dist_bins[c];
			if (dist < 0 || dist >= max_dist)
				continue;
			const float ratio =
				(max_dist > 0) ? (float)dist / (float)max_dist : 1.0f;
			const size_t idx =
				(size_t)std::lround(std::min(1.0f, std::max(0.0f, ratio)) *
									(float)(levels_len - 1));
			const char glyph = levels[idx];
			int band_idx = (band > 0.0f) ? (int)std::floor(dist / band) : 0;
			if (band_idx < 0)
				band_idx = 0;
			if (band_idx >= (int)rows)
				continue;
			const size_t fill_rows = rows - (size_t)band_idx;
			const size_t start_row = rows - fill_rows;
			for (size_t r = start_row; r < rows; ++r) {
				grid[r][c] = glyph;
			}
			if (dist <= cfg::TELEMETRY_NEAR_EMPH_MM) {
				grid[rows - 1][c] = '!';
			}
		}
	}
	for (size_t r = 0; r < rows; ++r) {
		heat_rows.push_back(grid[r]);
	}
	std::string labels(scale_w, ' ');
	auto place_label = [&](const std::string &txt, int pos) {
		int start = pos - (int)txt.size() / 2;
		if (start < 0)
			start = 0;
		if (start + (int)txt.size() > (int)scale_w)
			start = (int)scale_w - (int)txt.size();
		for (size_t i = 0; i < txt.size(); ++i) {
			if (start + (int)i >= 0 && start + (int)i < (int)scale_w) {
				labels[(size_t)(start + (int)i)] = txt[i];
			}
		}
	};
	const int ticks[] = {0, 10, 20, 30, 40, 50, 60};
	const char *tick_labels[] = {"-90", "-60", "-30", "0", "+30", "+60", "+90"};
	for (size_t i = 0; i < 7; ++i) {
		place_label(tick_labels[i], ticks[i]);
	}
	const std::string line_labels =
		compass_left + "|" + fitVisible(labels, scale_w) + "|";
	std::string marker(scale_w, '-');
	for (int pos : ticks) {
		if (pos >= 0 && pos < (int)scale_w)
			marker[(size_t)pos] = '|';
	}
	auto marker_prio = [](char c) {
		switch (c) {
		case 'A':
			return 3;
		case 'T':
			return 2;
		case 'B':
			return 1;
		default:
			return 0;
		}
	};
	auto place_marker = [&](float angle_deg, char c) {
		if (!std::isfinite(angle_deg))
			return;
		const int pos = posFromAngle(angle_deg);
		if (pos < 0 || pos >= (int)scale_w)
			return;
		char &slot = marker[(size_t)pos];
		if (marker_prio(c) >= marker_prio(slot))
			slot = c;
	};
	place_marker(s.best_angle_deg, 'B');
	place_marker(s.raw_steer_deg, 'T');
	place_marker((float)s.steer_deg, 'A');
	std::string marker_colored;
	marker_colored.reserve(marker.size() * 4);
	for (char c : marker) {
		switch (c) {
		case 'B':
			marker_colored += "\x1b[32mB\x1b[0m";
			break;
		case 'T':
			marker_colored += "\x1b[33mT\x1b[0m";
			break;
		case 'A':
			marker_colored += "\x1b[36mA\x1b[0m";
			break;
		case '*':
			marker_colored += "\x1b[31m*\x1b[0m";
			break;
		case '|':
			marker_colored += "\x1b[90m|\x1b[0m";
			break;
		default:
			marker_colored.push_back(c);
			break;
		}
	}
	const std::string line_markers =
		compass_left + "|" + fitVisible(marker_colored, scale_w) + "|";
	const std::string bot_compass =
		compass_left + "+" + std::string(scale_w, '-') + "+";
	std::ostringstream l2;
	l2 << std::fixed << std::setprecision(1)
	   << "angles \x1b[32mB\x1b[0m=" << std::showpos << s.best_angle_deg
	   << "deg  \x1b[33mT\x1b[0m=" << s.raw_steer_deg
	   << "deg  \x1b[36mA\x1b[0m=" << (float)s.steer_deg << "deg";
	std::ostringstream l3;
	l3 << "top:";
	for (size_t i = 0; i < s.top_count; ++i) {
		l3 << " " << std::showpos << s.top[i].angle_deg << "(" << s.top[i].score
		   << ")";
	}
	l3 << "  override: " << colorOverride(s.override_kind);
	if (s.override_detail != "NONE")
		l3 << " (" << s.override_detail << ")";
	std::ostringstream l4;
	l4 << std::fixed << std::setprecision(2);
	l4 << "cmd: v=" << s.base_speed << "->" << s.limited_speed
	   << "  steer=" << s.raw_steer_deg << "->" << s.steer_deg << "deg"
	   << "  curve=" << s.curve_ratio << "  sf=" << s.speed_factor;
	std::ostringstream l5;
	l5 << "latency p="
	   << (s.planner_latency_ms ? std::to_string(*s.planner_latency_ms) : "NA")
	   << "ms c="
	   << (s.control_latency_ms ? std::to_string(*s.control_latency_ms) : "NA")
	   << "ms ttl=" << (s.ttl_ms ? std::to_string(*s.ttl_ms) : "NA");
	if (status_.valid) {
		l5 << " auto=" << (unsigned)status_.auto_active << " faults=0x"
		   << std::hex << status_.faults << std::dec
		   << " age=" << status_.age_ms << "ms";
	}
	std::ostringstream l6;
	l6 << "path_obst=" << s.path_obst_mm
	   << "mm  min_handle=" << s.min_handle_angle_deg << "deg@"
	   << s.min_handle_dist_mm << "mm";
	if (s.front_dist_mm)
		l6 << "  front=" << *s.front_dist_mm << "mm";
	if (s.side_dist_mm)
		l6 << "  side=" << *s.side_dist_mm << "mm";
	const std::string sp_angle =
		sparkline(spark_best_, -90.0f, 90.0f, cfg::TELEMETRY_SPARK_LEN);
	const std::string sp_speed =
		sparkline(spark_speed_, 0.0f, (float)cfg::PROCESS_MAX_SPEED,
				  cfg::TELEMETRY_SPARK_LEN);
	const std::string sp_dist =
		sparkline(spark_dist_, 0.0f, (float)cfg::TELEMETRY_DIST_BAR_MAX_MM,
				  cfg::TELEMETRY_SPARK_LEN);
	std::ostringstream l7;
	l7 << "spark ang:" << sp_angle << " spd:" << sp_speed
	   << " dst:" << colorWrap(sp_dist, dist_sev);
	std::ostringstream l8;
	l8 << std::fixed << std::setprecision(1);
	const size_t bar_w = cfg::TELEMETRY_BAR_WIDTH;
	if (metrics.valid) {
		const float cpu_ratio = (float)metrics.cpu_usage_permille / 1000.0f;
		const float temp_ratio =
			(float)metrics.cpu_temp_cdeg / (float)cfg::TELEMETRY_TEMP_CRIT_CDEG;
		l8 << "CPU " << colorWrap(bar(cpu_ratio, bar_w), cpu_sev) << " "
		   << (metrics.cpu_usage_permille / 10.0f) << "%  "
		   << "TEMP " << colorWrap(bar(temp_ratio, bar_w), temp_sev) << " "
		   << (metrics.cpu_temp_cdeg / 100.0f) << "C  ";
	} else {
		l8 << "CPU NA  TEMP NA  ";
	}
	const float dist_ratio =
		(float)path_mm / (float)cfg::TELEMETRY_DIST_BAR_MAX_MM;
	l8 << "DIST " << colorWrap(bar(dist_ratio, bar_w), dist_sev) << " "
	   << path_mm << "mm";
	if (metrics.valid) {
		l8 << "  MEM " << (metrics.mem_used_kb / 1024.0f) << "/"
		   << (metrics.mem_total_kb / 1024.0f) << "MB";
	}
	auto sev_name = [](Severity s) {
		switch (s) {
		case Severity::Safe:
			return "SAFE";
		case Severity::Warn:
			return "WARN";
		case Severity::Crit:
			return "CRIT";
		}
		return "UNK";
	};
	auto sev_rank = [](Severity s) {
		switch (s) {
		case Severity::Safe:
			return 0;
		case Severity::Warn:
			return 1;
		case Severity::Crit:
			return 2;
		}
		return 0;
	};
	const bool best_jump = s.best_delta_deg && std::fabs(*s.best_delta_deg) >=
												   cfg::TELEMETRY_BEST_JUMP_DEG;
	if (best_jump && !last_best_jump_) {
		pushEvent_("BEST_JUMP " + std::to_string(*s.best_delta_deg));
	}
	last_best_jump_ = best_jump;
	const bool slowdown = (s.speed_factor <= cfg::TELEMETRY_SLOWDOWN_SF);
	if (slowdown && !last_slowdown_) {
		pushEvent_("SLOWDOWN sf=" + std::to_string(s.speed_factor));
	}
	last_slowdown_ = slowdown;
	if (s.scan_age_ms && sev_rank(loc_sev) > sev_rank(last_loc_sev_)) {
		pushEvent_("SCAN_STALE " + std::to_string(*s.scan_age_ms) + "ms");
	}
	last_loc_sev_ = loc_sev;
	if (sev_rank(map_sev) > sev_rank(last_map_sev_)) {
		pushEvent_(std::string("MAP ") + sev_name(map_sev));
	}
	last_map_sev_ = map_sev;
	if (sev_rank(sens_sev) > sev_rank(last_sens_sev_)) {
		if (sens_ratio >= 0.0f) {
			const int miss_pct = (int)std::round((1.0f - sens_ratio) * 100.0f);
			pushEvent_("SENS_DROP miss=" + std::to_string(miss_pct) + "%");
		} else {
			pushEvent_("SENS_DROP");
		}
	}
	last_sens_sev_ = sens_sev;
	if (sev_rank(ctrl_sev) > sev_rank(last_ctrl_sev_)) {
		pushEvent_(std::string("CTRL ") + sev_name(ctrl_sev));
	}
	last_ctrl_sev_ = ctrl_sev;
	if (ttl_expired && !last_ttl_expired_) {
		pushEvent_("TTL_EXPIRED age=" + std::to_string(status_.age_ms) + "ms");
	}
	last_ttl_expired_ = ttl_expired;
	const bool faults_now = status_.valid && status_.faults != 0;
	if (faults_now && !last_faults_) {
		std::ostringstream f;
		f << "FAULTS 0x" << std::hex << status_.faults << std::dec;
		pushEvent_(f.str());
	}
	last_faults_ = faults_now;
	std::ostringstream l9;
	if (s.lidar_points && s.lidar_expected) {
		const float miss = 100.0f *
						   (float)(*s.lidar_expected - *s.lidar_points) /
						   (float)*s.lidar_expected;
		l9 << "lidar: " << *s.lidar_points << "/" << *s.lidar_expected
		   << " miss=" << std::fixed << std::setprecision(1) << miss << "%";
	} else {
		l9 << "lidar: NA";
	}
	l9 << " | heat:";
	std::string heat;
	heat.reserve(TELEMETRY_HEAT_BINS);
	for (size_t i = 0; i < s.heat_bins.size(); ++i) {
		float n = s.heat_bins[i];
		if (n < 0.0f)
			n = 0.0f;
		if (n > 1.0f)
			n = 1.0f;
		const size_t idx = (size_t)std::round(n * 8.0f);
		static const char *k = " .:-=+*#@";
		heat.push_back(k[idx]);
	}
	l9 << heat;
	std::ostringstream l10;
	if (!events_.empty()) {
		l10 << "events:";
		for (size_t i = 0; i < events_.size(); ++i) {
			if (i > 0)
				l10 << " | ";
			l10 << events_[i];
		}
	} else {
		l10 << "events: NA";
	}
	auto pad = [&](const std::string &sline) {
		const std::string trimmed = trimVisible(sline, frame_width - 2);
		const size_t vis = visibleLen(trimmed);
		if (vis >= frame_width - 2)
			return trimmed;
		return trimmed + std::string(frame_width - 2 - vis, ' ');
	};
	const std::string title = " ROBO RACER TELEMETRY ";
	const std::string top =
		"+" + std::string((frame_width - title.size()) / 2, '-') + title +
		std::string(frame_width - title.size() -
						((frame_width - title.size()) / 2) - 2,
					'-') +
		"+";
	const std::string bot = "+" + std::string(frame_width - 2, '-') + "+";
	auto line = [&](const std::string &sline) {
		return "|" + pad(sline) + "|";
	};
	const int frame_lines = 17 + (int)heat_rows.size();
	if (!ui_initialized_) {
		std::cout << "\x1b[?25l"; 
		std::cout << top << "\n"
				  << line(l0.str()) << "\n"
				  << line(l1.str()) << "\n"
				  << line(top_compass) << "\n";
		for (const auto &row : heat_rows) {
			std::cout << line(compass_left + "|" + row + "|") << "\n";
		}
		std::cout << line(line_markers) << "\n"
				  << line(line_labels) << "\n"
				  << line(bot_compass) << "\n"
				  << line(l2.str()) << "\n"
				  << line(l3.str()) << "\n"
				  << line(l4.str()) << "\n"
				  << line(l5.str()) << "\n"
				  << line(l6.str()) << "\n"
				  << line(l7.str()) << "\n"
				  << line(l8.str()) << "\n"
				  << line(l9.str()) << "\n"
				  << line(l10.str()) << "\n"
				  << bot;
		std::cout << "\x1b[" << frame_lines << "A";
		ui_initialized_ = true;
	} else {
		std::cout << "\x1b[" << frame_lines << "A";
		std::cout << "\x1b[2K\r" << top << "\n";
		std::cout << "\x1b[2K\r" << line(l0.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l1.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(top_compass) << "\n";
		for (const auto &row : heat_rows) {
			std::cout << "\x1b[2K\r" << line(compass_left + "|" + row + "|")
					  << "\n";
		}
		std::cout << "\x1b[2K\r" << line(line_markers) << "\n";
		std::cout << "\x1b[2K\r" << line(line_labels) << "\n";
		std::cout << "\x1b[2K\r" << line(bot_compass) << "\n";
		std::cout << "\x1b[2K\r" << line(l2.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l3.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l4.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l5.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l6.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l7.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l8.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l9.str()) << "\n";
		std::cout << "\x1b[2K\r" << line(l10.str()) << "\n";
		std::cout << "\x1b[2K\r" << bot;
		std::cout << "\x1b[" << frame_lines << "A";
	}
	std::cout << std::flush;
}
----------------------------------------

----------------------------------------
File: rpi/src/main.cpp
----------------------------------------
#include "Process.h"
#include "Sender.h"
#include "ShmLidarReceiver.h"
#include "config/Config.h"
#include "lidar_to_esp.h"
#include "mc/core/Log.hpp"
#include "mc/core/Time.hpp"
#include <cerrno>
#include <csignal>
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <string>
#include <sys/stat.h>
#include <unistd.h>
#include <vector>
static volatile sig_atomic_t g_stop = 0;
static volatile sig_atomic_t g_last_sig = 0;
static void on_sig(int sig) {
	g_last_sig = sig;
	g_stop = 1;
}
static void show_cursor() { std::cout << "\x1b[?25h" << std::flush; }
static std::string make_run_id() {
	std::ostringstream oss;
	oss << std::hex << mc::core::Time::us() << "-p" << (unsigned)getpid();
	return oss.str();
}
static void ensure_dir_for(const std::string &path) {
	if (path.empty())
		return;
	const size_t pos = path.find_last_of('/');
	if (pos == std::string::npos || pos == 0)
		return;
	const std::string dir = path.substr(0, pos);
	const int rc = mkdir(dir.c_str(), 0755);
	if (rc == 0 || errno == EEXIST)
		return;
	MC_LOGW("main", "mkdir failed for log dir: " + dir);
}
int main(int argc, char **argv) {
	signal(SIGINT, on_sig);
	signal(SIGTERM, on_sig);
	std::atexit(show_cursor);
	std::string log_path = cfg::DEFAULT_PROCESS_LOG;
	std::string metrics_log_path = cfg::DEFAULT_METRICSD_LOG;
	std::string run_id;
	double telemetry_hz = cfg::TELEMETRY_DEFAULT_HZ;
	TelemetryLevel telemetry_level = TelemetryLevel::Basic;
	std::vector< std::string > positional;
	for (int i = 1; i < argc; ++i) {
		std::string a = argv[i];
		if (a == "--log" && i + 1 < argc) {
			log_path = argv[++i];
		} else if (a == "--metrics-log" && i + 1 < argc) {
			metrics_log_path = argv[++i];
		} else if (a == "--telemetry-hz" && i + 1 < argc) {
			telemetry_hz = std::atof(argv[++i]);
		} else if (a == "--telemetry-level" && i + 1 < argc) {
			std::string lv = argv[++i];
			if (lv == "full")
				telemetry_level = TelemetryLevel::Full;
			else
				telemetry_level = TelemetryLevel::Basic;
		} else if (a == "--run-id" && i + 1 < argc) {
			run_id = argv[++i];
		} else {
			positional.push_back(a);
		}
	}
	const char *lidar_dev = (positional.size() >= 1)
								? positional[0].c_str()
								: cfg::DEFAULT_LIDAR_DEVICE;
	int lidar_baud = (positional.size() >= 2) ? std::atoi(positional[1].c_str())
											  : cfg::DEFAULT_LIDAR_BAUD;
	const char *seriald_sock = (positional.size() >= 3)
								   ? positional[2].c_str()
								   : cfg::DEFAULT_SERIALD_SOCK;
	(void)lidar_dev;
	(void)lidar_baud;
	if (run_id.empty())
		run_id = make_run_id();
	auto &logger = mc::core::Logger::instance();
	logger.setConsoleEnabled(false);
	if (!log_path.empty()) {
		ensure_dir_for(log_path);
		logger.addSink(std::make_shared< mc::core::FileSink >(log_path));
	}
	ShmLidarReceiver lidarReceiver;
	TelemetryEmitter telemetry;
	telemetry.setMetricsLogPath(metrics_log_path);
	telemetry.setRateHz(telemetry_hz);
	telemetry.setLevel(telemetry_level);
	Process process(&telemetry);
	Sender sender(seriald_sock, &telemetry);
	uint64_t last_wait_log_us = 0;
	while (!g_stop && !lidarReceiver.connect()) {
		const uint64_t now_us = mc::core::Time::us();
		if (now_us - last_wait_log_us > 1000 * 1000) {
			MC_LOGW("main", "Waiting for lidar_received shared memory...");
			last_wait_log_us = now_us;
		}
		usleep(200 * 1000);
	}
	if (g_stop)
		return 0;
	float lastSteerAngle = 0.0f;
	uint64_t tick = 0;
	while (!g_stop) {
		std::vector< LidarData > lidarData;
		if (lidarReceiver.getLatestData(lidarData)) {
			const ProcResult procResult =
				process.proc(lidarData, lastSteerAngle, tick, tick, run_id);
			sender.send(procResult.speed, procResult.angle);
			lastSteerAngle = procResult.angle;
			++tick;
		} else {
			usleep(1 * 1000);
		}
	}
	if (g_last_sig != 0) {
		MC_LOGI("main", "Signal " + std::to_string((int)g_last_sig) +
							" received, shutting down...");
	}
	MC_LOGI("main", "shutdown complete");
	telemetry.shutdownUi();
	logger.shutdown();
	return 0;
}
----------------------------------------

----------------------------------------
File: rpi/src/lidar_to_esp.cpp
----------------------------------------
#include "lidar_to_esp.h"
#include "LidarReceiver.h"
#include "Process.h"
#include "Sender.h"
#include "config/Config.h"
#include "mc/core/Log.hpp"
#include "mc/core/Time.hpp"
#include <csignal>
#include <cstdint>
#include <iostream>
#include <sstream>
static volatile sig_atomic_t g_stop = 0;
static void on_sig(int) { g_stop = 1; }
static void show_cursor() { std::cout << "\x1b[?25h" << std::flush; }
static std::string make_run_id() {
	std::ostringstream oss;
	oss << std::hex << mc::core::Time::us();
	return oss.str();
}
int run_lidar_to_esp(const char *lidar_dev, int lidar_baud,
					 const char *esp_dev) {
	signal(SIGINT, on_sig);
	signal(SIGTERM, on_sig);
	std::atexit(show_cursor);
	mc::core::Logger::instance().setConsoleEnabled(false);
	LidarReceiver lidarReceiver(lidar_dev, lidar_baud);
	TelemetryEmitter telemetry;
	telemetry.setMetricsLogPath(cfg::DEFAULT_METRICSD_LOG);
	telemetry.setRateHz(cfg::TELEMETRY_DEFAULT_HZ);
	telemetry.setLevel(TelemetryLevel::Basic);
	Process process(&telemetry);
	Sender sender(esp_dev, &telemetry);
	const std::string run_id = make_run_id();
	uint64_t tick = 0;
	float lastSteerAngle = 0.0f;
	while (!g_stop) {
		const auto &res = lidarReceiver.receive();
		const auto procResult =
			process.proc(res, lastSteerAngle, tick, tick, run_id);
		sender.send(procResult.speed, procResult.angle);
		lastSteerAngle = procResult.angle;
		++tick;
	}
	telemetry.shutdownUi();
	return 0;
}
----------------------------------------

----------------------------------------
File: rpi/src/Telemetry.h
----------------------------------------
#pragma once
#include "mc/core/Time.hpp"
#include <array>
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <mutex>
#include <optional>
#include <string>
#include <thread>
#include <vector>
struct TelemetryCandidate {
	float angle_deg{};
	int distance_mm{};
	float score{};
};
enum class Severity : uint8_t { Safe = 0, Warn = 1, Crit = 2 };
static constexpr size_t TELEMETRY_HEAT_BINS = 37;
static constexpr size_t TELEMETRY_COMPASS_BINS = 61;
struct TelemetrySample {
	uint64_t ts_us{};
	std::string run_id;
	uint64_t tick{};
	uint64_t scan_id{};
	std::string mode{"UNKNOWN"};
	std::string map_state{"UNKNOWN"};
	std::optional< uint32_t > scan_age_ms;
	float best_angle_deg{};
	int best_dist_mm{};
	float best_score{};
	std::optional< float > best_delta_deg;
	float min_handle_angle_deg{};
	int min_handle_dist_mm{};
	int path_obst_mm{};
	std::optional< int > front_dist_mm;
	std::optional< int > side_dist_mm;
	int base_speed{};
	int limited_speed{};
	int steer_deg{};
	float raw_steer_deg{};
	float curve_ratio{1.0f};
	float speed_factor{1.0f};
	int steer_clamp_deg{};
	std::string override_kind{"NONE"};
	std::string override_detail{"NONE"};
	int th_stop_mm{};
	int th_safe_mm{};
	std::array< TelemetryCandidate, 3 > top{};
	size_t top_count{};
	std::vector< TelemetryCandidate > candidates;
	bool include_candidates = false;
	std::array< float, TELEMETRY_HEAT_BINS > heat_bins{};
	std::array< int, TELEMETRY_COMPASS_BINS > lidar_dist_bins{};
	bool lidar_dist_valid = false;
	std::optional< float > score_obstacle;
	std::optional< float > score_width;
	std::optional< float > score_goal;
	std::optional< float > score_curvature;
	std::optional< float > score_stability;
	std::optional< float > score_map_conf;
	std::optional< uint32_t > planner_latency_ms;
	std::optional< uint32_t > control_latency_ms;
	std::optional< uint16_t > ttl_ms;
	std::optional< size_t > lidar_points;
	std::optional< size_t > lidar_expected;
};
enum class TelemetryLevel : uint8_t { Basic = 0, Full = 1 };
class TelemetryEmitter {
public:
	TelemetryEmitter();
	~TelemetryEmitter();
	void emit(const TelemetrySample &s);
	void emitNoLidar(uint64_t ts_us,
					 const std::string &run_id,
					 uint64_t tick,
					 uint64_t scan_id);
	void setUiEnabled(bool enabled) { ui_enabled_ = enabled; }
	void setLevel(TelemetryLevel lv) { level_ = lv; }
	void setRateHz(double hz);
	void setMetricsLogPath(std::string path);
	void updateStatus(uint8_t auto_active,
					  uint16_t faults,
					  int16_t speed_mm_s,
					  int16_t steer_cdeg,
					  uint16_t age_ms);
	void shutdownUi();
private:
	void emitJson_(const TelemetrySample &s);
	void emitOverrideEvent_(const TelemetrySample &s);
	void emitUi_(const TelemetrySample &s);
	void refreshMetrics_();
	void metricsLoop_();
	void pushEvent_(std::string e);
	struct MetricsCache {
		bool valid = false;
		uint16_t cpu_temp_cdeg = 0;
		uint16_t cpu_usage_permille = 0;
		uint32_t mem_used_kb = 0;
		uint32_t mem_total_kb = 0;
	};
	struct StatusCache {
		bool valid = false;
		uint8_t auto_active = 0;
		uint16_t faults = 0;
		int16_t speed_mm_s = 0;
		int16_t steer_cdeg = 0;
		uint16_t age_ms = 0;
		uint64_t ts_us = 0;
	};
	std::string last_override_;
	bool ui_initialized_ = false;
	bool ui_enabled_ = true;
	TelemetryLevel level_ = TelemetryLevel::Basic;
	uint64_t telemetry_interval_us_ = 100000;
	uint64_t last_telemetry_us_ = 0;
	uint64_t last_ui_us_ = 0;
	std::string metrics_log_path_;
	uint64_t metrics_last_read_us_ = 0;
	MetricsCache metrics_;
	StatusCache status_;
	std::mutex metrics_mtx_;
	std::atomic< bool > running_{false};
	std::thread metrics_thread_;
	std::vector< float > spark_best_;
	std::vector< float > spark_speed_;
	std::vector< float > spark_dist_;
	std::vector< std::string > events_;
	bool has_last_delta_ = false;
	float last_delta_ = 0.0f;
	Severity last_loc_sev_ = Severity::Safe;
	Severity last_sens_sev_ = Severity::Safe;
	Severity last_ctrl_sev_ = Severity::Safe;
	Severity last_map_sev_ = Severity::Safe;
	bool last_best_jump_ = false;
	bool last_slowdown_ = false;
	bool last_ttl_expired_ = false;
	bool last_faults_ = false;
};
inline void TelemetryEmitter::updateStatus(uint8_t auto_active,
										   uint16_t faults,
										   int16_t speed_mm_s,
										   int16_t steer_cdeg,
										   uint16_t age_ms) {
	status_.valid = true;
	status_.auto_active = auto_active;
	status_.faults = faults;
	status_.speed_mm_s = speed_mm_s;
	status_.steer_cdeg = steer_cdeg;
	status_.age_ms = age_ms;
	status_.ts_us = mc::core::Time::us();
}
----------------------------------------

----------------------------------------
File: code.txt
----------------------------------------
----------------------------------------

----------------------------------------
File: shared/proto/include/mc/proto/Ack.hpp
----------------------------------------
#pragma once
#include "Proto.hpp"
namespace mc::proto {
static inline bool build_ack(uint16_t seq, uint8_t *out, size_t out_cap,
							 size_t &out_len) {
	return PacketWriter::build(out, out_cap, out_len, Type::ACK, 0, seq,
							   nullptr, 0);
}
template < typename Tx > static inline bool send_ack(Tx *tx, uint16_t seq) {
	if (!tx) {
		return false;
	}
	uint8_t out[mc::proto::MAX_FRAME_ENCODED];
	size_t out_len = 0;
	if (!build_ack(seq, out, sizeof(out), out_len)) {
		return false;
	}
	return tx->enqueue(out, (uint16_t)out_len);
}
} 
----------------------------------------

----------------------------------------
File: shared/proto/include/mc/proto/Proto.hpp
----------------------------------------
#pragma once
#ifdef ARDUINO
#include <Arduino.h>
#else
#include <array>
#include <cstddef>
#include <cstdint>
#endif
#include "mc_proto.h"
namespace mc::proto {
static constexpr size_t MAX_PAYLOAD = 64;
static constexpr size_t MAX_FRAME_DECODED = sizeof(Header) + MAX_PAYLOAD + 2;
static constexpr size_t MAX_FRAME_ENCODED =
	MAX_FRAME_DECODED + (MAX_FRAME_DECODED / 254) + 4;
static inline uint16_t to_le16(uint16_t v) {
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) &&             \
	(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
	return v;
#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) &&              \
	(__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
	return (uint16_t)((v >> 8) | (v << 8));
#else
	return v;
#endif
}
static inline uint16_t from_le16(uint16_t v) { return to_le16(v); }
static inline uint16_t host_to_le16(uint16_t v) { return to_le16(v); }
static inline uint16_t le16_to_host(uint16_t v) { return from_le16(v); }
class Frame {
public:
	const uint8_t *payload = nullptr;
	uint16_t payload_len = 0;
	uint8_t ver() const { return _hdr.ver; }
	uint8_t type() const { return _hdr.type; }
	uint8_t flags() const { return _hdr.flags; }
	uint16_t seq() const { return from_le16(_hdr.seq_le); }
	uint16_t len() const { return from_le16(_hdr.len_le); }
private:
	Header _hdr{};
	friend class PacketReader;
	friend bool decode_one(const uint8_t *enc, size_t enc_len, Frame &out,
						   uint8_t *decoded_buf, size_t decoded_cap);
};
using FrameView = Frame;
uint16_t crc16_ccitt(const uint8_t *data, size_t len);
size_t cobs_encode(const uint8_t *in, size_t len, uint8_t *out, size_t out_cap);
size_t cobs_decode(const uint8_t *in, size_t len, uint8_t *out, size_t out_cap);
class PacketWriter {
public:
	static bool build(uint8_t *out, size_t out_cap, size_t &out_len, Type type,
					  uint8_t flags, uint16_t seq, const uint8_t *payload,
					  uint16_t payload_len);
};
class PacketReader {
public:
	PacketReader();
	bool push(uint8_t b);
	bool hasFrame() const { return _hasFrame; }
	const Frame &frame() const { return _frame; }
	void consumeFrame();
	uint32_t badCrc() const { return _badCrc; }
	uint32_t badCobs() const { return _badCobs; }
	uint32_t badHdr() const { return _badHdr; }
private:
	bool decodeFrame_();
	uint8_t _raw[MAX_FRAME_ENCODED];
	size_t _rawLen;
	uint8_t _decoded[MAX_FRAME_DECODED];
	size_t _decodedLen;
	Frame _frame;
	bool _hasFrame;
	uint32_t _badCrc;
	uint32_t _badCobs;
	uint32_t _badHdr;
};
bool decode_one(const uint8_t *enc, size_t enc_len, Frame &out,
				uint8_t *decoded_buf, size_t decoded_cap);
#ifndef ARDUINO
template < size_t N >
inline bool decode_one(const uint8_t *enc, size_t enc_len, Frame &out,
					   std::array< uint8_t, N > &decoded_buf) {
	return decode_one(enc, enc_len, out, decoded_buf.data(),
					  decoded_buf.size());
}
#endif
} 
----------------------------------------

----------------------------------------
File: shared/proto/include/mc_proto.h
----------------------------------------
#pragma once
#include <stddef.h>
#include <stdint.h>
#pragma pack(push, 1)
namespace mc::proto {
static constexpr uint8_t MAGIC0 = 'M';
static constexpr uint8_t MAGIC1 = 'C';
static constexpr uint8_t VERSION = 1;
enum class Type : uint8_t {
	DRIVE = 0x01,
	KILL = 0x02,
	MODE_SET = 0x03,
	PING = 0x04,
	LOG = 0x10,
	STATUS = 0x11,
	HILS_STATE = 0x12,
	IPC_LIDAR_SCAN = 0x20,
	IPC_LIDAR_SUMMARY = 0x21,
	IPC_IMU_SAMPLE = 0x22,
	IPC_DRIVE_CMD = 0x23,
	IPC_VEHICLE_STATUS = 0x24,
	IPC_METRICS = 0x25,
	IPC_LOG_RECORD = 0x26,
	ACK = 0x80,
};
enum Flags : uint8_t {
	FLAG_ACK_REQ = 1u << 0, 
	FLAG_ACK = 1u << 1,		
	FLAG_ERR = 1u << 2,		
};
struct Header {
	uint8_t magic[2];
	uint8_t ver;
	uint8_t type;
	uint8_t flags;
	uint16_t seq_le;
	uint16_t len_le;
};
static_assert(sizeof(Header) == 9, "Header must be 9 bytes on wire");
struct DrivePayload {
	int16_t steer_cdeg;
	int16_t speed_mm_s;
	uint16_t ttl_ms_le;
	uint16_t dist_mm_le;
};
static_assert(sizeof(DrivePayload) == 8, "DrivePayload must be 8 bytes");
struct ModeSetPayload {
	uint8_t mode; 
};
static_assert(sizeof(ModeSetPayload) == 1, "ModeSetPayload must be 1 byte");
struct HilsStatePayload {
	uint32_t timestamp;
	int16_t throttle_raw;
	int16_t steer_cdeg;
	uint8_t flags;
};
static_assert(sizeof(HilsStatePayload) == 9,
			  "HilsStatePayload must be 9 bytes");
struct StatusPayload {
	uint8_t seq_applied;
	uint8_t auto_active;
	uint16_t faults_le;
	int16_t speed_mm_s_le;
	int16_t steer_cdeg_le;
	uint16_t age_ms_le;
};
static_assert(sizeof(StatusPayload) == 10, "StatusPayload must be 10 bytes");
struct LidarScanChunkPayload {
	uint32_t ts_ms;
	uint16_t scan_id;
	int16_t angle_start_cdeg;
	int16_t angle_step_cdeg;
	uint8_t chunk_index;
	uint8_t chunk_count;
	uint8_t point_count;
	uint8_t encoding; 
};
static_assert(sizeof(LidarScanChunkPayload) == 14,
			  "LidarScanChunkPayload must be 14 bytes");
struct LidarSummaryPayload {
	uint32_t ts_ms;
	int16_t best_heading_cdeg;
	uint16_t best_distance_mm;
	uint16_t min_distance_mm;
	int16_t min_distance_heading_cdeg;
	uint8_t confidence;
	uint8_t flags;
};
static_assert(sizeof(LidarSummaryPayload) == 14,
			  "LidarSummaryPayload must be 14 bytes");
struct ImuSamplePayload {
	uint32_t ts_ms;
	int16_t ax_mg;
	int16_t ay_mg;
	int16_t az_mg;
	int16_t gx_mdps;
	int16_t gy_mdps;
	int16_t gz_mdps;
};
static_assert(sizeof(ImuSamplePayload) == 16,
			  "ImuSamplePayload must be 16 bytes");
struct DriveCmdPayload {
	uint32_t ts_ms;
	int16_t steer_cdeg;
	int16_t speed_mm_s;
	uint16_t ttl_ms;
	uint8_t source;
	uint8_t flags;
};
static_assert(sizeof(DriveCmdPayload) == 12,
			  "DriveCmdPayload must be 12 bytes");
struct VehicleStatusPayload {
	uint32_t ts_ms;
	StatusPayload status;
};
static_assert(sizeof(VehicleStatusPayload) == 14,
			  "VehicleStatusPayload must be 14 bytes");
struct MetricsPayload {
	uint32_t ts_ms;
	uint16_t cpu_temp_cdeg;
	uint16_t cpu_usage_permille;
	uint32_t mem_used_kb;
	uint32_t mem_total_kb;
};
static_assert(sizeof(MetricsPayload) == 16, "MetricsPayload must be 16 bytes");
struct LogRecordPayload {
	uint32_t ts_ms;
	uint8_t level;
	uint8_t text_len;
	uint8_t flags;
	uint8_t reserved;
};
static_assert(sizeof(LogRecordPayload) == 8,
			  "LogRecordPayload must be 8 bytes");
} 
#pragma pack(pop)
----------------------------------------

----------------------------------------
File: shared/proto/library.json
----------------------------------------
{
  "name": "mc_proto_shared",
  "version": "0.1.0",
  "description": "Shared mc_proto implementation for firmware and RPi",
  "keywords": "proto, cobs, crc",
  "authors": [
    { "name": "TOYOTA42 team" }
  ],
  "license": "MIT",
  "frameworks": ["arduino"],
  "platforms": ["espressif32"]
}
----------------------------------------

----------------------------------------
File: shared/proto/src/mcproto.cpp
----------------------------------------
#include <mc/proto/Proto.hpp>
#ifdef ARDUINO
#include <string.h>
#else
#include <cstring>
#endif
namespace mc::proto {
static inline uint16_t rd16(const uint8_t *p) {
	return (uint16_t)p[0] | ((uint16_t)p[1] << 8);
}
static inline void wr16(uint8_t *p, uint16_t v_le) {
	p[0] = (uint8_t)(v_le & 0xFF);
	p[1] = (uint8_t)(v_le >> 8);
}
uint16_t crc16_ccitt(const uint8_t *data, size_t len) {
	uint16_t crc = 0xFFFF;
	for (size_t i = 0; i < len; ++i) {
		crc ^= (uint16_t)data[i] << 8;
		for (int b = 0; b < 8; ++b) {
			if (crc & 0x8000)
				crc = (uint16_t)((crc << 1) ^ 0x1021);
			else
				crc = (uint16_t)(crc << 1);
		}
	}
	return crc;
}
size_t cobs_encode(const uint8_t *in, size_t len, uint8_t *out,
				   size_t out_cap) {
	if (!out || out_cap == 0)
		return 0;
	size_t read_index = 0;
	size_t write_index = 1;
	size_t code_index = 0;
	uint8_t code = 1;
	while (read_index < len) {
		if (write_index >= out_cap)
			return 0;
		if (in[read_index] == 0) {
			out[code_index] = code;
			code = 1;
			code_index = write_index++;
			read_index++;
		} else {
			out[write_index++] = in[read_index++];
			if (++code == 0xFF) {
				out[code_index] = code;
				code = 1;
				code_index = write_index++;
			}
		}
	}
	if (code_index >= out_cap)
		return 0;
	out[code_index] = code;
	return write_index;
}
size_t cobs_decode(const uint8_t *in, size_t len, uint8_t *out,
				   size_t out_cap) {
	if (!in || !out)
		return 0;
	size_t read_index = 0;
	size_t write_index = 0;
	while (read_index < len) {
		uint8_t code = in[read_index];
		if (code == 0)
			return 0;
		read_index++;
		for (uint8_t i = 1; i < code; ++i) {
			if (read_index >= len)
				return 0;
			if (write_index >= out_cap)
				return 0;
			out[write_index++] = in[read_index++];
		}
		if (code != 0xFF && read_index < len) {
			if (write_index >= out_cap)
				return 0;
			out[write_index++] = 0;
		}
	}
	return write_index;
}
bool PacketWriter::build(uint8_t *out, size_t out_cap, size_t &out_len,
						 Type type, uint8_t flags, uint16_t seq,
						 const uint8_t *payload, uint16_t payload_len) {
	out_len = 0;
	if (payload_len > MAX_PAYLOAD)
		return false;
	uint8_t decoded[MAX_FRAME_DECODED];
	size_t decoded_len = 0;
	Header h{};
	h.magic[0] = MAGIC0;
	h.magic[1] = MAGIC1;
	h.ver = VERSION;
	h.type = (uint8_t)type;
	h.flags = flags;
	h.seq_le = host_to_le16(seq);
	h.len_le = host_to_le16(payload_len);
	memcpy(decoded, &h, sizeof(h));
	decoded_len += sizeof(h);
	if (payload_len && payload) {
		memcpy(decoded + decoded_len, payload, payload_len);
		decoded_len += payload_len;
	}
	const uint16_t crc = crc16_ccitt(decoded, decoded_len);
	wr16(decoded + decoded_len, to_le16(crc));
	decoded_len += 2;
	const size_t enc = cobs_encode(decoded, decoded_len, out, out_cap);
	if (enc == 0)
		return false;
	if (enc + 1 > out_cap)
		return false;
	out[enc] = 0x00;
	out_len = enc + 1;
	return true;
}
PacketReader::PacketReader()
	: _rawLen(0), _decodedLen(0), _hasFrame(false), _badCrc(0), _badCobs(0),
	  _badHdr(0) {
	_frame = Frame{};
}
bool PacketReader::push(uint8_t b) {
	if (_hasFrame)
		return true;
	if (b == 0x00) {
		if (_rawLen == 0)
			return false;
		const bool ok = decodeFrame_();
		_rawLen = 0;
		return ok && _hasFrame;
	}
	if (_rawLen >= sizeof(_raw)) {
		_rawLen = 0;
		_badCobs++;
		return false;
	}
	_raw[_rawLen++] = b;
	return false;
}
bool PacketReader::decodeFrame_() {
	_decodedLen = cobs_decode(_raw, _rawLen, _decoded, sizeof(_decoded));
	if (_decodedLen < sizeof(Header) + 2) {
		_badCobs++;
		return false;
	}
	const uint16_t got_crc = from_le16(rd16(_decoded + _decodedLen - 2));
	const uint16_t calc_crc = crc16_ccitt(_decoded, _decodedLen - 2);
	if (got_crc != calc_crc) {
		_badCrc++;
		return false;
	}
	Header h{};
	memcpy(&h, _decoded, sizeof(h));
	if (h.magic[0] != MAGIC0 || h.magic[1] != MAGIC1 || h.ver != VERSION) {
		_badHdr++;
		return false;
	}
	const uint16_t plen = from_le16(h.len_le);
	const size_t need = sizeof(Header) + (size_t)plen + 2;
	if (plen > MAX_PAYLOAD || _decodedLen != need) {
		_badHdr++;
		return false;
	}
	_frame._hdr = h;
	_frame.payload = _decoded + sizeof(Header);
	_frame.payload_len = plen;
	_hasFrame = true;
	return true;
}
void PacketReader::consumeFrame() { _hasFrame = false; }
bool decode_one(const uint8_t *enc, size_t enc_len, Frame &out,
				uint8_t *decoded_buf, size_t decoded_cap) {
	if (!enc || enc_len == 0 || !decoded_buf || decoded_cap == 0)
		return false;
	if (enc[enc_len - 1] == 0x00)
		enc_len--;
	const size_t dec_len = cobs_decode(enc, enc_len, decoded_buf, decoded_cap);
	if (dec_len < sizeof(Header) + 2)
		return false;
	Header h{};
	memcpy(&h, decoded_buf, sizeof(Header));
	if (h.magic[0] != MAGIC0 || h.magic[1] != MAGIC1 || h.ver != VERSION) {
		return false;
	}
	const uint16_t payload_len = from_le16(h.len_le);
	const size_t frame_wo_crc = sizeof(Header) + payload_len;
	if (frame_wo_crc + 2 != dec_len)
		return false;
	uint16_t crc_le = 0;
	memcpy(&crc_le, decoded_buf + frame_wo_crc, 2);
	const uint16_t crc = from_le16(crc_le);
	const uint16_t expect = crc16_ccitt(decoded_buf, frame_wo_crc);
	if (crc != expect)
		return false;
	out._hdr = h;
	out.payload = decoded_buf + sizeof(Header);
	out.payload_len = payload_len;
	return true;
}
} 
----------------------------------------

----------------------------------------
File: docs/firmware/hils_plan.md
----------------------------------------
# HILS 設計ドキュメント（Plan）

このドキュメントは、ESP32ファームウェアにおけるHILS
（Hardware-in-the-Loop Simulation）機能の設計思想、構成、
データフロー、APIをまとめた計画書です。

## 目的

- アクチュエータ出力を安全に切り替え可能にする
- 実機出力とHILS出力を同時/排他的に扱えるようにする
- 低遅延ループを壊さない軽量な観測経路を提供する
- 将来の疑似センサ注入（入力側HILS）を見据えた拡張性を確保する

## 適用範囲 / 非目的

適用範囲:

- ESP32側のアクチュエータ出力を観測/再生可能にする
- 実機制御の「最終出力」への観測点を提供する

非目的:

- 現時点では疑似センサ入力を注入する機能は持たない
- リアルタイム同期や閉ループHILSの完全再現は対象外

## 設計方針

1. 出力経路の切り替えで実現する
   - `OutputMode` によりHardware/Shadow/Hilsを統一制御
2. HILS出力はSinkで拡張可能にする
   - `hils::Sink` インターフェースで出力先を増やせる
3. 制御ループと疎結合にする
   - HILS出力は副経路として扱い、停止しても制御に影響しない

## 用語

- HILS: 実機の制御出力を外部に送出し、シミュレーションと接続する枠組み
- Hardware: 実機アクチュエータに直接出力する通常運用
- Shadow: 実機出力に加え、HILS出力も同時に送る
- Hils: 実機出力を停止し、HILS出力のみ送る

## システム全体における位置づけ

```
App -> ActuatorBus -> (MotorDriver / ServoSteering)
                     -> (HILS Sink: Serial/BLEなど)
```

- HILSはアクチュエータ出力直前に挿入される
- 出力値は安全処理やスケーリング後の最終指令値
- hostタイムアウト時の「停止値」もHILSに出力される

## コンポーネント構成

- `firmware/src/control/ActuatorBus.h`
- `firmware/src/control/ActuatorBus.cpp`
  - `OutputMode` と HILS送出
- `firmware/src/hils/Hils.h`
- `firmware/src/hils/Hils.cpp`
  - `hils::Sink`, `hils::Mux`, `hils::StreamSink`
- `firmware/src/config/Config.h`
  - `OUTPUT_MODE`, `HILS_REPORT_TO_SERIAL`, `HILS_REPORT_TO_BLE`

## データフロー設計

```
ActuatorBus::apply -> OutputMode分岐
  Hardware: 実機に出力のみ
  Shadow: 実機出力 + HILS Sinkへ送出
  Hils: 実機出力なし、HILS Sinkへ送出のみ
```

## 初期化 / 設定フロー

1. `App::begin()` で `ActuatorBus::begin()` を呼び実機初期化
2. `App::configureHils()` で `OutputMode` とHILS Sinkを設定
3. `ActuatorBus::apply()` がループ内で毎回呼ばれる

注意:

- `OutputMode` は `Config.h` の静的定数で設定する
- 変更はビルド/書き込みが必要

## データ仕様

### ActuatorCommand

```
now_ms: millis() の値（単調増加、約49日でラップ）
throttle: 最終指令値（スケーリング後）
steer: 最終指令値（スケーリング後）
```

スケーリング例:

- `throttle` は `THROTTLE_MAX` / `THROTTLE_REVERSE` を反映した値
- `steer` は `STEER_MAX` を反映した値

つまり、HILSで取得する値は「入力（-1..1）」ではなく
「実機へ出す正規化済み指令」です。

## タイミング / 性能

- 出力頻度はメインループに依存（おおむね数百Hz）
- HILS Sinkは同期呼び出しのため、重い処理は避ける
- 出力の取りこぼしは許容（制御優先）

## 安全設計 / フェイルセーフ

- `ActuatorBus::begin()` でモータ停止・サーボセンターに初期化される
- `OutputMode::Hils` は実機出力を無効化する
- hostタイムアウト時は停止値がHILSにも送出される
- HILS出力が止まっても制御ループは継続する

## API設計

### OutputMode

- `Hardware`: 実機に出力、HILS送出なし
- `Shadow`: 実機出力 + HILS送出
- `Hils`: 実機出力なし、HILS送出のみ

### ActuatorBus

- `setOutputMode(OutputMode mode)`
- `attachHilsSink(hils::Sink *sink)`
- `apply(float throttle, float steer, uint32_t now_ms)`

### hils::Sink

```
struct ActuatorCommand {
  uint32_t now_ms;
  float throttle;
  float steer;
};

class Sink {
 public:
  virtual void onActuatorCommand(const ActuatorCommand &cmd) = 0;
};
```

### hils::Mux

複数Sinkに送出するための集約クラス。
最大3つまで登録可能。

### 3.1 通信プロトコル

低遅延性と既存資産の再利用のため、`comm/mc_proto` (COBS + CRC16) を使用する。
新しいパケットタイプ `CMD_HILS_STATE (0x12)` を定義し、バイナリで転送する。

**パケット構造:**
`[Header] [Type=0x12] [Seq] [Len] [Payload] [CRC]`

**Payload (HilsStatePayload):**

| フィールド | 型 (Byte) | 説明 | スケーリング |
| :--- | :--- | :--- | :--- |
| timestamp | uint32 (4) | 内部時刻 | 1ms |
| throttle | int16 (2) | スロットル | Raw値 (-1000~1000等) |
| steer | int16 (2) | ステアリング | センチ度 (cdeg) |
| flags | uint8 (1) | 状態フラグ | Bitmask |

## 制約・注意点

- HILS出力は副経路として扱われるため、Sinkの停止は制御に影響しない
- Sink数は最大3
- `OutputMode::Hils` では実機出力が無効になる
- Shadow/Hilsは安全確認の上で使用する
- HILS出力はアクチュエータのPWM値ではなく正規化コマンド値

## 検証観点

- Shadowモードで実機挙動とHILS値の一致を確認
- Hilsモードで実機出力が止まることを確認
- HILS出力を有効にしてもループレイテンシが悪化しないことを確認

## 拡張の方向性

- HILS入力（疑似センサ値の注入）経路の追加
- バイナリHILS出力（COBS+CRC）による高頻度配信
- HILS再生用のタイムスタンプ同期機構
- 出力のレート制御（デシメーション）
- 収録データのフォーマット統一（ログ/テレメトリとの統合）
----------------------------------------

----------------------------------------
File: docs/firmware/log_guide.md
----------------------------------------
# LOG/HILS 運用ガイド（Guide）

このドキュメントは、LOGの使い方、設定方法、運用パターンを
まとめた実務向けガイドです。

## 設定ファイル

設定は `firmware/src/config/Config.h` にあります。

### ログ設定

- `LOG_LEVEL_DEFAULT`
- `LOG_LEVEL_COMM`, `LOG_LEVEL_CONTROL`, `LOG_LEVEL_HARDWARE`,
  `LOG_LEVEL_HILS`
- `LOG_TO_SERIAL`（テキストログをUARTへ）
- `LOG_TO_BLE`（テキストログをBLEへ）
- `LOG_TO_UART_PROTOCOL`（COBS+CRCログをUARTへ）
- `LOG_TO_UDP`（UDPログを有効化）

HILS設定は `docs/firmware/hils_guide.md` を参照してください。

### UDP設定

- `WIFI_SSID`, `WIFI_PASS`
- `LOG_UDP_HOST`, `LOG_UDP_PORT`
- `LOG_UDP_CONNECT_TIMEOUT_MS`

## 推奨運用パターン

### UARTにCOBSログ、制御はUARTのまま

```
LOG_TO_SERIAL = false
LOG_TO_UART_PROTOCOL = true
LOG_TO_UDP = false
```

RPi側でCOBS+CRCをデコードし、`MsgType::Log` を処理します。

### 高頻度ログはUDP、制御はUART固定

```
LOG_TO_SERIAL = false
LOG_TO_UART_PROTOCOL = false
LOG_TO_UDP = true
WIFI_SSID / WIFI_PASS / LOG_UDP_HOST / LOG_UDP_PORT を設定
```

UARTは制御専用、ログはUDPに分離されます。

### デバッグ時の軽量テキストログ

```
LOG_TO_SERIAL = true
LOG_TO_UART_PROTOCOL = false
LOG_TO_UDP = false
```

## ログAPIの使い方

### レベルとトピック

レベル:

- `Trace`, `Debug`, `Info`, `Warn`, `Error`, `Off`

トピック:

- `App`, `Comm`, `Control`, `Hardware`, `Hils`

### マクロ

```
MC_LOGT(topic, "fmt", ...)
MC_LOGD(topic, "fmt", ...)
MC_LOGI(topic, "fmt", ...)
MC_LOGW(topic, "fmt", ...)
MC_LOGE(topic, "fmt", ...)
```

例:

```
MC_LOGI(mc::log::Topic::Comm, "BLE connected");
```

### Logger API（概要）

- `Logger::attachSink(Sink*)`
- `Logger::setLevelAll(Level)`
- `Logger::setLevel(Topic, Level)`
- `Logger::enabled(Topic, Level)`
- `Logger::logf(Topic, Level, const char *fmt, ...)`

## 運用上の注意点

- UARTのCOBSログとテキストログは混在させない
- UDPログはWi-Fi接続失敗時に無効化される
- 文字列ログは最大96文字に切り詰められる
- Sinkは最大3つまで

## 受信側（RPi）実装のヒント

- UART/UDPともにCOBS+CRCで同じデコーダを使える
- `MsgType::Log` は `LogPayloadHeader` + メッセージバイト列
- `msg_len` を信頼し、NUL終端はない前提で扱う

HILSの運用は `docs/firmware/hils_guide.md` を参照してください。
----------------------------------------

----------------------------------------
File: docs/firmware/log_plan.md
----------------------------------------
# LOG 設計ドキュメント（mc_proto LOG v1）

このドキュメントは、ESP32 ファームウェアにおけるログ（LOG）の
設計思想、構成、データフロー、プロトコル仕様をまとめた運用設計書です。
**wire 上の値は `shared/proto/mc_proto.h` を正とし、本書は運用・設計の補助です。**

## 目的

- 低遅延の制御ループを阻害しないログ出力を提供する
- RPi 側で再利用できる共通フレーム（COBS + CRC）でログを送る
- mc_proto の LOG(0x10) に統合して、仕様の単一正を保つ

## 設計方針

1. 制御経路の安定性最優先
   - ログは「捨てられても良い副経路」扱い
2. フレーム統一
   - LOG は mc_proto v1 の `Type::LOG(0x10)` を使用
   - UART 伝送は COBS + CRC16 で再同期性を確保
3. 実装はシンプルに
   - `AsyncLogger -> UartTx` の単一経路でベストエフォート

## 実装コンポーネント

- `firmware/src/log/AsyncLogger.*`
  - `LogLevel` とメッセージ文字列を LOG フレームへ変換
  - 送信キュー満杯時は drop（`dropped()` でカウント）
- `firmware/src/comm/UartTx.*`
  - 送信専用キュー（低優先度タスク）
- `firmware/src/comm/mc_proto.*`
  - PacketWriter / COBS / CRC16

## データフロー

```
MC_LOGI(...) -> AsyncLogger -> UartTx -> COBS+CRC frame -> UART
```

## LOG プロトコル仕様（mc_proto v1）

フレーミングは `docs/proto/log_transport.md` を参照。
ここでは LOG の payload 仕様のみ記す。

```
type = 0x10 (LOG)
payload:
  [0]   level : u8
  [1..] text  : UTF-8 bytes (NUL終端なし)
```

- `level` は `LogLevel` の 0..5 を使用
- `text` は `tag + ": " + msg` 形式（`AsyncLogger` 実装）

## 制約・注意点（現行実装に基づく）

- payload の最大長は `mc::proto::MAX_PAYLOAD`（64 bytes）
  - `text` は最大 63 bytes に切り詰められる
- 送信キューが詰まった場合は **drop** される（制御を止めない）
- LOG の送信はベストエフォートで、順序/完全性は保証しない

## 運用（推奨）

- 重要イベント（KILL/TTL_EXPIRED など）を優先し、DEBUG を抑制する
- 帯域を占有しないよう **ログ量を制限** する
  - 例: 1 秒あたりの上限 bytes / 1 ループあたりの上限件数
  - 上限は `AsyncLogger` 側で制御（将来の拡張ポイント）

## 参考

- `shared/proto/mc_proto.h`（wire 上の正）
- `docs/proto/log_transport.md`（フレーミングと UART 運用）
----------------------------------------

----------------------------------------
File: docs/firmware/plan.md
----------------------------------------
# Firmware Plan (ESP32) — TOYOTA42自動運転ミニカーバトル

## 目的とスコープ

このファームウェアは **ESP32単体で走行可能**であることを最優先とし、RPi（高レベル制御）を後から接続しても破綻しないよう、次を提供します。

- **TSD20（1D LiDAR）** を用いた前方距離計測に基づく「減速・停止・回避」
- **MPU-6050（ジャイロ）** による **ヨー角（相対）** 推定を使った「直進保持」「右回り／左回りの回避戦略」
- **ステート管理**（Idle / Manual / Auto / Estop）と安全系（ホスト監視、緊急停止）
- **RPiとの通信プロトコル**（実装はESP32側のみ。RPi側はインターフェース定義）
- 今後の2D LiDAR（RPi）・経路計画・SLAM等の拡張を前提とした **クラス分割** と **ディレクトリ設計**

本フェーズでは「最速で走る」ではなく **確実に“安全に走る”** を優先します。

## 関連ドキュメント

- LOG 設計: log_plan.md
- LOG 運用: log_guide.md
- HILS 設計: hils_plan.md
- HILS 運用: hils_guide.md

---

## 現状の最小機能（本実装が提供するもの）

### 走行（Auto）
- 通常は前進（速度はConfigで制限）
- TSD20距離が閾値を下回ると減速→停止→後退→旋回→再前進
- 旋回方向は **preferRight（右優先/左優先）** で決定
- ジャイロのヨー角変化量で **旋回完了角（例: 55°）** を判定

### 直進保持（Yaw P制御）
- Cruise中に基準方位（headingRef）を固定
- 方位誤差を `steer += Kp * yaw_error` で補正

### 安全系
- EstopがActiveなら常にスロットル0、操舵センター
- Host（RPi）からManual制御中、ハートビートが途絶えたら停止
- 1D距離が非常に近い場合は、最終段で必ずスロットル0へクランプ

---

## ディレクトリ設計（推奨方針）

PlatformIO/Arduinoの慣例に合わせます。

```
firmware/
  src/
    main.cpp
    app/         … 依存を束ねるアプリ層（App）
    comm/        … RPi/ホストと通信（Comm + protocol）
    config/      … ピン・閾値・制御ゲイン（Config.h）
    control/     … 状態・戦略・制御（State/Strategy/MotionController）
    hardware/    … デバイスドライバ（Tsd20/Imu/MotorDriver/ServoSteering）
  lib/
    common/      … 本プロジェクト共通の小物（SlewRateLimiter, clamp等）
    external/    … 外部ライブラリをsubmodule/subtreeで固定する場合の置き場
docs/
  firmware/plan.md
  firmware/log_plan.md
  firmware/log_guide.md
  firmware/hils_plan.md
  firmware/hils_guide.md
```

PlatformIOは `lib_dir` / `lib_extra_dirs` を使ってローカルライブラリを優先的に探索できます。 citeturn16search1turn16search7  
依存は `lib_deps` に宣言して自動インストールするのが標準運用です。 citeturn16search0turn16search12

---

## 主要クラス（責務の分離）

### app/App
- 全サブシステムを所有し、`begin()/loop()` のみを公開
- センサ更新→通信反映→状態機械→アクチュエータ出力→テレメトリ送信の順に実行

### hardware/*
- `MotorDriver`（IBT-2 / BTS7960）: PWMで前後回転を切替
- `ServoSteering`: LEDC 50Hz PWMでサーボ角（正規化 -1..1）を出力
- `Tsd20`: I2Cで距離(0x00/0x01)を読む（アドレス0x52）
- `Imu`: MPU6050_lightを使い `gyroZ` の積分で相対Yawを算出（バイアス推定あり）

### control/*
- `RuntimeState`: mode, estop, preferRight, headingRef, maneuver記録など
- `Strategy`: Auto時の挙動（Cruise/Brake/Reverse/Turnのサブステート）
- `MotionController`: 目標指令に対してスロットルのスルーレート制限と方位保持を適用

### comm/*
- `proto::Header` + payload のバイナリプロトコル（COBSでフレーミング）
- `Comm`: 受信パケットをコマンド（HostCommand）に変換し、テレメトリを送信

PacketSerialは **COBS/SLIP** によるパケット化を提供し、ペイロードに0x00等が含まれても扱えます。 citeturn12search0turn12search4  
CRC16はAceCRCなどを利用し、フレーム破損検出を行います。 citeturn13search3

---

## 右回り/左回り戦略（戦術レイヤ）

本実装の「回避」は **右優先（右手法）/左優先（左手法）** を単純に切替可能にしています。

- `preferRight = true` → 右に最大操舵して旋回（前進しながら）
- `preferRight = false` → 左に最大操舵して旋回

RPi側が将来、コース形状やLiDAR（2D）で「右へ行くべき/左へ行くべき」を判断して `SetPrefer` を送れば、ESP32はその方針に従って回避します。

---

## ジャイロ処理（Yaw推定・補正方針）

MPU-6050は磁気センサを持たないため、ヨー角は **必ずドリフト** します。  
ただし「短時間の直進保持」「一定角の旋回完了判定」には十分有効です。

- `gyroZ`（deg/s）を積分して `yawDeg` を更新
- 車体静止とみなせる期間に `gyroZ` バイアスを平均して補正
- `yawDeg` は [-180, 180) にラップ

MPU6050_lightは `getGyroZ()` や `getAngleZ()` などを提供し、実装コストを大幅に下げます。 citeturn10search6turn10search15  
より姿勢推定を強化する場合、MadgwickAHRS（加速度+ジャイロのAHRS）でロール/ピッチ安定化を行い、ヨーは相対角として扱う方針が現実的です。 citeturn14view2

---

## RPi通信プロトコル（インターフェース仕様）

### 前提
- 物理層: UART（RPi <-> ESP32）
- フレーミング: PacketSerial（COBS）
- 破損検出: CRC16（CCITT系、片側だけ変えない）

### メッセージ種別（例）
- `Heartbeat`: RPiが周期送信（ESP32はウォッチドッグに使用）
- `SetMode`: Idle/Manual/Auto
- `SetManual`: スロットル/操舵（-1000..1000）
- `Estop` / `ClearEstop`
- `Status`: ESP32→RPiのテレメトリ（距離、Yaw、指令値、ループHzなど）

プロトコルの定義は `firmware/src/comm/protocol/Protocol.h` に集約しています。

---

## 外部ライブラリ（本プロジェクトで“使える”候補）

### 通信
- PacketSerial（COBS/SLIPフレーミング） citeturn12search0turn12search4
- CRC: AceCRC（crc16ccittなど） citeturn13search3
- JSON（将来の設定配布/デバッグ用途）: ArduinoJson（MIT） citeturn15search2

### IMU/フィルタ
- MPU6050_light（簡易・軽量） citeturn10search6
- I2Cdevlib（より低レベル/柔軟、DMP等も視野） citeturn2search8turn4search0
- MadgwickAHRS（AHRSアルゴリズムのラッパ） citeturn14view2

### 組込みC++の共通化
- Embedded Template Library（ETL, MIT）: 組込み向けコンテナ・アルゴリズム citeturn14view1

### サーボ（補足）
ESP32Servo系ライブラリは複数系統があり、Arduino-ESP32のバージョン追従の差があります。  
互換性が必要なら、Arduino-ESP32 v3系を明示しているESP32Servoフォークの利用を検討してください。 citeturn15search16turn15search1  
本実装は依存を減らすため、LEDCでサーボPWMを直接生成しています。

---

## 今後の拡張（次ステップ）

1. **速度推定（車輪エンコーダ）** の追加  
   直進保持は yaw のみだと速度変動に弱いので、速度ループ（PI）と組み合わせる

2. **TSD20の複数搭載**  
   前方だけでなく左右も持てば「壁沿い走行」「ライン復帰」がやりやすい

3. **RPi側のプロトコル実装**  
   Python/C++で同一ヘッダ仕様（payload構造体）を再現し、COBS+CRCで相互運用

4. 2D LiDAR/RPi側SLAMに合わせた、ESP32側の役割固定  
   - ESP32: 低遅延のモータ/サーボ制御、安全停止、基礎センサ集約
   - RPi: 認識・地図・経路計画・戦術（右/左）決定・速度目標

---

## ビルド・導入メモ

- `firmware/PLATFORMIO_SNIPPET.ini` を参考に、プロジェクトの `platformio.ini` に `lib_deps` と `lib_extra_dirs` を追記してください。 citeturn16search0turn16search1
- 外部ライブラリを `firmware/lib/external/` に固定する場合は、PlatformIOのローカルライブラリ探索に乗せる（`lib_extra_dirs`）のが扱いやすいです。 citeturn16search1turn16search7
----------------------------------------

----------------------------------------
File: docs/firmware/hils_guide.md
----------------------------------------
# HILS 運用ガイド（Guide）

このドキュメントは、HILSの設定・運用方法をまとめたガイドです。
運用時の注意点やトラブルシュートも含みます。

## 前提

- HILSは「アクチュエータ出力の観測経路」です
- `Config.h` の値を変更した場合は再ビルド/書き込みが必要です
- HILS出力は制御ループの同期呼び出しで発行されます

## 設定ファイル

設定は `firmware/src/config/Config.h` にあります。

### HILS設定

- `OUTPUT_MODE`
  - `0` = Hardware
  - `1` = Shadow
  - `2` = Hils
- `HILS_REPORT_TO_SERIAL`
- `HILS_REPORT_TO_BLE`

出力先の注意:

- BLE出力を使う場合は `BLE_ENABLED=true` が必要
- BLEは帯域が小さいため高頻度には向かない

## 出力値の意味

HILSで観測できる `throttle` と `steer` は、**最終指令値**です。

- `throttle`: `THROTTLE_MAX`/`THROTTLE_REVERSE` を反映済み
- `steer`: `STEER_MAX` を反映済み

入力（-1..1）の素値ではなく、実機に出す正規化済み値が出力されます。

## 運用パターン

### Shadowモード（実機+HILS）

実機を動かしながらHILS出力を同時に確認します。

```
OUTPUT_MODE = 1
HILS_REPORT_TO_SERIAL = true
```

手順:

1. 設定を変更しビルド/書き込み
2. シリアルモニタで `HILS` 行が出ることを確認
3. 実機動作とHILS出力が一致するか確認

### Hilsモード（実機出力なし）

実機出力を止め、HILS出力のみを確認します。

```
OUTPUT_MODE = 2
HILS_REPORT_TO_SERIAL = true
```

手順:

1. 設定を変更しビルド/書き込み
2. 実機が動かないことを確認
3. HILS出力のみが出ていることを確認

## 実運用フロー（詳細）

目的別に手順を分けて記載します。安全確認を優先してください。

### 事前準備

1. 配線確認
   - モータ/サーボが物理的に安全な状態か確認
   - Hilsモードの場合は車体が動かないことを確認
2. 出力経路の選択
   - Shadow: 実機+HILS観測
   - Hils: 実機停止+HILS観測
3. 出力先の選択
   - Serial: デバッグ向け
   - BLE: 近距離確認向け（帯域に注意）

### 設定（Config.h）

例: Shadow + Serial出力

```
OUTPUT_MODE = 1
HILS_REPORT_TO_SERIAL = true
HILS_REPORT_TO_BLE = false
```

例: Hils + Serial出力

```
OUTPUT_MODE = 2
HILS_REPORT_TO_SERIAL = true
HILS_REPORT_TO_BLE = false
```

### ビルド/書き込み

1. `Config.h` を更新
2. ファームウェアをビルド
3. ESP32へ書き込み

注意:

- 書き込み後に電源再投入が必要な場合がある

### シリアル接続とログ取得

1. シリアルモニタを起動
2. `HILS` 行が出ることを確認

保存例（外部ツールで保存）:

```
HILS 1234 0.120 -0.045
```

### Shadowモードの検証

1. 安全な環境で最小入力から開始
2. 実機の挙動とHILS値が一致するか確認
3. 必要に応じて記録を停止/再開

### Hilsモードの検証

1. 実機が動かないことを確認
2. HILS出力が継続して出ることを確認
3. 記録データを解析し、指令が想定通りか確認

### 解析・再生の基本

1. `HILS` 行を抽出
2. `now_ms` を基準に並べ、時系列として扱う
3. `throttle` と `steer` をグラフ化して挙動を確認

推奨:

- 高頻度運用は出力先を軽量にする（Serialログを抑制）
- 記録ファイルに実験条件（設定値）を併記する

## 出力フォーマット

### StreamSink

```
HILS <ms> <throttle> <steer>
```

例:

```
HILS 1234 0.120 -0.045
```

## 記録と解析

- `HILS ` プレフィックスで行を抽出して保存する
- `now_ms` を基準に時系列で並べ、後処理で再生する
- 高頻度化が必要ならバイナリ出力の追加を検討する

## ログとの併用

- HILS出力はテキストのため、LOGのテキスト出力と混在する
- 解析しやすくするには `HILS` 行だけをフィルタする
- 解析の精度を重視する場合はLOGテキストを減らす

## 運用上の注意点

- `OutputMode::Hils` は実機出力が無効になる
- HILS出力は副経路なので、Sink停止は制御に影響しない
- Sinkは最大3つまで
- 重い処理をHILS受信側に入れるとループに影響する
- 同期が必要なら時刻のずれを補正する仕組みを追加する

## 運用チェックリスト

- `OUTPUT_MODE` が意図通りか
- `HILS_REPORT_TO_SERIAL`/`HILS_REPORT_TO_BLE` が有効か
- シリアル/BLEが接続済みか
- 実機を動かす場合は安全確認済みか

## トラブルシュート

- HILSが出力されない
  - `OUTPUT_MODE` と `HILS_REPORT_TO_*` を再確認
  - Serial/BLEが初期化されているか確認
  - HILS出力を受け取る側が接続済みか確認
  - ログ出力で埋もれていないか確認
  - ボーレート/接続先ポートが正しいか確認

- 実機が動いてしまう
  - `OUTPUT_MODE` が `2 (Hils)` になっているか確認
  - 書き込み後に電源再投入したか確認
----------------------------------------

----------------------------------------
File: docs/slam/ros2_setup_v1.md
----------------------------------------
# ROS2 / SLAM 手順 v1（タスクA）

## 目的
- SLAM/可視化（RViz含む）環境を **再現可能** に用意する
- 別PC/別人でも同じ手順で地図生成できる状態にする
- bag 運用を含む標準I/Fを固定し、B/C の並行開発を可能にする

## 前提
- ROS2: Humble（推奨）
- 方式: Docker優先（OS差分を最小化）
- ホスト: **Ubuntuを主**、**Macも同等に対応**
- 入力: LiDARのログ（IPC/ログから変換）

---

## 期待する入力
- `sensor_msgs/LaserScan` 形式の bag を用意する
- 元データは `IPC_LIDAR_SCAN` から生成する

**変換の最小仕様**
- frame_id: `laser`
- angle_min/max: 0〜2π（または -π〜π）で統一
- range_min/max: LiDAR仕様に合わせる

---

## 手順（v1）

## 配置先（確定）
- Dockerfile/compose: `tools/ros2/`
  - `tools/ros2/Dockerfile`
  - `tools/ros2/compose.yml`
- 変換ツール: `tools/ros2/scripts/`
  - `tools/ros2/scripts/convert_ipc_lidar_to_rosbag.py`

### 1) Docker環境の用意
- `tools/ros2/` に Dockerfile/compose を配置する
- コンテナ内で `ros2` と `slam_toolbox` と `rviz2` を使用可能にする

**例（方針）**
```
docker build -t robo-racer-ros2 -f tools/ros2/Dockerfile .
docker run --rm -it -v $PWD:/ws robo-racer-ros2
```

#### GUI（RViz）を使う場合
**Ubuntu（X11）**
- `xhost +local:root`
- `-e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:rw`

**Mac（Docker Desktop + XQuartz）**
- XQuartz を起動し「接続を許可」を有効化
- `DISPLAY=host.docker.internal:0` を指定
- 必要に応じて `xhost + 127.0.0.1` を許可

### 2) bag の準備
- `training/data/` または `logs/` から bag を生成
- 変換ツールは `tools/` に追加する（v1では最小変換でOK）

### 3) slam_toolbox（オフライン）
- `slam_toolbox` の offline モードで地図生成
- 生成した地図は `docs/slam/maps/` に保存する

**例（方針）**
```
ros2 launch slam_toolbox offline_launch.py
ros2 bag play <bag_path>
ros2 run nav2_map_server map_saver_cli -f docs/slam/maps/track
```

---

## 再現性チェック（DoD）
- 別PCで同じ手順で map が生成できる
- 同じbagで同じ地図そのよが得られる（大きな差分がない）

---

## TODO（v1で確定する内容）
- `tools/ros2/` の Dockerfile/compose を追加
- bag 変換ツールの最小実装（`tools/ros2/scripts/convert_ipc_lidar_to_rosbag.py`）
- slam_toolbox のパラメータセット（scan_matcher など）
- RViz の起動手順（Ubuntu/Mac）を確定
----------------------------------------

----------------------------------------
File: docs/proto/log_transport.md
----------------------------------------
# UARTログ伝送アーキテクチャ（ESP32 -> RPi）

## 前提（2026-01-22 方針）

- ログはファイル保存し、RAMでもバッファリングする。
- ESP32は状態を極力持たず命令待機に寄せる。
- 非常停止（KILL/PANIC）を最優先する。

この文書は、現行の「Serial2 UART 制御／Bluepad32 手動入力」を保ちつつ、
**非ブロッキング志向・拡張可能なログ伝送**を統合する設計をまとめる。

---

## 目的

- 制御ループを絶対に止めない（ログは落ちても良い）。
- UARTストリーム上で堅牢に再同期できるフレーミングを採用する。
- type追加で拡張できる構造化ログを標準にする。
- RPi側で生ログを保存し、後から再解析可能にする。

---

## 現行実装との統合ポイント

- 制御は引き続き Serial2 UART を使用し、ログも同一UARTに混載する。
- Bluepad32 の手動入力は現行方針のまま（自律中は無視、KILLのみ有効）。
- KILL/PANIC は常に最優先で処理し、ログ送信よりも優先する。

---

## システム全体像

```
[ESP32]
  ControlTask (high)  ---->  log enqueue (drop OK)
  UartRxTask (high)   ---->  cmd store + log enqueue
  LogTxTask (low)     ---->  COBS + CRC -> Serial2

[UART: 921600 bps]

[RPi]
  seriald (sole owner)
    RX thread: decode + dispatch
    TX thread: cmd send
    log forward -> logd
  logd
    raw frame file + jsonl (optional)
```

---

## ESP32側: タスク分離（FreeRTOS）

### 1. ControlTask（最優先）

- UART受信済みコマンドを適用（Drive.setSpeed / setAngle）。
- TTL/kill/heartbeat でフェイルセーフ判定。
- 重要イベントは Logger に投げるだけ（I/O禁止）。

### 2. UartRxTask（高優先度）

- RPi -> ESP の受信フレームをデコード。
- CRC/len検証、typeディスパッチ。
- 受信イベント（CRC失敗など）をログ化。

### 3. LogTxTask（低優先度）

- ログ用リングバッファから取り出して UART 送信。
- `availableForWrite()` を見て小刻みに送る。
- 送れない場合はブロックせず drop（dropカウンタ加算）。

### 非ブロッキング原則

- `Logger::emit()` は O(1) で終了すること。
- ログI/Oは ControlTask から隔離すること。
- ログ送信の詰まりは **制御に影響させない**。

### 注意: 速度ランプのブロッキング

現状 `Engine::setSpeed()` は `delay()` を含むため制御ループを止める。
将来的には `SlewRateLimiter` による**非ブロッキング速度ランプ**へ移行すると、
ログ設計の価値が最大化する。

---

## RPi側: UART専用プロセス

### 推奨: seriald + logd

- **seriald**: UARTを唯一占有するプロセス。
  - RXスレッド: read -> COBS decode -> CRC verify -> type dispatch
  - TXスレッド: cmd queue -> write
  - ログは logd へ転送（UNIXドメインソケット等）
- **logd**: ファイル保存、JSONL生成、リアルタイム配信。

### 最小構成（今すぐ動かす）

- 同一プロセス内に2スレッド（RX/TX）を置く。
- 将来の保守性・リアルタイム性は seriald 分離が有利。

---

## フレーミングとパケット構造

### フレーミング: COBS + 0x00 終端

- UARTはバイトストリームなので境界が必要。
- COBSで `0x00` を排除し、終端 `0x00` でフレーム確定。
- 破損しても次の `0x00` から復帰できる。

### CRC

- CRC-16/CCITT-FALSE 推奨。
- CRCは末尾に置く（len分読んで一括検証）。

### ベースフレーム（COBS前の生データ）

| Field  | Size | 説明 |
| ------ | ---: | ---- |
| magic  | 2    | 固定 `0x4D 0x43` ("MC") |
| ver    | 1    | プロトコル版（例: 1） |
| type   | 1    | メッセージ種別 |
| flags  | 1    | bit0: ACK_REQ（要求側がACKを要求） |
| seq    | 2    | 送信側連番（ロス/順序判定） |
| len    | 2    | payload長 |
| payload| N    | typeごとの構造体 |
| crc16  | 2    | CRC16-CCITT-FALSE |

※ v1では `flags` の bit0（ACK_REQ）のみ使用。その他は予約（0固定）。

---

## type設計（最低限）

### ESP32 -> RPi

- `0x10` LOG: テキストログ（level + text）
- `0x11` STATUS: 状態（速度/ステア/fault/age）
- `0x80` ACK: ACK応答（payloadなし）

### RPi -> ESP32

- `0x01` DRIVE: 角度/速度/TTL/距離
- `0x02` KILL: 非常停止（最優先）
- `0x03` MODE_SET: MANUAL/AUTO 切替
- `0x04` PING: 生存確認（ACK応答）

---

## LOG payload（テキストログ）

| Field | Size | 説明 |
| ----- | ---: | ---- |
| level | 1    | ログレベル（0=TRACE..5=FATAL） |
| text  | N    | UTF-8 テキスト（可変長） |

※ 将来的に構造化ログへ拡張する場合は別typeで追加する。

## STATUS payload（状態通知）

| Field | Size | 説明 |
| ----- | ---: | ---- |
| seq_applied | 1 | 最後に適用した `DRIVE.seq`（下位8bit） |
| auto_active | 1 | 1=自律有効 |
| faults | 2 | bitfield（KILL/HB_TIMEOUT/TTL_EXPIRED/AUTO_INACTIVE） |
| speed_mm_s | 2 | 現在速度（i16 LE） |
| steer_cdeg | 2 | 現在ステア（i16 LE） |
| age_ms | 2 | 最終コマンドからの経過（u16 LE, 0xFFFFで飽和） |

## ACK（応答）

- 受信側は `flags & ACK_REQ` のとき **ACKを返す**。
- `ACK` は `type=0x80`、`payload_len=0`、`seq` は要求側の `seq` をそのまま返す。
- **PINGは常にACK**（`ACK_REQ` に依存しない）。ただし len!=0 は不正として ACK しない。

---

## Logger設計（ESP32側）

### 役割分離（現行）

- AsyncLogger: level + text をフレーム化して enqueue
- UartTx: LogTxTask側で送信

### 追記で増やすポイント

- 構造化ログを別typeで追加し、専用のencoderを用意

---

## 収集すべき最低ログ

### 制御コマンド系

- DRIVE_RX / DRIVE_APPLY / FAILSAFE_TTL / KILL

### モータ/ステア出力

- MOTOR_APPLY / STEER_APPLY

### 通信健全性

- UART_RX_ERR / LOG_DROP / LINK_STAT

### Bluetooth

- BT_CONN / MANUAL_IGNORED

---

## RPi側ログ保存フォーマット

1. **生フレーム保存**
   - COBS復号後のフレーム列をそのまま保存
   - 将来デコーダ差し替えが可能
2. **JSON Lines（拡張）**
   - 重要イベントのみJSON化して保存

`spdlog::async_logger` + ローテーションを推奨。

---

## UART帯域の目安

- **921600 bps**
- 低重要度ログはサンプリング（STATUSは20Hz、LINK_STATは1Hz）。

---

## 実装落とし込み（開始点）

### ESP32

- `firmware/src/comm/`
  - `mc_proto.*`, `UartTx.*`
- `firmware/src/log/`
  - `AsyncLogger.*`

### RPi

- `rpi/seriald/`（推奨）
- `rpi/logd/`

---

## 固定パラメータ

- `DEFAULT_ESP_BAUD = 921600`
- UARTは RPi 側で seriald が単独所有

---

## まとめ

- **制御最優先**、ログは drop して良い。
- **COBS + CRC + type-dispatch** が拡張の核。
- ESP32はタスク分離で非ブロッキング化。
- RPiは seriald/logd 分離で I/O を隔離。
----------------------------------------

----------------------------------------
File: docs/proto/overview.md
----------------------------------------
方針
* **Bluetooth（Bluepad32）は ESP32 に直結**
* **自律中は手動入力を受けない（介入は KILL のみ）**
* **ESP32 は “プロトコル中心”に拡張可能（type 追加で機能追加）**
* **低遅延かつ安定（フレーム化＋CRC、誤同期復帰が強い）**
**詳細なプロトコル仕様書（実装可能な粒度）**と、**ESP32 側の実装設計（ポリモーフィズム＝登録型ディスパッチ＋入力ソース差し替え可能）**

---

# 1. 用語・前提

* **RPi**：上位（自律・SLAM・経路・安全監視など）。ESP32へ制御命令送信。
* **ESP32**：下位（受信した命令を適用、フェイルセーフ、KILL）。
* **MANUAL**：ESP32のBluetoothゲームパッド入力（Bluepad32）。
* **AUTO**：RPiからUARTで送られる自律制御コマンド。
* **KILL**：緊急停止。**どのモードでも最優先**。解除は現状プロトコルでは行わない（再起動/ローカル操作）。

---

# 2. システム方針（最重要）

## 2.1 モードポリシー（確定）

* **AUTOモード（mode=AUTO）**：

  * Bluetooth 手動入力は **無視**
  * 介入できるのは **KILL のみ**（BT でも UART でも可）
* **MANUALモード（mode=MANUAL）**：

  * Bluetooth 手動入力を Drive に反映して良い
  * UART の DRIVE コマンドを受けても適用しない（受理のみ）

※この「自律中は手動無視」を成立させるため、**MODE_SET でモードを明示切り替え**します（後述）。

---

# 3. 通信プロトコル（UART）仕様

## 3.1 要求

* 低遅延
* 誤同期に強い（すぐ復帰）
* 拡張容易（type追加＝ハンドラ追加）
* CRCで破損検知
* 最新のみ採用（seq）
* 期限切れは停止（TTL）

## 3.2 フレーム方式：COBS + delimiter + CRC16

### 3.2.1 物理レイヤ

* UART（921600 bps）
* 8N1

### 3.2.2 フレーム境界

* **フレーム終端（delimiter）**：`0x00`
* 受信は `0x00` を見つけたら「1フレーム確定」とする

### 3.2.3 COBS

* `header + payload + crc16` を COBS エンコードし、最後に `0x00` を付与
* 受信側は `0x00` までを COBS デコードする

### 3.2.4 CRC

* CRC16-CCITT（多項式 0x1021, 初期値 0xFFFF 推奨）
* 対象：**header(MAGIC〜LEN) + payload**
* CRCは little-endian 2byte を末尾に付与

---

## 3.3 パケット構造

### 3.3.1 Header v1（固定 9 bytes）

| フィールド |      型 | 説明                       |
| ------- | -----: | --------------------------- |
| `magic` |   u8×2 | 固定 `0x4D 0x43` ("MC")     |
| `ver`   |     u8 | 現行は 1                     |
| `type`  |     u8 | メッセージ種別                |
| `flags` |     u8 | フラグ（共通）                |
| `seq`   | u16 LE | シーケンス（0-65535循環）      |
| `len`   | u16 LE | payload長（0..MAX_PAYLOAD）  |

**LE変換ルール（重要）**

* `seq` / `len` は **wire上は little-endian**。受信側は必ず変換して扱う。
* Pi/ESP32がともにlittle-endianでも、**仕様として rd16_le()/wr16_le() を通す**こと。
* “たまたま動く”実装を防ぐため、サンプルコードも変換込みで示す。

**flags（共通）定義**

* bit0: `ACK_REQ`（1=ACKが欲しい）
* bit1: `RESERVED`
* bit2: `RESERVED`
* bit3..7: 予約

> MANUAL/AUTO は flags では表しません。理由：あなたの確定方針が「mode=AUTO時は手動無視」なので、入力の“出所”は ESP32 内部のソース（BT）と UART（RPi）で明確に分離でき、flags に混ぜると事故るためです。

---

## 3.4 type 定義（v1）

| type | 名前              | 方向      | payload  | 目的                             |
| ---: | ---------------- | --------- | -------- | -----------------------         |
| 0x01 | `DRIVE`          | RPi→ESP   | 固定      | 操舵/速度/TTL                     |
| 0x02 | `KILL`           | RPi→ESP   | なし      | 即時停止（ラッチ）                |
| 0x03 | `MODE_SET`       | RPi→ESP   | 固定      | MANUAL/AUTO 切替                  |
| 0x04 | `PING`           | RPi→ESP   | なし      | 生存確認（ACK応答）                |
| 0x10 | `LOG`            | ESP→RPi   | 可変      | ログ（level + text）               |
| 0x11 | `STATUS`         | ESP→RPi   | 固定      | 状態通知（任意）                  |
| 0x80 | `ACK`            | ESP→RPi   | なし      | PING応答                          |

---

## 3.5 payload 定義

### 3.5.1 `MODE_SET` (type=0x03) payload（1 bytes）

| フィールド    |  型 | 説明                          |
| -------- | -: | --------------------------- |
| `mode`   | u8 | 0=MANUAL, 1=AUTO             |

**挙動**

* mode=1（AUTO）：以後、UARTの `DRIVE` を適用対象とする。BT入力は無視。
* mode=0（MANUAL）：以後、UARTの `DRIVE` は受理のみ。BT入力が適用対象。

> 自律中に手動を受けないための「唯一の切替」です。RPiが制御権を握っていることを明示します。

**v1 固定仕様**

* `len == 1` のみ許可。`len != 1` は無視（or NACK）。
* `reason` は v2 で追加する（例：`MODE_SET_EX` など）。

---

### 3.5.2 `DRIVE` (type=0x01) payload（8 bytes）

物理量寄りで固定し、後からPIDや車両スケールが変わっても仕様が安定するようにします。

| フィールド      |  型 | 単位    | 説明                                                |
| ------------- | --: | ------ | --------------------------------------------------- |
| `steer_cdeg`  | i16 | 0.01°  | 目標舵角（0中心、左+右- などは実装で統一）                |
| `speed_mm_s`  | i16 | mm/s   | 目標速度（符号付き。車体/モータ都合で上限は実装側でクランプ） |
| `ttl_ms`      | u16 | ms     | このコマンドの有効期限                                  |
| `distance_mm` | u16 | mm     | 将来拡張用（0なら無視）                                 |

**TTLの評価基準**

* ESP32 がこのフレームを **受理（CRC OK）した時刻 `t_rx_ms`** を起点に、

  * `now_ms - t_rx_ms > ttl_ms` なら失効 → STOP
* RPi時刻 `t_ms` は使わない（あなたの要望）

**distance_mm の扱い**

* v1では 0 以外でも “参照値”として保持して良い
* エンコーダ導入後に「距離到達で停止」へ拡張可能

---

### 3.5.3 `PING` (type=0x04) payload（0 bytes）

* len=0 固定（len!=0 は不正として無視）
* 受理したら `last_hb_ms=now` を更新（payloadは参照しない）
* 受理時に `ACK` を返す（payloadなし、headerのseqで応答）
* **PINGは常にACK**（`FLAG_ACK_REQ` に依存しない、ただし len!=0 は ACK しない）

運用メモ：
* RPi は **modeに関わらず** PING を送る（リンク監視目的）

**v2 で nonce を入れるなら** `PING_EX` を追加する。

---

### 3.5.4 `KILL` payload なし

* KILL受理：`kill_latched=true` にする（必ずラッチ）
* 解除は現状プロトコルでは行わない（安全のためローカル操作/再起動）

---

### 3.5.5 `ACK` (type=0x80) payload なし

* **ACK要求**：request側が `FLAG_ACK_REQ` を立てる
* **ACK応答**：`type=ACK`、`flags=0`、payloadなし
* headerの `seq` は受信フレームの `seq` と一致させる
* payloadは将来拡張用（現状は空）

---

### 3.5.6 `STATUS` (type=0x11) payload（10 bytes）

| フィールド         |  型 | 単位       | 説明                          |
| ---------------- | --: | -------- | ---------------------------------- |
| `seq_applied`    |  u8 | -        | 最後に適用した `DRIVE.seq`（下位8bit） |
| `auto_active`    |  u8 | -        | 1/0                                |
| `fault`          | u16 | bitfield | 故障/停止要因                        |
| `speed_now_mm_s` | i16 | mm/s     | 現在速度（暫定は指令値でも良い）       |
| `steer_now_cdeg` | i16 | 0.01°    | 現在舵角（暫定は指令値でも良い）        |
| `age_ms`         | u16 | ms       | 最終DRIVE受理からの経過       |

※ `seq_applied` は `seq` の下位8bitを載せる運用でも可。

**fault bitfield（v1案）**

* bit0: KILL_LATCHED
* bit1: HB_TIMEOUT
* bit2: TTL_EXPIRED
* bit3: AUTO_INACTIVE（MODE=MANUALなのにDRIVEが来ている等、運用監視）
* bit4..15: 予約

---

### 3.5.7 `LOG` (type=0x10) payload（可変長）

| フィールド |  型 | 説明 |
| ------ | -: | ---- |
| `level` | u8 | ログレベル（0=TRACE..5=FATAL） |
| `text`  | u8[N] | UTF-8テキスト |

* payloadの先頭1 byteが `level`、残りがテキスト
* テキストは **NUL終端しない**（`len - 1` バイトが本文）
* テキストは空でも可
* 構造化ログは別type（例: `LOG_EVENT`）で拡張する

---

## 3.6 タイムアウト・周波数（推奨値）

* RPi→ESP32 `DRIVE`：50〜200Hz
* `ttl_ms`：制御周期の2〜3倍（例：送信100Hzなら ttl=30〜50ms）
* `PING`：10〜50Hz
* `hb_timeout_ms`（ESP32内部）：200ms（暫定）
* `STATUS`：20Hz（必要なときだけ）

---

# 4. ESP32 制御ロジック仕様（安全優先順位）

制御ループ（例：200Hz = 5ms周期）で必ずこの順で評価します。

1. **KILL**：`kill_latched==true` → `Engine.stop()` + `Steer.center()`（または安全角）
2. **mode==AUTO のとき**：

   * `hb_timeout`（HB使うなら）→ STOP
   * `ttl_expired` → STOP
   * 有効なら `DRIVE` を適用
3. **mode==MANUAL のとき**：

   * Bluetooth入力を適用（ただし KILL 優先）

> これにより「自律中は手動無視（介入はKILLのみ）」がプロトコルレベルで崩れません。

---

# 5. ESP32 実装設計（拡張性＝type追加だけで機能追加）

あなたの現行ツリーを尊重し、最小の侵襲で移行できる形にします。

## 5.1 追加するコンポーネント（提案）

* `comm/mc_proto.*`：ヘッダ構造体、type enum、COBS/CRC/reader/writer
* `comm/registry.*`：type→handler 登録（登録型ディスパッチ）
* `comm/handlers/*.cpp`：DRIVE/MODE_SET/PING/KILL
* `comm/registry.h`：ControlState（mode/killed/targets/timers）
* `control/ControllerInput.*`：BT入力
* `hardware/Drive.*`：実際の駆動適用

## 5.2 “ポリモーフィズム”

組み込みで最も堅牢かつ軽いのは **登録型ディスパッチ（関数テーブル）**です。

* `HandlerFn handlers[256]`
* `register_handler(type, fn)`
* 追加コマンドは `handlers/new_type.cpp` を増やして登録するだけ

仮想関数でもよいですが、今回の要件（低遅延・コンパクト）なら関数テーブルが適します。

---

# 6. 参考実装（ESP32側の骨格コード）

以下は “仕様書を実装に落とすとこうなる” という最小骨格です。
（あなたのリポジトリ構造に合わせたパスは例です。実際に配置する際は `src/comm/` などに入れてください。）

## 6.1 Protocol 定義（例：`src/comm/mc_proto.h`）

```cpp
#pragma once
#include <stdint.h>

namespace proto {

static constexpr uint8_t VER = 1;
static constexpr size_t MAX_PAYLOAD = 64; // 必要に応じて

enum class Type : uint8_t {
  DRIVE    = 0x01,
  KILL     = 0x02,
  MODE_SET = 0x03,
  PING     = 0x04,
  LOG      = 0x10,
  STATUS   = 0x11,
  ACK      = 0x80,
};

enum : uint8_t {
  FLAG_ACK_REQ = 1u << 0,
};

#pragma pack(push, 1)
struct Header {
  uint8_t  magic[2];
  uint8_t  ver;
  uint8_t  type;
  uint8_t  flags;
  uint16_t seq_le;
  uint16_t len_le;  // little-endian on wire
};

struct ModeSetPayload {
  uint8_t mode;   // 0=MANUAL, 1=AUTO
};

struct DrivePayload {
  int16_t  steer_cdeg;   // 0.01 deg
  int16_t  speed_mm_s;   // mm/s
  uint16_t ttl_ms;
  uint16_t distance_mm;  // 0なら無視
};

struct LogPayload {
  uint8_t level;
  // uint8_t text[]; // UTF-8 text follows (variable length)
};

struct StatusPayload {
  uint8_t  seq_applied;
  uint8_t  auto_active;
  uint16_t fault;
  int16_t  speed_now_mm_s;
  int16_t  steer_now_cdeg;
  uint16_t age_ms;
};
#pragma pack(pop)

} // namespace proto
```

## 6.2 SafetyState（例：`src/control/SafetyState.h`）

```cpp
#pragma once
#include <stdint.h>

struct SafetyState {
  bool kill_latched = false;
  bool auto_active  = false;

  uint32_t last_hb_ms = 0;
  uint32_t hb_timeout_ms = 200;

  uint16_t fault = 0;

  enum FaultBits : uint16_t {
    KILL_LATCHED = 1u << 0,
    HB_TIMEOUT   = 1u << 1,
    TTL_EXPIRED  = 1u << 2,
    AUTO_INACTIVE= 1u << 3,
  };

  void updateFaults() {
    fault = 0;
    if (kill_latched) fault |= KILL_LATCHED;
    // HB_TIMEOUT, TTL_EXPIRED は判定側で立てる（瞬間値）
  }
};
```

## 6.3 DriveCommandStore（例：`src/control/DriveCommandStore.h`）

```cpp
#pragma once
#include <stdint.h>
#include "../comm/mc_proto.h"

struct DriveCommandStore {
  bool     has = false;
  uint16_t seq = 0;
  proto::DrivePayload sp{};
  uint32_t rx_ms = 0;

  void set(uint16_t s, const proto::DrivePayload& p, uint32_t now_ms) {
    has = true;
    seq = s;
    sp = p;
    rx_ms = now_ms;
  }

  bool ttlExpired(uint32_t now_ms) const {
    if (!has) return true;
    return (uint32_t)(now_ms - rx_ms) > (uint32_t)sp.ttl_ms;
  }

  uint16_t ageMs(uint32_t now_ms) const {
    if (!has) return 0xFFFF;
    return (uint16_t)(now_ms - rx_ms);
  }
};
```

## 6.4 Dispatcher（例：`src/comm/registry.h`）

```cpp
#pragma once
#include <stdint.h>
#include <stddef.h>

struct FrameView {
  const uint8_t* data; // points to Header
  size_t len;          // header+payload bytes (no crc)
};

struct Context; // forward

using HandlerFn = bool(*)(const FrameView&, Context&);

struct Dispatcher {
  HandlerFn table[256]{};

  void reg(uint8_t type, HandlerFn fn) { table[type] = fn; }

  bool dispatch(uint8_t type, const FrameView& f, Context& ctx) {
    auto fn = table[type];
    if (!fn) return false;
    return fn(f, ctx);
  }
};
```

## 6.5 Context（例：`src/comm/registry.h`）

```cpp
#pragma once
#include "../hardware/Drive.h"
#include "../control/SafetyState.h"
#include "../control/DriveCommandStore.h"

struct TxPort {
  // ACK/STATUS を返したくなった時に実装
  void sendAck(uint16_t seq);
};

struct Context {
  Drive& drive;
  SafetyState& safety;
  DriveCommandStore& autoCmd;
  TxPort& tx;
};
```

## 6.6 ハンドラ例：MODE_SET（例：`src/comm/handlers/ModeSetHandler.cpp`）

```cpp
#include "../mc_proto.h"
#include "../Dispatcher.h"
#include "../Context.h"
#include <string.h>

static inline const proto::Header* hdr(const FrameView& f) {
  return reinterpret_cast<const proto::Header*>(f.data);
}
static inline uint16_t rd16_le(uint16_t v_le) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  return v_le;
#else
  return (uint16_t)((v_le >> 8) | (v_le << 8));
#endif
}

bool handleModeSet(const FrameView& f, Context& ctx) {
  const auto* h = hdr(f);
  const uint16_t len = rd16_le(h->len_le);
  if (len < 1) {
    return true;
  }
  proto::ModeSetPayload p{};
  const size_t copy_len = (len >= sizeof(p) ? sizeof(p) : 1);
  memcpy(&p, f.data + sizeof(proto::Header), copy_len);

  ctx.safety.auto_active = (p.mode != 0);
  return true;
}
```

## 6.7 ハンドラ例：DRIVE（例：`src/comm/handlers/DriveHandler.cpp`）

```cpp
#include "../mc_proto.h"
#include "../Dispatcher.h"
#include "../Context.h"
#include "../../lib/common/Time.h"
#include <string.h>

static inline const proto::Header* hdr(const FrameView& f) {
  return reinterpret_cast<const proto::Header*>(f.data);
}
static inline uint16_t rd16_le(uint16_t v_le) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  return v_le;
#else
  return (uint16_t)((v_le >> 8) | (v_le << 8));
#endif
}

bool handleDrive(const FrameView& f, Context& ctx) {
  const auto* h = hdr(f);
  const uint16_t len = rd16_le(h->len_le);
  if (len != sizeof(proto::DrivePayload)) {
    return true;
  }

  proto::DrivePayload p{};
  memcpy(&p, f.data + sizeof(proto::Header), sizeof(p));

  const uint32_t now = mc::Time::ms();
  ctx.autoCmd.set(rd16_le(h->seq_le), p, now);
  return true;
}
```

## 6.8 ハンドラ例：KILL（例：`src/comm/handlers/KillHandler.cpp`）

```cpp
#include "../mc_proto.h"
#include "../Dispatcher.h"
#include "../Context.h"

static inline const proto::Header* hdr(const FrameView& f) {
  return reinterpret_cast<const proto::Header*>(f.data);
}
static inline uint16_t rd16_le(uint16_t v_le) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  return v_le;
#else
  return (uint16_t)((v_le >> 8) | (v_le << 8));
#endif
}

bool handleKill(const FrameView& f, Context& ctx) {
  const auto* h = hdr(f);
  const uint16_t len = rd16_le(h->len_le);
  if (len != 0) {
    return true;
  }
  ctx.safety.kill_latched = true;
  return true;
}
```

## 6.9 main の制御ループ（現行 CSV 受信を置換する指針）

あなたの `main.cpp` は、次の3ブロックに整理します：

1. `uart_rx_poll()`：Serial2 から受信し、フレーム抽出→ディスパッチ
2. `bt_poll()`：Bluepad32 で pad 更新（ただし mode=AUTO なら適用しない。KILLボタンだけは許可）
3. `apply_control()`：安全優先順位で Drive に反映→ `drive.control()`

（COBSフレーマやCRC実装は長くなるのでここでは割愛しましたが、仕様は上記の通りです。）

---

# 7. Bluetooth（手動）入力の扱い仕様

## 7.1 自律中は手動無視（ただしKILLは許可）

* `mode==AUTO`：

  * `pad.update()` はしてもよい（接続維持・状態確認）
  * 走行コマンド（steer/speed）は **適用しない**
  * ただし **特定ボタン（例：HOME/START長押し）でKILLを発火**するのは許可（“介入はKILLのみ”の要件に一致）

## 7.2 自律でないときは手動操作OK

* `mode==MANUAL`：

  * padから `Drive.setSpeed()`/`Drive.setAngle()` を更新して良い
  * `Drive` の timeout は手動でも更新される（安全停止）

---

# 8. 仕様上の重要な決め（ここは実装前に固定推奨）

以下は仕様書として固定してください。そうしないと“運用が揺れて事故る”典型ポイントです。

1. **KILL はラッチ**（必ず止まり続ける）
2. **KILL 解除は現状プロトコル外**（ローカル操作/再起動）
3. **TTL は ESP32 受理時刻基準**（RPi時刻は不要）
4. **MODE を明示切替**（MODE_SET で切替）
5. **mode=AUTO 中は手動入力を無視**（KILL以外は無視）
----------------------------------------

----------------------------------------
File: docs/proto/test_plan.md
----------------------------------------
# プロトコル テスト計画（ESP32 + RPi）

## 1. 対象範囲
現行の mc_proto 実装に対して以下を確認する。
- フレーミング（COBS + CRC16）
- ヘッダ検証
- typeごとのpayload仕様
- ESP32側ハンドラの挙動
- RPi側 Sender/seriald の挙動
- UART実機でのE2E

## 2. 現行プロトコルのパターン

### 2.1 フレーム形式
- 生フレーム: `Header + payload + crc16` を COBS エンコードし、末尾に `0x00` 区切り
- Header（9 bytes）
  - `magic[2] = 'M','C'`
  - `ver = 1`
  - `type = u8`
  - `flags = u8`（`ACK_REQ=0x01` のみ、他はv1未使用）
  - `seq = u16 LE`
  - `len = u16 LE`
- CRC16-CCITT（poly 0x1021, init 0xFFFF）を `Header + payload` に対して計算

### 2.2 type 定義（現行）
- RPi -> ESP32
  - `0x01 DRIVE`（len=8）
  - `0x02 KILL`（len無視）
  - `0x03 MODE_SET`（len>=1許容）
  - `0x04 PING`（len=0固定）
- ESP32 -> RPi
  - `0x10 LOG`（len>=1）
  - `0x11 STATUS`（len=10）
  - `0x80 ACK`（len=0、flags=0、seqをエコー）

### 2.3 payload 定義
- DRIVE（8 bytes）
  - `steer_cdeg: i16 LE`
  - `speed_mm_s: i16 LE`
  - `ttl_ms: u16 LE`
  - `distance_mm: u16 LE`
- MODE_SET（>=1 byte）
  - `mode: u8`（0=MANUAL, 1=AUTO）
  - `reason: u8`（任意、無視される）
- PING
  - payloadは空（len=0固定、len!=0は不正）
- KILL
  - payloadは無視（現在の実装）
- STATUS（10 bytes）
  - `seq_applied: u8`（last_seq下位8bit）
  - `auto_active: u8`
  - `faults: u16 LE`（bit0 KILL, bit1 HB_TIMEOUT, bit2 TTL_EXPIRED, bit3 AUTO_INACTIVE）
  - `speed_mm_s: i16 LE`
  - `steer_cdeg: i16 LE`
  - `age_ms: u16 LE`
- LOG（>=1 byte）
  - `level: u8 (0..5)`
  - `text: UTF-8文字列`（可変長、空でも可）

## 3. テスト戦略概要
- ユニット: codec / PacketReader / PacketWriter
- コンポーネント: ESP32ハンドラ、RPi Sender/seriald の挙動
- 統合: RPi内ループバック（seriald + Sender）
- HIL: 実UARTでESP32 <-> RPi

## 4. テストマトリクス（パターン一覧）

### 4.1 フレーミング / Codec（共通）
**正常系**
- COBSの往復（0x00含む入力）
- len=0 の最小フレーム
- len=MAX_PAYLOAD の最大フレーム
- 連続フレーム（バックトゥバック）

**異常系**
- CRC不一致
- COBSデコード失敗（code=0、切れた入力）
- magic不一致
- ver不一致
- len>MAX_PAYLOAD
- lenとpayload長の不一致
- encoded長オーバー

### 4.2 ヘッダ/flags
- FLAG_ACK_REQ 有効時に ACK を返すこと（PINGは常にACK）
- ACKフレームは `payload_len=0` かつ `flags=0` であること
- 未対応type受信時にクラッシュしないこと

### 4.3 RPi -> ESP32 type
**DRIVE**
- len=8 正常
- len!=8 エラー
- steer/speedのクランプ
- ttlのクランプ（最小/最大）
- distance保持
- last_seq/last_cmd_ms/expireの更新

**MODE_SET**
- len=1 mode=0 -> MANUAL
- len=1 mode=1 -> AUTO
- len=2 reason付き -> mode反映
- mode=2等の不正値 -> エラー

**PING**
- len=0 で last_hb_ms 更新 + ACK送信
- len!=0 は不正（last_hb_ms更新なし、ACKなし）

**KILL**
- len=0 で killed=true, cmd_expire=0
- len=2 でも同様に動作

### 4.4 ESP32 -> RPi type
**STATUS**
- len=10 検証
- seq下位8bit反映
- faultsビットの反映
- age_msの0xFFFFサチュレート

**LOG**
- len=1（textなし）で空ログ
- len>1でtext出力
- level範囲のクランプ（0..5）

**ACK**
- payload_len=0
- flags=0
- seqが要求側と一致

## 5. ESP32側テスト計画

### 5.1 ハンドラ単体（ホストビルド）
- Context/ControlState/Logger/UartTx をモック化
- DriveHandler: 各state更新とクランプ確認
- ModeHandler: mode切替・不正値エラー
- KillHandler: killラッチ/expire
- PingHandler: last_hb_ms更新、ACK enqueue

### 5.2 HIL統合
- UARTでフレーム送信
- STATUSを見て以下を確認
  - AUTOでDRIVEが反映される
  - TTL切れでTTL_EXPIRED
  - PING停止でHB_TIMEOUT
  - KILLでKILL_LATCHED

## 6. RPi側テスト計画

### 6.1 Codec拡張
- `test/rpi/proto/cpp/proto_tests.cpp` を拡張
  - max payload
  - multi-frame
  - resync
  - len不一致

### 6.2 Senderテスト
- auto_disabled時にDRIVE送信しない
- PING送信間隔
- MODE_SET送信

### 6.3 serialdテスト
- LOG payload（level+text）の表示
- STATUS表示
- IPC->UARTの透過転送

## 7. E2E（RPi <-> ESP32）

### 7.1 通常制御
1) MODE_SET(AUTO)
2) DRIVE 50-100Hz
3) STATUSでspeed/steer/age確認

### 7.2 フェイルセーフ
- DRIVE停止 -> TTL_EXPIRED
- PING停止 -> HB_TIMEOUT
- KILL送信 -> KILL_LATCHED

### 7.3 ログ
- ESP32ログ発火
- serialdでテキスト出力
- 制御ループが阻害されないこと

## 8. テスト配置案
- 既存: `test/rpi/proto/cpp/proto_tests.cpp`, `test/firmware/proto/cpp/proto_tests.cpp`
- 新規案: `test/firmware/comm/test_handlers.cpp`
- 新規案: `test/rpi/comm/test_sender.py`

## 9. 受け入れ条件
- ホスト側テストが全て通る
- HILでSTATUS/LOGの期待出力が得られる
- seriald転送に回帰がない
----------------------------------------

----------------------------------------
File: docs/proto/protocol_logging_plan.md
----------------------------------------
# プロトコルログ実装計画（ESP32 + RPi）

目的: 制御系を乱さずに UART プロトコルの送受信が正しいことを証明できるログを残す。  
対象: `docs/proto/overview.md` の UART プロトコル。

---

## 要件

- Serial2（制御UART）にテキストログを混ぜない。
- 低オーバーヘッド・ロス許容（制御優先）。
- RX/TX 成功と失敗理由（CRC/長さ/バージョン/未対応）を追える。
- RPi側で収集して後から解析できる。
- codec/フレーミング/異常系をテストで担保する。

---

## 設計概要

二段構えのログ:

1. **ローカル出力（ESP32 USB Serial / RPi stdout or file）**
   - 1秒毎の要約ログ（既定）
   - 必要時のみ詳細ログ（verbose）

2. **任意の統計フレーム（ESP32 -> RPi）**
   - デバッグ専用 `PROTO_STATS` を追加
   - 受信カウンタ・直近エラーを固定長で送る
   - 既存フレームと同様に安全に扱える

理由:
- ローカルログはUART2に影響しない。
- `PROTO_STATS` でESP32側の受信健全性をRPiで取得できる。

---

## ログ項目

詳細ログ（verbose時）:
- `RX_OK` type/seq/len/flags
- `RX_ERR` 原因（CRC/len/overflow/decode/ver）
- `TX_OK` type/seq/len/flags
- `TX_FAIL` type/seq
- `ACK` code/type_echo/seq_echo
- `STATUS` seq_applied/fault/age 等

要約ログ（1Hz既定）:
- 受信: `rx_ok`, `rx_crc`, `rx_len`, `rx_decode`, `rx_ver`, `rx_unsupported`
- 送信: `tx_ok`, `tx_fail`, `ack_ok`, `ack_err`, `status_rx`
- 直近: `last_rx_type/seq`, `last_tx_type/seq`, `last_err`

---

## ESP32 側 実装計画

1. `ProtoTrace` モジュール追加  
   - `firmware/src/comm/ProtoTrace.{h,cpp}`
   - API: `onRxFrame`, `onRxError`, `onTx`, `onAck`, `onStatus`, `tick()`
   - カウンタ/直近情報を保持

2. 既存パスへフック  
   - `PacketReader`: decode/CRC/len/overflowエラーを `onRxError`
   - `uart_rx_poll`: `kOk` で `onRxFrame`
   - `TxPort`: ACK/STATUS の送信成否を `onTx`

3. 出力  
   - USB `Serial` のみ使用（Serial2禁止）
   - 要約ログの間隔: `PROTO_TRACE_SUMMARY_MS`（既定 1000）
   - verbose は `PROTO_TRACE_VERBOSE` で切替

4. （必要なら）`PROTO_STATS` 実装  
   - `Protocol.h` に type追加
   - `ProtoStatsPayload` 定義
   - `TxPort::sendProtoStats` を要約間隔で送信

---

## RPi 側 実装計画

1. `ProtoTrace` モジュール追加  
   - `rpi/src/proto/Trace.{h,cpp}`
   - ESP32と同じカウンタ/要約

2. Sender/Receiver へフック  
   - `Sender::send` → `onTx`
   - `Sender::poll` → `onRxFrame` / `onRxError`
   - `ACK` / `STATUS` / `PROTO_STATS` を解析して詳細記録

3. 出力/保存  
   - CLIオプション想定: `--proto-log`, `--proto-log-file`
   - 既定は1Hz要約をstdout

---

## テスト計画（pytest方針）

### pytest（ホスト）
- `test/rpi/proto/test_proto_rpi_cpp.py` で g++ を呼び出し、
  `test/rpi/proto/cpp/proto_tests.cpp` をビルドして実行する。
- codec/reader/writer の基礎検証を C++ 側で行う。

### Integration（ホスト）
- `PacketWriter -> PacketReader` のループバック
- ランダム分割バイト列で再同期を検証

---

## 設定/フラグ

ESP32（`firmware/src/config/Config.h`）:
- `PROTO_TRACE_ENABLE`
- `PROTO_TRACE_VERBOSE`
- `PROTO_TRACE_SUMMARY_MS`

RPi:
- `PROTO_TRACE_VERBOSE=1`
- `PROTO_TRACE_LOGFILE=/path/to/log.txt`

---

## 実装順序

1. 両側に `ProtoTrace` とカウンタ追加（要約ログのみ）
2. 送受信フックを差し込み
3. verbose出力追加
4. 必要なら `PROTO_STATS` 追加
6. 実機UARTでログ取得・検証
----------------------------------------

----------------------------------------
File: docs/contracts/mc_bridge_v0.1.md
----------------------------------------
# mc_bridge 契約 v0.1（定義のみ）

## 目的
`seriald` の telemetry から受け取った mc_proto を ROS2 topic に変換し、
B/C が **実機なしでも ROS2 上で可視化/検証**できる状態を作る。
実装は次フェーズとし、**定義（契約）だけを先に凍結**する。

---

## 入力

### ソケット
- `seriald.telemetry.sock`（観測専用）
  - 既定: `/tmp/roboracer/seriald.telemetry.sock`

### フレーム種別
- UART 受信フレーム（ESP32→RPi）
- **RPi→ESP32 送信フレームのミラー**
  - DRIVE / MODE_SET / KILL 等
  - `/mc/drive_cmd` 可視化のため **必須**

---

## 出力（ROS2 topic）

### 必須
- `/mc/status`（`mc_msgs/Status`）
  - `mc::proto::StatusPayload` に対応
- `/mc/hils_state`（`mc_msgs/HilsState`）
  - `mc::proto::HilsStatePayload` に対応
- `/mc/log`（`mc_msgs/LogRecord`）
  - `mc::proto::LogPayload` の要約
- `/mc/drive_cmd`（`mc_msgs/DriveCmd`）
  - 送信ミラーされた `DrivePayload` を可視化

### 任意（デバッグ）
- `/mc/ack`（`mc_msgs/LogRecord` で代用可）

---

## QoS（最低限）
- `/mc/status` `/mc/hils_state` `/mc/drive_cmd`: `reliable`
- `/mc/log`: `best_effort`（ドロップ可、rate limit あり）

---

## タイムスタンプ/メタデータ
- `header.stamp`: **受信時刻**を付与（mc_protoに時刻が無い前提）
- `run_id`: 環境変数 or `/mc/run_id` を受け取り、`LogRecord.run_id` に **必ず** 付与
  - `run_id` が取得できない場合は `/mc/log` を **発行しない**（完全トレーサビリティ優先）
- `seq`: mc_proto の `seq` を各 message に含める

---

## 例外処理（最小）
- COBS/CRC decode 失敗 → `/mc/log` に WARN（`event=decode_error`）
- seq 飛び → `/mc/log` に WARN（`event=seq_gap`）
- 受信ゼロ継続 → `/mc/log` に INFO（`event=no_frame`）

---

## 受け入れ基準（定義）
- B/C が **質問なしで mc_bridge 実装を開始**できる具体度
- `/mc/drive_cmd` の出所（ミラー）と目的が明確
- エラー時の出力先が `/mc/log` に統一される
----------------------------------------

----------------------------------------
File: docs/contracts/min_spec_v0_1.md
----------------------------------------
# A側 最小仕様 v0.1（B/C 並行開発ブロッカー解除用）

## 目的
本ドキュメントは **インターフェース確定 → 実装計画 → 受け入れ基準** の順でまとめる。

---

## 0. ゴール定義（最小）

### Aが満たすべき必須条件
1. **インターフェース凍結（契約）**
   - `mc_proto`（フィールド・単位・時刻・seq運用・互換性）
   - UDS の役割分離（**制御系と観測系の分離**）
   - ログの最低限構造（後で rosbag / 学習データ化できる粒度）
2. **B/Cが“実機なし”で動かせる入力源**
   - HILS最小（Drive→Status 返却）またはログリプレイ
3. **ROS2開発基盤（Docker/Make導線/rosbag雛形/RViz）**
   - Ubuntu を主、Mac も同等に対応
   - bridge 実装前でも **ROS2側の型・運用規格が固まっている**

---

## 1. まず確定すべき「契約（Contract）」最小セット

### 1.1 `mc_proto` 契約（既存を仕様書化して凍結）
**凍結対象（v1）**
- Header（9 bytes）
  - `magic[2]='M','C'` / `ver=1` / `type` / `flags` / `seq_le` / `len_le`
- Type（最低限）
  - `DRIVE(0x01)`, `KILL(0x02)`, `MODE_SET(0x03)`, `PING(0x04)`
  - `LOG(0x10)`, `STATUS(0x11)`, `HILS_STATE(0x12)`, `ACK(0x80)`
- Payload（単位込みで固定）
  - `DrivePayload { steer_cdeg, speed_mm_s, ttl_ms_le, dist_mm_le }`
  - `StatusPayload { seq_applied, auto_active, faults, speed_mm_s, steer_cdeg, age_ms }`
  - `HilsStatePayload { timestamp, throttle_raw, steer_cdeg, flags }`
- **互換性ルール**
  - v1の拡張は **新Type追加のみ**（既存payloadを壊さない）
  - 既存payload変更が必要なら `ver` を上げる（v2）

**作業**
- `docs/contracts/mc_proto_v1.md` を作成して **コードから起こす**

---

### 1.2 UDS（IPC）契約：**制御(Write) と 観測(Read) を分離**
現状 `seriald` は「受信したら UART へすべて forward」。
観測専用クライアントが誤送信すると事故るため、**2系統に分離**する。

**最小仕様**
- **Control Socket（送信権あり）**
  - `/tmp/roboracer/seriald.sock`
  - ルール：**送信者は1プロセスのみ**（= racerd）
  - 例外：`serialctl` はデバッグ時のみ
- **Telemetry Socket（観測専用）**
  - `/tmp/roboracer/seriald.telemetry.sock`
  - ルール：`send()` したら **即切断**（または無視＋WARN）
  - UART受信フレームを **telemetryへbroadcast**

**注意**
- `/tmp/roboracer` を正とする。

**作業**
- `docs/contracts/ipc_uds.md` を作成
- `seriald` を **control/telemetry の2ソケット**に改修

---

### 1.3 ログ契約（後で使える最小構造）
**最小ログ要件（推奨）**
- JSONL 形式
- 1行に最低限：
  - `ts_us`（epoch か monotonic を固定）
  - `proc`（seriald / racerd / lidard …）
  - `level`
  - `event`（例: `rx_frame`, `tx_frame`, `plan`, `cmd`, `fault`）
  - `mc`（該当するなら: `type, seq, payload_summary`）
- **run_id**（走行セッションID）で横断可能にする

**作業**
- `docs/contracts/log_schema_v1.md` を作成
- run_id を必須にする

---

### 1.4 mc_bridge 契約（定義のみ）
**方針**
- **実装は次フェーズ**だが、B/C が並行開発できるよう **定義は今フェーズで凍結**する

**最小仕様**
- 入力: `seriald.telemetry.sock` の mc_proto フレーム
  - UART受信に加えて **RPi→ESP32 送信フレームも telemetry にミラー**（/mc/drive_cmd 可視化のため）
- 出力: ROS2 topic
  - `/mc/status` `/mc/hils_state` `/mc/log` `/mc/drive_cmd`
- 例外: decode/CRC/seq異常は `/mc/log` に WARN 出力

**作業**
- `docs/contracts/mc_bridge_v0.1.md` を作成

---

## 2. 実装計画（タスク分解）

### 2.1 P0: Telemetry Socket 追加（seriald改修）
**目的**：観測系（ROS/SLAM/学習）を安全に並行接続できる

**タスク**
1. `seriald` に `telemetry_ipc` を追加
2. listen path：
   - control: `/tmp/roboracer/seriald.sock`
   - telemetry: `/tmp/roboracer/seriald.telemetry.sock`
3. UART→UDS broadcast を
   - control clients にも流す（既存維持）
   - telemetry clients にも流す（新規）
4. **RPi→ESP32 送信フレームも telemetry にミラー**（DRIVE/MODE/KILL 可視化）
5. telemetry 側の `recv()` は **即切断**（送信禁止を強制）
6. docs に接続方針を明記

**受け入れ基準**
- racerd が control で運転中でも、観測系が telemetry で並行接続できる
- telemetry クライアントが誤送信しても車体へ流れない
- `/mc/drive_cmd` に **送信命令が可視化**される（telemetry ミラー前提）

---

### 2.2 P0: run_id 導入
**目的**：B/C が bag・学習データ・SLAMログを同一単位で扱える

**タスク**
1. 起動時に run_id を生成
2. 全ログに run_id を付与
3. 出力ディレクトリ規約を固定
   - `./logs/<run_id>/...`
   - `./bags/<run_id>/...`

**受け入れ基準**
- どのログ/成果物も run_id で束ねられる
- 再起動でも引き継げる（環境変数 or run_id.txt）

---

### 2.3 P0: ROS2開発基盤（Docker/Make導線/rosbag雛形/RViz）
**目的**：bridge 前でも ROS2 側の型と運用を固定する

**タスク**
1. `tools/ros2/` を追加（Ubuntu/Mac 両対応）
2. compose で RViz が動く形を標準化
3. Make導線（ros2-up/shell/build/bag-record/bag-play）
4. rosbag スクリプト（record/play）
5. RViz config 雛形（必要なら）

**受け入れ基準**
- Ubuntu/Mac で RViz が起動できる
- bag record/play の型が固定される

---

### 2.4 P1: ROS2メッセージ定義（mc_msgs）
**目的**：bridge 未実装でも msg/トピック仕様を固定

**タスク**
- `rpi/ros2_ws/src/mc_msgs/` に msg 定義を追加

**受け入れ基準**
- `/mc/status` `/mc/drive_cmd` 等が型付きで扱える

---

### 2.5 P1: HILS 最小（Drive→Status）
**目的**：実機なしで「命令→反映」を検証可能にする

**タスク**
- 擬似ESP32（sim）またはログリプレイで Status を生成
- `serialctl` で Drive を送ると Status が返る

**受け入れ基準**
- 実機なしで「コマンド→状態」が回る

---

## 3. 受け入れ基準（まとめ）
- **UDS分離**：control/telemetry が分離され誤送信が車体へ流れない
- **run_id**：ログ/バッグ/成果物が run_id で紐づく
- **ROS2基盤**：Ubuntu/Mac 両方で RViz が動く
- **mc_msgs**：ROS2トピックの型が固定される
- **HILS最小**：実機なしで Drive→Status が確認できる

---

## 4. 確認事項（最小）
1. ROS2 ディストロは Humble 固定でよいか
2. `ts_us` は epoch / monotonic のどちらを一次にするか（両方出す方針でも可）
----------------------------------------

----------------------------------------
File: docs/contracts/ros_topics_v0.1.md
----------------------------------------
# ROS Topics 契約 v0.1（凍結）

## 目的
B/C が実機なしで ROS2 側の実装を並行できるよう、topic/型/frame_id を最小で凍結する。

## フレーム（凍結）
- `base_link`
- `laser`
- `map/odom` は次フェーズで追加・凍結

## Topics（凍結）

### /scan
- 型: `sensor_msgs/msg/LaserScan`
- `header.frame_id`: **`laser` 固定**
- `angle_min/max`, `angle_increment`, `range_min/max` を必ず設定

### /tf_static
- 型: `tf2_msgs/msg/TFMessage`
- `base_link -> laser` の static transform を publish
- 変換値は `rpi/config/frames.yaml` で管理

### /mc/status
- 型: `mc_msgs/msg/Status`
- `mc::proto::StatusPayload` と意味一致

### /mc/drive_cmd
- 型: `mc_msgs/msg/DriveCmd`
- `mc::proto::DrivePayload` と意味一致

### /mc/log
- 型: `mc_msgs/msg/LogRecord`
- `run_id` は必須（`/mc/run_id` と一致）

### /mc/hils_state（推奨）
- 型: `mc_msgs/msg/HilsState`
- `mc::proto::HilsStatePayload` と意味一致

### /mc/run_id（運用補助）
- 型: `std_msgs/msg/String`
- QoS: `transient_local` 推奨
- bag/ログの run_id と一致させる

### /mc/bridge_diag（任意）
- 型: `diagnostic_msgs/msg/DiagnosticArray`
- bridge の decode/CRC 異常を通知

## 変更ルール
- v0.1 以降の変更は **追加のみ**（既存 topic/型の破壊的変更は禁止）
- 破壊的変更は v0.2 以降で再凍結する
----------------------------------------

----------------------------------------
File: docs/contracts/bag_ops_v0.1.md
----------------------------------------
# rosbag 運用契約 v0.1（凍結）

## 目的
Mac/RPi の双方で同一の記録・再生フローを固定し、学習/SLAM/可視化の前提を揃える。

## 保存規約
- 保存先: `training/data/bags/<run_id>/`
- `metadata.json` を **同階層に必ず生成**する

## run_id 規約
- 生成: `tools/ros2/scripts/run_id.sh`
- 形式: `YYYYMMDD_HHMMSS_<short>`（例: `20260201_123456_a1b2c3d4`）
- `/mc/run_id` と bag/ログの run_id は一致させる

## metadata.json（必須）
最低限のキー:
- `run_id`
- `git_sha`
- `host`
- `notes`
追加フィールドは可（例: `created_at`）。

## record（固定）
- 記録対象（必須）: `/scan`, `/tf_static`, `/mc/status`, `/mc/drive_cmd`, `/mc/log`
- 追加推奨: `/mc/hils_state`, `/mc/run_id`, `/tf`
- `tools/ros2/scripts/bag_record.sh` を使用する

## play（固定）
- `tools/ros2/scripts/bag_play.sh` を使用する
- `--clock` を有効化した再生を標準とする
----------------------------------------

----------------------------------------
File: docs/contracts/ipc_uds_v0.1.md
----------------------------------------
# IPC UDS 契約 v0.1（control/telemetry 分離）

## 目的
観測系（ROS/SLAM/学習）からの誤送信を防ぎ、制御と観測を安全に分離する。

## ソケット
### control
- 役割: **送信権あり**（制御系）
- 既定: `/tmp/roboracer/seriald.sock`
- 原則: **送信者は 1 プロセスのみ（racerd）**

### telemetry
- 役割: **観測専用（送信禁止）**
- 既定: `/tmp/roboracer/seriald.telemetry.sock`
- ルール: クライアントが `send()` した場合は **即切断**（または無視 + WARN）
- 複数クライアントの同時接続を許可する

## 配信内容
- UART 受信フレーム（ESP32 → RPi）を telemetry へ broadcast
- **RPi → ESP32 送信フレームも telemetry にミラー**（/mc/drive_cmd 可視化のため）

## 互換・移行
- `/tmp/roboracer/` を正とする
----------------------------------------

----------------------------------------
File: docs/planning/role_definitions_v1.md
----------------------------------------
# タスクA/B/C 定義書 v1

## 目的
A/B/C 表記の意味を固定し、タスク範囲の解釈違いを防ぐ。

## 共通方針
- A/B/C は**責務のグルーピング**であり、個人名ではない
- Interface Freeze（v1）を前提に並行開発する
- 変更は v2 として追記する

---

# A: インターフェース/テスト/HILS/ロギング

## タスク領域
- RPi↔ESP32 プロトコルの凍結と整合
- RPi内IPC/ログの契約化と共通化
- sim_esp32d を含む机上HILSと統合テスト

## 主要成果物（ドキュメント）
- `docs/interfaces/protocol_rpi_esp32_v1.md`
- `docs/interfaces/ipc_topics_v1.md`
- `docs/interfaces/ipc_payloads_v1.md`
- `docs/observability/logging_v1.md`
- `docs/testing/hils_v1.md`

## 主要成果物（実装）
- `shared/proto` の v1 型定義固定
- sim_esp32d（HILS代替）
- seriald/racerd 机上E2E

## 非対象（v1）
- ルールベース走行ロジックの詳細
- 学習データ/推論のパイプライン

---

# B: ルールベース（FTG）/ SLAM / セーフティ

## タスク領域
- LiDAR入力からの FTG 走行
- RPi内IPCでの LIDAR_SCAN/SUMMARY 連携
- 安全停止条件の強化（single-point/IMU 等）
- ROS2/SLAM の再現可能な運用手順

## 主要成果物（ドキュメント）
- `docs/planning/ftg_v1.md`
- `docs/slam/ros2_setup_v1.md`

## 主要成果物（実装）
- `lidard` のIPC publish
- `racerd` の FTG 統合（DRIVE_CMD生成）

## 非対象（v1）
- AI推論・学習パイプライン
- プロトコル/ログ契約の変更

---

# C: AI/データ/推論入口

## タスク領域
- 走行ログから dataset 生成
- imitation 学習パイプライン
- racerd への policy plugin（FTG/AI/Shadow切替）

## 主要成果物（ドキュメント）
- `docs/ml/dataset_schema_v1.md`
- `docs/ml/policy_plugin_v1.md`

## 主要成果物（実装）
- dataset 生成ツール
- 学習/評価の入口（make train/eval 等）

## 非対象（v1）
- ESP32ファームの安全制御
- ルールベース走行の詳細
----------------------------------------

----------------------------------------
File: docs/planning/lidar_received_eintr_status.md
----------------------------------------
# lidar_received EINTR 対応 状態管理

## 目的
- write_to_mem() の sem_wait() で EINTR を正しく処理し、共有メモリアクセスの破綻を防ぐ。

## ステータス
- [完了] write_to_mem() の sem_wait() を EINTR リトライ付きに変更

## メモ
- sem_wait() が中断された場合は再試行し、致命的エラー時のみ終了する。
----------------------------------------

----------------------------------------
File: docs/planning/bc_taskflow_implementation_status.md
----------------------------------------
# タスクB（ルールベース/SLAM/安全）・タスクC（AI/データ/推論入口） タスクフロー&実装計画 ステート管理

目的: タスクB（ルールベース/SLAM/センサー安全）とタスクC（AI/データ/推論入口）のタスクフローと実装計画の進行状況を追跡する。

## 状態凡例
- 未着手
- 進行中
- 完了
- 再検討
- 保留

## 進捗サマリ
- 作成日: 2026-01-27
- 更新日: 2026-01-29
- 対象ドキュメント: docs/planning/bc_taskflow_plan.md

## ステータス一覧

### ドキュメント作成
| 項目 | 状態 | メモ |
| --- | --- | --- |
| タスクB/タスクCタスクフロー&実装計画書の新規作成 | 完了 | docs/planning/bc_taskflow_plan.md を作成 |
| FTG実装計画（v1） | 完了 | docs/planning/ftg_v1.md を作成 |
| ROS2/SLAM手順（v1） | 完了 | docs/slam/ros2_setup_v1.md を作成 |
| Dataset schema（v1） | 完了 | docs/ml/dataset_schema_v1.md を作成 |
| Policy plugin 仕様（v1） | 完了 | docs/ml/policy_plugin_v1.md を作成 |
| IPC payload 定義（v1） | 完了 | docs/interfaces/ipc_payloads_v1.md を作成 |
| タスクA/B/C 定義書（v1） | 完了 | docs/planning/role_definitions_v1.md を作成 |

### タスクB（ルールベース/SLAM/安全）
| 項目 | 状態 | メモ |
| --- | --- | --- |
| FTGタスクフロー定義 | 進行中 | 入出力・周期・安全条件を明記 |
| LIDAR入力/IPC設計反映 | 進行中 | IPC topicはv1凍結仕様に合わせる |
| racerd ルールベース統合フロー | 進行中 | DRIVE TTL前提を固定 |
| セーフティ拡張（single-point/IMU） | 進行中 | ESP32責務優先 |
| ROS2/SLAM手順 | 進行中 | 再現可能な手順を優先 |

### タスクC（AI/データ/推論入口）
| 項目 | 状態 | メモ |
| --- | --- | --- |
| データ収集フロー定義 | 進行中 | ログ仕様v1を参照 |
| dataset schema 設計 | 進行中 | timestamp整列・欠損扱い |
| 学習パイプライン v0 | 進行中 | imitation優先 |
| policy plugin 仕様 | 進行中 | FTGフェイルセーフ必須 |
----------------------------------------

----------------------------------------
File: docs/planning/ros2_novnc_trap_status.md
----------------------------------------
# noVNC 起動スクリプトの trap/cleanup 改修ステータス

## 目的
- exec によるプロセス置換を避け、SIGTERM/EXIT 時に cleanup() が確実に実行される構成にする。
- コンテナ停止時の後始末を安定させる。

## 状態
| 項目 | 状態 | 日付 | メモ |
| --- | --- | --- | --- |
| 対象スクリプトの現状確認 | 完了 | 2026-02-01 | exec による trap 不達の確認 | 
| 子プロセス wait 構成へ変更 | 完了 | 2026-02-01 | exec を廃止し wait で終了管理 | 
| SIGTERM/INT の転送と終了コード整理 | 完了 | 2026-02-01 | 受信シグナルを子プロセスに転送 | 
| ステート更新 | 完了 | 2026-02-01 | 実装反映済み | 

## 進行メモ
- 対象: tools/ros2/scripts/novnc_start.sh
- exec を廃止し、子プロセスにシグナル転送 → wait で終了管理
----------------------------------------

----------------------------------------
File: docs/planning/ros2_param_validation_status.md
----------------------------------------
# ROS2 ノード起動時のパラメータ検証ステータス

## 目的
- rclpy ノードの __init__ 内で不正パラメータが検出された場合に、確実にプロセスを終了させる。
- 誤設定時に rclpy.spin(node) が待ち続ける状態を防ぐ。

## 状態
| 項目 | 状態 | 日付 | メモ |
| --- | --- | --- | --- |
| 対象ノードの現状確認 | 完了 | 2026-02-01 | __init__ のパラメータ検証と main() の終了経路を確認 | 
| 例外送出による終了経路の実装 | 完了 | 2026-02-01 | 不正時は例外送出＋main() で終了 | 
| 例外時のログ/シャットダウン整理 | 完了 | 2026-02-01 | rclpy.shutdown() を確実に呼ぶ | 
| mc_tf_static のパラメータ検証/終了経路整理 | 完了 | 2026-02-01 | 空フレーム検出時に例外送出、main() で終了 | 
| ステート更新 | 完了 | 2026-02-01 | 実装反映済み | 

## 進行メモ
- 対象: rpi/ros2_ws/src 配下の rclpy ノード
- 参考: ROS 2 rclpy パラメータ運用
- mc_demo_pub / mc_bridge は不正パラメータで例外送出し、main() で終了するように変更済み
----------------------------------------

----------------------------------------
File: docs/planning/ros2_env_status.md
----------------------------------------
# ROS2 開発環境（Docker/Make/bag）ステータス（担当A）

## 目的
ROS2（RViz含む）を Ubuntu/Mac の Docker で再現可能にし、B/C が bag 前提で並行開発できる基盤を作る。

## 範囲（Aの追加責務）
- ROS2 Docker 環境（Ubuntu/Mac 対応）
- RViz 実行導線
- rosbag2 record/play の雛形
- topic/bag 規格（ICDのROS版）

## ステータス
| 項目 | 状態 | 期限 | 備考 |
| --- | --- | --- | --- |
| 既存 docs の精査 | 完了 | 2026-02-01 | ros2_setup_v1.md を確認 |
| docs 修正（A責務化・RViz・Mac対応明記） | 完了 | 2026-02-01 | ros2_setup_v1.md 更新 |
| tools/ros2 Dockerfile/compose 追加 | 完了 | 2026-02-03 | Ubuntu/Mac 両対応 |
| rosbag2 record/play スクリプト雛形 | 完了 | 2026-02-03 | run_id を付与 |
| Make 導線（ros2-up/shell/build/record/play） | 完了 | 2026-02-04 | 既存Makeと干渉しない |
| docs/ros2/{dev_env,bag_ops,topic_spec}.md | 完了 | 2026-02-04 | B/Cが質問なしで進める |
| rpi/ros2_ws/mc_msgs（msg雛形） | 完了 | 2026-02-04 | topic_spec に対応 |
| docs/ros2/dev_env.md の DISPLAY 注意追記 | 完了 | 2026-01-31 | Ubuntu/Mac の差分を強調 |

## 残タスク（順序付きTODO）
| 順番 | タスク | 状態 | 期限 | 依存 | 根拠 | 備考 |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | tools/ros2 Dockerfile/compose 追加 | 完了 | 2026-02-03 | - | 実行環境が先に必要（基盤） | Ubuntu/Mac 両対応 |
| 2 | docs/ros2/dev_env.md | 完了 | 2026-02-03 | 1 | 環境が固まらないと手順が書けない | RViz手順含む |
| 3 | docs/ros2/topic_spec.md | 完了 | 2026-02-03 | - | B/Cを早期に動かすため | ICDのROS版 |
| 4 | rosbag2 record/play スクリプト雛形 | 完了 | 2026-02-04 | 1 | 実行環境が必要 | run_id付与 |
| 5 | docs/ros2/bag_ops.md | 完了 | 2026-02-04 | 4 | スクリプトが決まらないと運用が書けない | 命名/保存規則 |
| 6 | Make 導線（ros2-up/shell/build/record/play） | 完了 | 2026-02-04 | 1 | Docker環境が必要 | 既存Makeと干渉しない |
| 7 | rpi/ros2_ws/mc_msgs（msg雛形） | 完了 | 2026-02-04 | 3 | topic_spec と整合させる | Drive/Status/Hils/Log |
| 8 | docs/ros2/dev_env.md の DISPLAY 注意追記 | 完了 | 2026-01-31 | 2 | RViz の起動失敗を防ぐ | compose のデフォルト注意 |

## 進行メモ
- 2026-02-01: ros2_setup_v1.md を精査開始。
- 2026-02-01: ros2_setup_v1.md をA責務化＋RViz＋Mac対応で更新。
- 2026-02-01: tools/ros2（Docker/compose）実装を開始。
- 2026-02-01: tools/ros2 と docs/ros2、Make導線、bagスクリプトまで実装完了。
- 2026-02-01: rpi/ros2_ws/mc_msgs の雛形を追加。
- 2026-01-31: DISPLAY のプラットフォーム差分を docs に追記する作業を開始。
- 2026-01-31: docs/ros2/dev_env.md に DISPLAY 事前設定の注意を追記。
----------------------------------------

----------------------------------------
File: docs/planning/p0_parallelization_status.md
----------------------------------------
# P0 並走安全化・ROS 実データ化 ステータス（Day2-3）

## 目的
- Day1で凍結したI/Fを **安全に並走できる状態**へ引き上げる。
- 観測の誤送信リスクを遮断し、ROSへ実データを通す入口を作る。

## 前提
- `/tmp/roboracer` を正とする。
- `docs/contracts/ipc_uds_v0.1.md` / `mc_bridge_v0.1.md` / `ros_topics_v0.1.md` の凍結内容に準拠する。

## ブランチ方針（分割）
- P0-1: `feat/seriald-telemetry-split`
- P0-2: `feat/mc-bridge-telemetry`
- P0-3: `feat/lidar-bridge-scan`
- 統合: `integration/p0-parallelization`（必要なら）

## 依存関係
- P0-1 → P0-2（telemetry.sock が前提）
- P0-3 は P0-1 非依存（ROS / SHM 側のみ）

## ステータス
| 項目 | 状態 | 期限 | 備考 |
| --- | --- | --- | --- |
| P0-1 seriald control/telemetry 分離 | 実装済み（未検証） | 2026-02-03 | 互換パス維持・送信遮断・ミラー配信 |
| P0-2 mc_bridge 実働化 | 実装済み（未検証） | 2026-02-04 | telemetry decode → /mc/* publish |
| P0-3 lidar_bridge 追加 | 実装済み（未検証） | 2026-02-04 | SHM → /scan publish |

## P0-1 詳細（seriald 分離）
- 対象: `rpi/apps/seriald/src/main.cpp`, `rpi/apps/seriald/config/Config.h` ほか
- 受け入れ基準（DoD）
  - control 運転中でも telemetry に複数クライアント接続できる
  - telemetry からの送信が UART に **一切流れない**
  - 既存 `hils-local` / 机上E2E が壊れない

## P0-2 詳細（mc_bridge 実働）
- 対象: `rpi/ros2_ws/src/mc_bridge`
- 受け入れ基準（DoD）
  - telemetry.sock から STATUS/DRIVE/HILS を decode して ROS publish
  - `/mc/run_id` が無い場合 `/mc/log` を publish しない
  - decode/CRC 失敗カウント or ログを出す

## P0-3 詳細（lidar_bridge）
- 対象: `rpi/ros2_ws/src/lidar_bridge`（新規）
- 受け入れ基準（DoD）
  - `tools/ros2/rviz/default.rviz` で `/scan` 表示できる
  - `base_link -> laser` の `/tf_static` と組み合わせて破綻しない

## 進行メモ
- 2026-02-01: ステータス管理を開始。P0-1〜P0-3 をブランチ分割で実装する方針を確定。
- 2026-02-01: seriald を control/telemetry に分離（送信遮断・ミラー配信・/tmp 互換listen）。
- 2026-02-01: mc_bridge に telemetry decode を追加（/mc/status /mc/drive_cmd /mc/hils_state /mc/log）。
- 2026-02-01: lidar_bridge を追加（/dev/shm/lidar_scan → /scan）。
----------------------------------------

----------------------------------------
File: docs/planning/mc_bridge_status.md
----------------------------------------
# mc_bridge 定義・実装ステータス（タスクA）

## 目的
mc_bridge の **契約（定義）を先に凍結**し、B/C が並行開発できる状態を作る。
実装は次フェーズで行う。

## 範囲（今フェーズ）
- `docs/contracts/mc_bridge_v0.1.md` の作成
- `/mc/drive_cmd` の出所（telemetry ミラー）を仕様化
- 既存 docs への反映（最小仕様/ROS2 topic spec）

## ステータス
| 項目 | 状態 | 期限 | 備考 |
| --- | --- | --- | --- |
| docs/contracts/mc_bridge_v0.1.md | 完了 | 2026-01-31 | 定義のみ（実装は次フェーズ） |
| docs/contracts/min_spec_v0_1.md 更新 | 完了 | 2026-01-31 | telemetry ミラー前提を反映 |
| docs/ros2/topic_spec.md 更新 | 完了 | 2026-01-31 | /mc/drive_cmd 出所を明記 |
| rpi/ros2_ws/src/mc_bridge 実装 | 実装済み（未検証） | 2026-02-05 | telemetry decode と /mc/* publish を追加 |
| RunIdCache スレッドセーフ化 | 完了 | 2026-01-31 | MultiThreadedExecutor 対応 |
| demo_period_sec ガード追加 | 完了 | 2026-01-31 | 0 以下の無効値を防止 |

## 残タスク（順序付きTODO）
| 順番 | タスク | 状態 | 期限 | 依存 | 根拠 | 備考 |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | mc_bridge 契約の凍結 | 完了 | 2026-01-31 | - | B/C が並行実装できる最小ブロッカー解除 | docs/contracts/mc_bridge_v0.1.md |
| 2 | /mc/drive_cmd 出所の仕様化 | 完了 | 2026-01-31 | 1 | 可視化/デバッグの前提を固定するため | telemetry ミラー前提 |
| 3 | mc_bridge 実装 | 実装済み（未検証） | 2026-02-05 | 1,2 | 仕様凍結後に実装すべき | telemetry decode を追加 |
| 4 | RunIdCache スレッドセーフ化 | 完了 | 2026-01-31 | 3 | Executor 複数スレッド時の競合防止 | Lock 導入 or 単一スレッド前提の明記 |
| 5 | demo_period_sec ガード追加 | 完了 | 2026-01-31 | 3 | 無効値でのタイマー起動を防ぐ | warning を出して停止 |

## 進行メモ
- 2026-01-31: mc_bridge 定義のステータス管理を開始。
- 2026-01-31: mc_bridge v0.1 定義を作成し、/mc/drive_cmd の出所を明記。
- 2026-01-31: mc_bridge の run_id ガード骨組みを追加（/mc/log publish 前のガード）。
- 2026-01-31: RunIdCache に Lock を導入し、run_id の参照/更新をスレッドセーフ化。
- 2026-01-31: demo_period_sec の無効値ガード追加に着手。
- 2026-01-31: demo_period_sec が 0 以下のとき demo_log を無効化するガードを追加。
- 2026-02-01: telemetry.sock を読んで /mc/status /mc/drive_cmd /mc/hils_state /mc/log を publish。
----------------------------------------

----------------------------------------
File: docs/planning/interface_freeze_status.md
----------------------------------------
# インターフェース凍結・実装ステータス（タスクA）

## 目的
RPi↔ESP32の既存プロトコル/安全設計を契約として凍結し、
タスクB（ルールベース/SLAM/安全）とタスクC（AI/データ/推論入口）が車体なしで並行開発できる状態を作る。

## 範囲（Day1成果物）
- v1インターフェース文書の整備（RPi↔ESP32 / IPC / Logging / HILS）
- `shared/proto` にIPC用メッセージ型（v1）を追加
- RPi側 Logger API の一本化（mc_core へ統合）

## ステータス
| 項目 | 状態 | 期限 | 備考 |
| --- | --- | --- | --- |
| docs/interfaces/protocol_rpi_esp32_v1.md | 完了 | 2026-01-27 | 既存仕様の凍結版作成 |
| docs/interfaces/ipc_topics_v1.md | 完了 | 2026-01-27 | IPCトピック定義の凍結 |
| docs/interfaces/ipc_payloads_v1.md | 完了 | 2026-01-29 | IPC payload 定義の凍結 |
| docs/observability/logging_v1.md | 完了 | 2026-01-27 | Logger/LogRecord契約化 |
| docs/testing/hils_v1.md | 完了 | 2026-01-27 | HILS v1の要件整理 |
| shared/proto: IPCメッセージ型追加 | 完了 | 2026-01-27 | v1型の追加・固定 |
| RPi Logger API 統一 | 完了 | 2026-01-27 | serialdをmc_coreへ |

## 残タスク（順序付きTODO）
| 順番 | タスク | 状態 | 期限 | 依存 | 根拠 | 備考 |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | sim_esp32d（HILS代替）実装 | 完了（未検証） | 2026-01-30 | - | 机上E2Eとfault injectionの前提になるため先行 | DRIVE→STATUS/TTL/KILL/AUTO再現（ビルド確認済み） |
| 2 | proto/ログ単体テスト拡張 | 完了（未検証） | 2026-01-31 | - | 仕様固定の回帰防止を早期に確保するため | LogRecord往復/境界条件（実装済み） |
| 3 | 統合テスト（seriald + sim_esp32d + racerd） | 完了（未検証） | 2026-02-01 | 1 | sim_esp32d完成後に机上E2Eを成立させるため | 最小E2E（テスト実装済み） |
| 4 | HILS fault injection（遅延/欠損/CRC不正） | 完了（未検証） | 2026-02-02 | 1 | sim_esp32dがあれば再現可能、早期に安全検証 | sim_esp32dで再現（オプション追加） |
| 5 | ローカル実行環境（docker or make target） | 完了（未検証） | 2026-02-02 | 1 | 物理アクセス不要の開発を確立するため | make hils-local 追加 |
| 6 | Metricsログ（CPU/温度/メモリ） | 完了（未検証） | 2026-02-03 | - | 後続の閾値設定の前提となるため | metricsd追加（IPC送信/ログ） |
| 7 | CI整備（unit + integration） | 完了（未検証） | 2026-02-04 | 2,3 | unit/integrationが揃った後に常時実行へ | GitHub Actions追加 |
| 8 | systemd運用・ログローテ手順 | 完了 | 2026-02-05 | 5 | 実行環境が固まってから運用手順を確定 | docs/ops/systemd_v1.md |
| 9 | 性能監視の閾値設定（温度/CPU） | 完了 | 2026-02-05 | 6 | メトリクス取得後に閾値を決めるため | docs/ops/monitoring_thresholds_v1.md |

## 進行メモ
- 2026-01-27: ステータス管理開始。v1ドキュメント作成完了。
- 2026-01-27: IPCメッセージ型追加とLogger統一まで完了。
- 2026-01-27: 残タスクの順序付きTODOを定義。
- 2026-01-29: sim_esp32d 実装を開始。
- 2026-01-29: IPC payload 定義（v1）を追加。
- 2026-01-29: sim_esp32d 実装完了（未検証）。
- 2026-01-29: sim_esp32d ビルド確認、机上E2E統合テストの設計に着手。
- 2026-01-29: 机上E2E統合テストを実装開始。
- 2026-01-29: proto/ログ単体テストの拡張を開始。
- 2026-01-29: proto/ログ単体テスト拡張を実装完了（未検証）。
- 2026-01-29: 机上E2E統合テストを実装完了（未検証）。
- 2026-01-29: HILS fault injection オプションを追加（未検証）。
- 2026-01-29: make hils-local を追加しローカル実行手順を用意（未検証）。
- 2026-01-29: metricsd を追加（未検証）。
- 2026-01-29: CI（unit + integration）を追加（未検証）。
- 2026-01-29: systemd/ログローテ手順を文書化。
- 2026-01-29: 性能監視の閾値を文書化し metricsd に反映。
----------------------------------------

----------------------------------------
File: docs/planning/ftg_v1.md
----------------------------------------
# FTG 実装計画 v1（タスクB）

## 目的
- LiDAR入力から **安全かつ決定論的** に舵角/速度を生成する
- TTL前提の安全設計に合わせて **一定周期で DRIVE_CMD を生成**する

## 正本/参照
- IPCトピック: `docs/interfaces/ipc_topics_v1.md`
- IPC payload定義: `docs/interfaces/ipc_payloads_v1.md`
- RPi↔ESP32プロトコル: `docs/proto/overview.md`

---

## 入力
- `IPC_LIDAR_SUMMARY`（10-50Hz）
- `IPC_LIDAR_SCAN`（5-20Hz、補助）
- `IPC_VEHICLE_STATUS`（10-50Hz）
- `IPC_IMU_SAMPLE`（50-200Hz、任意）

**優先順位**
1. `LIDAR_SUMMARY` があればそれを使用
2. 無い場合は `LIDAR_SCAN` から gap を計算

---

## 出力
- `IPC_DRIVE_CMD`（20-100Hz）
  - `steer_cdeg`, `speed_mm_s`, `ttl_ms`
  - `source=SOURCE_FTG`

**TTL/周期**
- 送信周期: 20-50ms（=20-50Hz）
- `ttl_ms`: 送信周期の2-3倍（例: 50ms周期なら ttl=100-150ms）

---

## 処理フロー（決定論）
1. **入力スナップショット**
   - 最新の `LIDAR_SUMMARY` もしくは `LIDAR_SCAN` を固定
   - `VEHICLE_STATUS` の `auto_active` / fault を確認

2. **前処理**
   - 距離0や閾値未満点を除外
   - 角度範囲を `PROCESS_ANGLE_MIN/MAX` に制限

3. **gap抽出**（scanを使う場合）
   - 一定距離以上の連続領域をgapとして抽出
   - gap中心の角度を `best_heading_cdeg` とする

4. **操舵・速度決定**
   - `steer_cdeg = clamp(best_heading_cdeg)`
   - `speed_mm_s` は距離や角度に応じて減速

5. **安全判定**
   - confidenceが低い/障害物が近い場合は `speed_mm_s=0`
   - AUTOでない場合は **出力しない**（または0指令）

6. **平滑化**
   - 舵角・速度にスルーレート制限を適用

---

## パラメータ（v1）
`rpi/src/config/Config.h` のデフォルト値を基準とする。

| パラメータ | 目的 | 既定値/根拠 |
| --- | --- | --- |
| `PROCESS_ANGLE_MIN_DEG` | 走行視野の左限 | -70.0 deg |
| `PROCESS_ANGLE_MAX_DEG` | 走行視野の右限 | 70.0 deg |
| `SPEED_MM_S_MAX` | 速度上限 | 2000 mm/s |
| `STEER_CDEG_MAX` | 舵角上限 | 3000 cdeg |
| `AUTO_TTL_MS` | TTL既定 | 100 ms |

**追加パラメータ（FTG側で定義）**
- `min_clearance_mm`（gap判定閾値）
- `slowdown_distance_mm`（減速開始距離）
- `stop_distance_mm`（停止距離）
- `steer_slew_cdeg_per_s`（舵角スルーレート）
- `speed_slew_mm_s2`（速度スルーレート）

---

## 失敗時の挙動
- gap無し/低信頼 → `speed_mm_s=0`、`steer_cdeg=0`
- 入力欠損が一定期間続く → **STOP** を維持
- `VEHICLE_STATUS` に fault が立っている場合は **保守的な停止**

---

## DoD
- 동일入力で**決定論的**に同じ出力が出る
- 20-50ms周期で `DRIVE_CMD` を生成できる
- TTLが常に有効（失効前に更新）
- `LIDAR_SUMMARY` あり/なし両方で動作

---

## テスト
- 単体: 既知のscan/summary入力に対して出力が固定
- 統合: sim_esp32d + seriald + racerd で机上E2E
----------------------------------------

----------------------------------------
File: docs/planning/telemetry_tcp_bridge_status.md
----------------------------------------
# telemetry TCP ブリッジ 状態管理

## 目的
- RPi 上の `seriald.telemetry.sock` を TCP 経由で PC へ配信し、
  PC 側の `mc_bridge` が実データを受け取れるようにする。
- 観測専用の安全性（送信遮断）を TCP でも維持する。

## スコープ
- RPi: `seriald` に telemetry TCP 配信を追加（送信不可）
- PC: `mc_bridge` に TCP 入力オプションを追加
- ドキュメント: 運用メモとテスト手順を追加

## 仕様（暫定）
- RPi 側: `seriald` に `--telemetry-tcp-port` を追加
  - デフォルト: 5001
- TCP: `SOCK_STREAM` で接続を受け、
  - 受信（POLLIN）は即切断（telemetry送信禁止）
  - 送信は telemetry と同じフレームを配信
- PC 側: `mc_bridge` に `telemetry_tcp_host` / `telemetry_tcp_port`
  - 指定時は TCP を優先
  - 未指定時は従来の UDS を使用

## ステータス
| 項目 | 状態 | 期限 | 備考 |
| --- | --- | --- | --- |
| seriald: telemetry TCP 配信追加 | 実装済み（未検証） | 2026-02-03 | 送信遮断・複数接続対応 |
| mc_bridge: TCP 入力追加 | 実装済み（未検証） | 2026-02-03 | UDS fallback を維持 |
| 運用メモ/テスト手順更新 | 未着手 | 2026-02-03 | docs/planning に追記 |

## 進行メモ
- 2026-02-03: 状態管理を開始。
- 2026-02-03: seriald に `--telemetry-tcp-port` を追加。
- 2026-02-03: mc_bridge に `telemetry_tcp_host/port` を追加。
----------------------------------------

----------------------------------------
File: docs/planning/bc_taskflow_plan.md
----------------------------------------
# タスクB（ルールベース/SLAM/安全）・タスクC（AI/データ/推論入口） タスクフロー & 実装計画（10日版）

## 目的
タスクB（ルールベース/SLAM/センサー安全）とタスクC（AI/データ/推論入口）の
**タスクフロー**と**実装計画**を明文化し、
Interface Freeze 後に**並行開発**できる状態を作る。

## 前提となる契約（Interface Freeze）
以下を**契約（v1）として凍結**し、タスクB/タスクCはこの前提で実装する。

- RPi↔ESP32 プロトコル: `docs/proto/overview.md`
- RPi内IPCトピック: `docs/interfaces/ipc_topics_v1.md`
- ログ方針/ログ運用: `docs/proto/protocol_logging_plan.md`
- 固定責務の前提: `docs/architecture/overview.md`

重要:
- **DRIVE は TTL 前提の安全設計**。タスクB/タスクCは送信周期・TTL を厳守する。
- **AUTO中は MANUAL を無視**、介入は KILL のみ。

---

# タスクB: ルールベース（FTG）/ SLAM / セーフティ

## 役割
- LiDAR入力からの**FTG走行**を成立させる
- 走行の**安全停止条件**を強化する
- ROS2 + SLAM で**再現可能な地図生成手順**を整備する

## 関連ドキュメント
- `docs/planning/ftg_v1.md`
- `docs/slam/ros2_setup_v1.md`

## タスクフロー（論理フロー）
```
LiDAR raw -> (lidard) -> LIDAR_SCAN
                     -> LIDAR_SUMMARY

LIDAR_SCAN/LIDAR_SUMMARY -> (racerd) -> FTG -> DRIVE_CMD
DRIVE_CMD -> (seriald) -> DRIVE (ttl_ms付き) -> ESP32

ESP32 STATUS -> RPi -> VEHICLE_STATUS (IPC)
```

### 主要データ（v1想定 / IPC凍結）
- LIDAR_SCAN: `IPC_LIDAR_SCAN` / 5-20Hz / LidarScanChunkPayload + data
- LIDAR_SUMMARY: `IPC_LIDAR_SUMMARY` / 10-50Hz / LidarSummaryPayload
- IMU_SAMPLE: `IPC_IMU_SAMPLE` / 50-200Hz / ImuSamplePayload
- DRIVE_CMD: `IPC_DRIVE_CMD` / 20-100Hz / DriveCmdPayload（steer_cdeg/speed_mm_s/ttl_ms）
- VEHICLE_STATUS: `IPC_VEHICLE_STATUS` / 10-50Hz / VehicleStatusPayload

## 実装計画（10日）

### Day1-2: FTGコアの土台
- FTGアルゴリズム v0 実装
  - 入力: LIDAR_SUMMARY or LIDAR_SCAN（仮データOK）
  - 出力: steer_cdeg / speed_mm_s
- FTGパラメータ表（閾値/窓幅/速度係数）作成

### Day3-4: IPC連携 + ルールベース統合
- `lidard` の IPC publish（SCAN/SUMMARY）
- `racerd` v0: subscribe → FTG → DRIVE_CMD 生成
- TTL/送信周期の固定（例: 20-50ms）

### Day5-6: 安全系の強化
- single-point LiDAR の停止条件（ESP32側が最優先）
- RPiに距離・状態を載せてログ可視化
- IMU 取得のログ化（ブラインド区間の速度制御に備える）

### Day7-8: ROS2/SLAM の再現手順
- docker + slam_toolbox の手順書（オフラインでも再現）
- 地図生成 → 中心線 → 簡易パスの手順確立

### Day9-10: 安定化 & 最終固定
- FTGのパラメータ固定
- E2Eで再現可能な走行手順を記録

## DoD（受け入れ条件）
- `lidard` が v1 IPC を publish できる
- `racerd` が FTG で DRIVE を安定生成できる（TTL遵守）
- replay入力で**決定論的**に同じ出力
- ROS2/SLAM が別PCでも再現可能

## テスト/検証
- FTG単体: 入力→出力が固定となるユニットテスト
- 統合: sim_esp32d + seriald + racerd で机上E2E
- replay: 既存ログで同じ結果が出るか比較

---

# タスクC: AI/データ/推論入口

## 役割
- 走行ログからの**dataset生成**
- imitation学習の**最小ループ**
- racerd への**policy plugin**（FTG/AI切替）

## 関連ドキュメント
- `docs/ml/dataset_schema_v1.md`
- `docs/ml/policy_plugin_v1.md`

## タスクフロー（論理フロー）
```
LOG_RECORD/IPC topics
   -> (dataset builder) -> training/data
   -> (train/eval) -> models/production
   -> (policy plugin) -> racerd
```

### 主要データ（v1想定 / IPC凍結）
- LiDAR: `IPC_LIDAR_SCAN`（5-20Hz）or `IPC_LIDAR_SUMMARY`（10-50Hz）
- コマンド: DRIVE / MODE_SET / KILL（RPi↔ESP32プロトコル）
- 状態: `IPC_VEHICLE_STATUS`（10-50Hz）/ `IPC_IMU_SAMPLE`（50-200Hz）

## 実装計画（10日）

### Day1-2: データ設計
- dataset schema（timestamp整列/欠損処理/正規化）
- ログ→dataset変換ツール v0（CSV/Parquet どちらか）

### Day3-4: 学習パイプライン v0
- imitation 学習（入力: summary、出力: steer/speed）
- 評価指標（追従誤差/安定性）定義

### Day5-6: 推論差し替え口
- racerd に policy plugin 仕様を追加
- FTG/AI/Shadow の切替
- AI 失敗時は FTG へフェイルセーフ

### Day7-8: 自動化
- `make train` / `make eval` 等の入口
- モデル/データの履歴管理（最低限のメタ情報）

### Day9-10: 実ログで1周
- 実ログから dataset → 学習 → 推論評価
- “どのデータが足りないか” を明文化

## DoD（受け入れ条件）
- 1コマンドで dataset 生成できる
- 小モデルで学習→推論が再現できる
- racerd で FTG/AI 切替が安全に動作

## テスト/検証
- dataset 生成の再現性テスト
- 学習/評価のスモークテスト
- Shadow mode でのログ比較（AI vs FTG）

---

# 依存関係・リスク
- Interface Freeze（proto/log/IPC）が遅れるとタスクB/タスクCがブロック
- TTL/周期が守れないと安全設計が崩れる
- dataset schema が曖昧だと学習が再現不能

# 次のアクション（タスクB/タスクC同時並行）
- B: FTG v0 と lidard IPC を先行着手
- C: dataset schema と変換ツール v0 を先行着手
----------------------------------------

----------------------------------------
File: docs/planning/hils_e2e_status.md
----------------------------------------
# HILS E2E テスト安定化 状態管理

## 目的
- MODE_SET + DRIVE 直後の STATUS 取得を安定化し、不要な古い STATUS で失敗しないようにする。

## 状態一覧
- [完了] STATUS 受信の待ち条件を期待値一致で判定するよう見直し
- [完了] 失敗時のデバッグ情報（直近 STATUS 内容）の補足
----------------------------------------

----------------------------------------
File: docs/planning/lidar_shm_integration_status.md
----------------------------------------
# LiDAR 共有メモリ連携 状態管理

## 目的
- rpi/src のメイン処理が LiDAR デバイスを直接制御せず、`lidar_received` の共有メモリを参照して処理する。

## 状態一覧
- [完了] 共有メモリ読取クラスの追加（open/close、sem保護、コピー）
- [完了] rpi/src/main.cpp を共有メモリ読取に切り替え
- [完了] `lidar_received` 側の seq 運用見直し（インクリメント化）
- [完了] エラー時のリトライ/起動順の運用メモ

## メモ
- `lidar_received` の共有メモリ名: `/lidar_scan`、セマフォ名: `/lidar_scan_sem`
- `seq` はフレーム更新ごとにインクリメント（`UINT32_MAX` 到達時は 1 に戻す）
- 起動順: `lidar_received` → `robo-racer`
- `robo-racer` は共有メモリ未作成時に待機して再試行（200ms間隔）
- 共有メモリ/セマフォが残留する場合は `lidar_received` を停止後に `/dev/shm/lidar_scan` と `/dev/shm/sem.lidar_scan_sem` を削除して復旧する
----------------------------------------

----------------------------------------
File: docs/planning/lidar_received_logging_status.md
----------------------------------------
# lidar_received ログ統合 状態管理

## 目的
- `lidar_received` が共通の `mc::core::Logger` を使ってログ出力する。

## 状態一覧
- [完了] `lidar_received` のログを共通 Logger に置き換え
- [完了] ビルド設定（mc_core include/link）の調整

## メモ
- 参照資料: `docs/observability/logging_v1.md`
----------------------------------------

----------------------------------------
File: docs/planning/a_min_spec_plan.md
----------------------------------------
# A Minimal Spec Plan (v0.1) — ROS 2 Humble / RViz / bag / Contracts

このドキュメントは、A（基盤）担当が **B/C をブロックせずに並行開発可能にするため**の「最小仕様（Minimal Spec）」を **10日計画のDay1〜Day3相当**で完了させる実装計画書である。

- ROS 2 distro: **Humble**（Dockerは `ros:humble-desktop`）
- 座標系（最短）：**`base_link` / `laser` を凍結**（`map/odom` は次フェーズ）
- 可視化：**RViz（GUI）必須**
- ホスト：**Mac上Dockerが主、RPi上Dockerも同等に動作**

---

## 0. ゴール（Definition of Done）

Aの最小仕様 v0.1 が “Done” である条件：

1. `make ros2-up` で ROS2 環境が起動し、**MacでもRPiでもRVizが表示できる**
2. `docs/contracts/ros_topics_v0.1.md` が存在し、**topic/型/frame_id が凍結**されている
3. `rpi/ros2_ws/src/mc_msgs` が存在し、**B/C が依存できる msg 定義が凍結**されている
4. bridge 未実装でも `mc_demo_pub` で `/scan` が出て、**RVizでLaserScanが見える**
5. `bag_record.sh` / `bag_play.sh` があり、**run_id規約 + metadata.json 付きで記録/再生できる**
6. （推奨）`seriald.telemetry.sock` の契約（＋可能なら実装）により、**観測クライアントが安全に接続できる**

---

## 1. Day1で凍結する最小契約（Contracts v0.1）

### 1.1 ROS2 Topics（凍結対象）
- `/scan` : `sensor_msgs/msg/LaserScan`
  - `header.frame_id = "laser"`（固定）
- `/tf_static` : `tf2_msgs/msg/TFMessage`
  - `base_link -> laser`（static transformを publish）
- `/mc/status` : `mc_msgs/msg/Status`
- `/mc/drive_cmd` : `mc_msgs/msg/DriveCmd`
- `/mc/log` : `mc_msgs/msg/LogRecord`
- （任意）`/mc/bridge_diag` : `diagnostic_msgs/msg/DiagnosticArray`

### 1.2 Frame（凍結対象）
- `base_link`（固定）
- `laser`（固定）
- ※`map/odom` は次フェーズで追加・凍結する

### 1.3 bag運用（凍結対象）
- 保存先：`training/data/bags/<run_id>/`
- `metadata.json` を同階層に必ず生成
- `run_id` 生成規則はスクリプトで統一（例：`YYYYMMDD_HHMMSS_<short>` or UUID）

---

## 2. 実装の全体像（成果物ツリー）

```

docs/
contracts/
ros_topics_v0.1.md
bag_ops_v0.1.md
mc_bridge_v0.1.md            # 定義のみ（実装は次フェーズでOK）
ipc_uds_v0.1.md              # (推奨) telemetry socket 契約
docker/
ros2/
Dockerfile
docker-compose.yml
tools/
ros2/
rviz/default.rviz
scripts/
run_id.sh
bag_record.sh
bag_play.sh
rpi/ros2_ws/
src/
mc_msgs/
msg/DriveCmd.msg
msg/Status.msg
msg/LogRecord.msg
mc_tf_static/                # base_link->laser の static TF
mc_demo_pub/                 # bridge無しで /scan を出す

```

---

## 3. PR計画（A1〜A5）

### PR-A1: ROS2基盤（Humble desktop）+ RViz GUI（Mac/RPi同等）
**目的**：`make ros2-up` で “誰でも” GUI まで到達する。

**作業**
- `docker/ros2/Dockerfile` を `ros:humble-desktop` ベースで作成
- `docker/ros2/docker-compose.yml` を追加
- RViz表示方式を確定（Mac/RPi同等が最優先）
  - 推奨：**noVNC**（ブラウザ表示。XQuartz不要で事故りにくい）
- Makeターゲット追加
  - `ros2-up`, `ros2-down`, `ros2-shell`, `ros2-build`, `ros2-rviz`

**受け入れ基準**
- Mac: `make ros2-up` → ブラウザでRViz画面が見える
- RPi: `make ros2-up` → 同様にRViz画面が見える
- `make ros2-shell` で `ros2 topic list` が実行できる

**チェック**
- [ ] Macで起動確認
- [ ] RPiで起動確認
- [ ] README/手順が `docs/` にある

---

### PR-A2: Contracts（ROS topics）+ mc_msgs + static TF
**目的**：B/Cが依存する “型” と “topic契約” をDay1で凍結する。

**作業**
- `docs/contracts/ros_topics_v0.1.md` を追加（ここで凍結宣言）
- `rpi/ros2_ws/src/mc_msgs/` を追加（msg定義）
  - `DriveCmd.msg`, `Status.msg`, `LogRecord.msg`
- `rpi/ros2_ws/src/mc_tf_static/` を追加
  - `base_link -> laser` を `/tf_static` に publish
  - transform値は `rpi/config/frames.yaml`（または同等）から読む

**受け入れ基準**
- `/tf_static` が publish される
- RVizで `Fixed Frame = base_link` にできる（TFが生きている）
- `mc_msgs` が `colcon build` で通る

**チェック**
- [ ] docs/contracts/ros_topics_v0.1.md がレビュー済み
- [ ] msg定義が最小で過不足ない
- [ ] TFが1回だけpublishされ、重複しない

---

### PR-A3: demo publisher（bridge無しで /scan をRViz表示）
**目的**：bridgeが無くてもBがFTG/SLAMのROS側実装に着手できる。

**作業**
- `rpi/ros2_ws/src/mc_demo_pub/` を追加
  - `/scan` を疑似生成して publish（簡単でOK）
  - `header.frame_id="laser"`
  - `angle_min/max`, `angle_increment`, `range_min/max` を正しく設定
- `tools/ros2/rviz/default.rviz` を追加
  - LaserScan表示を保存
- `make ros2-rviz` が `default.rviz` を開く導線を持つ

**受け入れ基準**
- bridge無しで RViz に `/scan` が表示される
- bag record/play の前提として最低限のtopicが存在する

**チェック**
- [ ] `/scan` が一定周期で出る
- [ ] `frame_id` が `laser` で固定
- [ ] RViz configが保存されている

---

### PR-A4: bag運用雛形（record/play）+ run_id + metadata
**目的**：Mac/RPiで同一のデータ収集・再生フローを固定し、Cの学習データ基盤も同時に作る。

**作業**
- `docs/contracts/bag_ops_v0.1.md` を追加（運用凍結）
- `tools/ros2/scripts/run_id.sh` を追加（run_id生成）
- `tools/ros2/scripts/bag_record.sh` を追加
  - 記録topicは固定（`/scan`, `/tf_static`, `/mc/status`, `/mc/drive_cmd`, `/mc/log`）
  - 出力先 `training/data/bags/<run_id>/`
  - `metadata.json` 生成（run_id, git_sha, host, notes）
- `tools/ros2/scripts/bag_play.sh` を追加
  - `BAG=<path>` を受け、`--clock` で再生（将来 `use_sim_time` と連動）
- Makeターゲット追加
  - `ros2-bag-record`, `ros2-bag-play`

**受け入れ基準**
- demo publisher稼働中に record → play が成立する
- `metadata.json` が出る（run_id と git_sha が入る）

**チェック**
- [ ] Macで record/play 確認
- [ ] RPiで record/play 確認
- [ ] 生成物の保存先が規約通り

---

### PR-A5（推奨 / P0）: seriald telemetry socket（観測の安全確保）
**目的**：B/C/可視化/学習収集が “安全に並行接続” できるようにする。

**作業**
- `docs/contracts/ipc_uds_v0.1.md` を追加（control/telemetryの契約）
- 可能なら `seriald` に以下を実装：
  - `/tmp/roboracer/seriald.sock`（control：送信権あり。原則 racerd のみ）
  - `/tmp/roboracer/seriald.telemetry.sock`（telemetry：観測専用。送信禁止）
  - telemetryクライアントが送信したら切断 or 無視＋WARN（安全）

**受け入れ基準**
- control運転中に telemetry が複数接続できる
- telemetry から送信しても UART に流れない

**チェック**
- [ ] telemetry接続クライアントが増えても安定
- [ ] “誤送信” を確実に防げる

---

## 4. mc_bridge の扱い（定義はDay1、実装は次フェーズ）
**方針**：今フェーズは “基盤” のみ。実データをROSへ流す bridge は次フェーズで実装する。  
ただし、B/Cの並行開発のため、**mc_bridge の契約だけはDay1で凍結**する。

### docs/contracts/mc_bridge_v0.1.md（Day1で追加）
- 入力：`seriald.telemetry.sock`（mc_protoフレーム）
- 出力：
  - `/mc/status`, `/mc/log`, `/mc/hils_state`, `/mc/ack`
- エラー：CRC/COBS不正は `/mc/bridge_diag` へ
- stamp：受信時刻を `header.stamp` とする（最初はこれで十分）
- run_id：bag/ログと同じ run_id で束ねる

---

## 5. 実行手順（スモークテスト）

### ROS2
- `make ros2-up`
- `make ros2-shell`
- `make ros2-build`
- `make ros2-rviz`

### demo publisher
- コンテナ内で `mc_demo_pub` 起動（コマンドはPR内のREADMEに固定）
- RVizで `/scan` が見えることを確認

### bag
- `make ros2-bag-record`
- `BAG=training/data/bags/<run_id> make ros2-bag-play`

---

## 6. 完了判定（Day1 Closeout Checklist）

- [ ] `docs/contracts/ros_topics_v0.1.md` がある（凍結宣言）
- [ ] `mc_msgs` があり、B/Cが依存できる
- [ ] `base_link -> laser` の `/tf_static` が出ている
- [ ] demo `/scan` がRVizで見える
- [ ] rosbag record/play が規約通りに動く（run_id + metadata.json）
- [ ] （推奨）telemetry socket の契約（＋可能なら実装）が入っている

---

## 7. リスクと回避策

- **RViz GUI（Mac/RPi同等）**
  - X11は環境差で詰まりやすい → **noVNC方式を標準化**して事故を減らす
- **topic/msgの後出し変更**
  - B/Cの手戻りが発生 → v0.1凍結後は “追加のみ” を原則
- **telemetry未整備**
  - 観測ツールがcontrolへ誤送信する事故 → `telemetry.sock` を最優先で導入

---

## 8. 次フェーズ（参考）
- `mc_bridge` 実装（telemetryからdecodeしてROS publish）
- `lidar_bridge` 実装（実LiDAR or IPC → `/scan`）
- `log_to_bag`（既存ログ → rosbag2変換）
- 座標系拡張（`odom` / `map` 凍結、REP-105への移行）
----------------------------------------

----------------------------------------
File: docs/planning/p0_branch_test_memo.md
----------------------------------------
# P0 ブランチ別 最低限テスト手順メモ

## 目的
- P0-1〜P0-3 の **最低限動作確認** を短時間で回せるようにする。
- 手元・机上（HILS）で「壊れていない」ことを確認する。

## 共通前提
- ブランチを切り替えたら `uv sync` もしくは `make pysync` を実施。
- ROS2/rviz の起動は `tools/ros2` を利用（必要なら `make ros2-rviz`）。

---

## P0-1: `feat/seriald-telemetry-split`

### 目的
- control/telemetry 分離が機能し、telemetry 送信が UART に流れないこと。

### 手順（机上E2E）
1. ブランチ切替
   - `git checkout feat/seriald-telemetry-split`
2. 机上E2E 起動
   - `make hils-local`
3. control ソケットで送信が通ることを確認
   - `rpi/apps/seriald/seriald_client.py --sock /tmp/roboracer/seriald.sock --mode auto`
4. telemetry ソケットで送信が遮断されることを確認
   - `rpi/apps/seriald/seriald_client.py --sock /tmp/roboracer/seriald.telemetry.sock --mode auto`
   - 期待: WARN ログが出て切断される / UART へは流れない
5. telemetry 多重接続
   - 複数ターミナルで `seriald_client.py --sock /tmp/roboracer/seriald.telemetry.sock --recv`
   - 期待: STATUS が複数クライアントに届く

### 判定
- telemetry 送信が UART に **一切** 流れない
- telemetry 複数接続でも control が落ちない

---

## P0-2: `feat/mc-bridge-telemetry`

### 目的
- telemetry.sock → ROS2 topic publish が成立すること。

### 手順
1. ブランチ切替
   - `git checkout feat/mc-bridge-telemetry`
2. ROS2 build
   - `tools/ros2/scripts/ros2_build.sh`
3. run_id publish
   - `tools/ros2/scripts/publish_run_id.sh`（run_id が無いと /mc/log は出ない）
4. mc_bridge 起動
   - UDS（RPi上）: `ros2 run mc_bridge mc_bridge`
   - TCP（PC側）: `ros2 run mc_bridge mc_bridge --ros-args -p telemetry_tcp_host:=<RPi_IP> -p telemetry_tcp_port:=5001`
5. topic 確認
   - `ros2 topic echo /mc/status`
   - `ros2 topic echo /mc/drive_cmd`
   - `ros2 topic echo /mc/hils_state`
   - `ros2 topic echo /mc/log`

### 判定
- telemetry の STATUS/DRIVE/HILS が /mc/* に出る
- /mc/run_id が無い場合 /mc/log が抑止される
- decode/CRC 異常で WARN が出る

---

## P0-3: `feat/lidar-bridge-scan`

### 目的
- `/dev/shm/lidar_scan` → `/scan` の LaserScan が RViz で見えること。

### 手順
1. ブランチ切替
   - `git checkout feat/lidar-bridge-scan`
2. ROS2 build
   - `tools/ros2/scripts/ros2_build.sh`
3. lidar_received 起動（SHM 作成）
   - `rpi/apps/lidar_received`（手元環境に合わせて）
4. lidar_bridge 起動
   - `ros2 run lidar_bridge lidar_bridge`
5. RViz
   - `make ros2-rviz`
   - Fixed Frame = `base_link` で `/scan` が表示されること

### 判定
- `/scan` が更新され、RViz に描画される
- `base_link -> laser` の tf_static で破綻しない

---

## 補足
- `/tmp/roboracer` を正とする。
- 机上E2E で不安定なら、まず `seriald` のログを確認。
----------------------------------------

----------------------------------------
File: docs/planning/ros2_novnc_bind_bag_ops_status.md
----------------------------------------
# noVNC バインド方針と bag コピー運用ステータス

## 目的
- noVNC をデフォルトで 127.0.0.1 にバインドし、LAN 公開は明示的に指定する。
- RPi → PC への bag コピー運用をドキュメント化する。

## 状態
| 項目 | 状態 | 日付 | メモ |
| --- | --- | --- | --- |
| 既存 noVNC の公開範囲確認 | 完了 | 2026-02-01 | compose の ports と起動スクリプトを確認 | 
| noVNC のデフォルト bind 制限 | 完了 | 2026-02-01 | スクリプトは 127.0.0.1 既定、compose で 0.0.0.0 を上書き | 
| LAN 公開の明示手順 | 完了 | 2026-02-01 | NOVNC_BIND=0.0.0.0 を記載 | 
| RPi から bag コピー手順の記載 | 完了 | 2026-02-01 | scp 例を追加 | 

## 進行メモ
- 対象: tools/ros2/scripts/novnc_start.sh / tools/ros2/compose.yml / docs/ros2/dev_env.md
----------------------------------------

----------------------------------------
File: docs/planning/ros2_xdg_runtime_dir_status.md
----------------------------------------
# ROS2 サービスの XDG_RUNTIME_DIR 初期化ステータス

## 目的
- ros2 サービス起動時に XDG_RUNTIME_DIR を作成し、Qt/RViz が失敗しないようにする。
- novnc_start.sh と同等の mkdir/chmod をエントリーポイントで実行する。

## 状態
| 項目 | 状態 | 日付 | メモ |
| --- | --- | --- | --- |
| 既存挙動の確認 | 完了 | 2026-02-01 | ros2 サービスで XDG_RUNTIME_DIR が未作成 | 
| エントリーポイントの追加 | 完了 | 2026-02-01 | mkdir -p と chmod 700 を追加 | 
| Dockerfile への組み込み | 完了 | 2026-02-01 | ラッパーを ENTRYPOINT に設定 | 
| ステート更新 | 完了 | 2026-02-01 | 反映済み | 

## 進行メモ
- 対象: tools/ros2/Dockerfile / tools/ros2/scripts/ros2_entrypoint.sh
- 参考: tools/ros2/scripts/novnc_start.sh
----------------------------------------

----------------------------------------
File: docs/planning/process_decision_telemetry_status.md
----------------------------------------
# process 意思決定テレメトリ 状態管理

## 目的
- `Process::proc()` の意思決定過程（best角/候補/override）を観測可能にする
- ターミナルでリアルタイムに状況把握できる最小UIを提供する

## 状態一覧
- [完了] `Process` のテレメトリログ（best/min/path/cmd/override）の追加
- [完了] ASCIIコンパス + top-3 + override表示の追加
- [完了] JSONL 形式の telemetry/event 出力の追加
- [完了] run_id/tick/scan_id 付与（run_id は起動時生成）
- [完了] ログ頻度の間引き/レート制御（既定10Hz、CLIで変更可）
- [完了] TTY 固定UI（フレーム化/追加情報/終了時カーソル復帰）
- [完了] UIとログの混線回避（console sink 無効化）
- [完了] テレメトリ出力のモジュール分離（TelemetryEmitter）
- [完了] rpi/src の標準出力/標準エラーを Logger へ移行（Sender/LidarReceiver/main）
- [完了] UI/JSONL の追加項目（mode/latency/score/metrics/ESP status など）
- [完了] metricsd.log の最新値を UI に反映（JSONLは除外）
- [完了] テレメトリのレート制限（既定10Hz）と出力レベル（basic/full）
- [完了] full candidates はイベント時のみ出力
- [完了] metricsd.log 読み込みを別スレッド化
- [完了] フルダッシュボードUI（スパークライン/バー/3段階色）
- [完了] MAPを最上段に配置（リッチUI拡張）
- [完了] ミニヒートマップ/イベント表示/品質指標/安定性指標を追加
- [完了] バッジ判定・イベント条件をチューニング（閾値/品質/TTL/遅延）
- [完了] TSAN ビルドオプション追加（開発時の競合検出用）
- [完了] コンパス表示を別枠化してリッチ化（B/Sマーカー付き）
- [完了] 矩形ヒートマップ化（扇形を廃止し距離×角度の棒グラフ表示）
- [完了] B/T/Aマーカーの色分け（マーカー行＋角度行）
- [完了] リッチコンパス拡張（LiDAR距離の扇形可視化＋進行方向の可視化）
- [完了] リッチコンパス用の距離ビン生成（Processで角度→距離プロファイルを生成）
- [完了] UI配置の再設計（コンパス枠の高さ増加・他行の圧縮）

## メモ
- 参照資料: `docs/observability/logging_v1.md`
----------------------------------------

----------------------------------------
File: docs/planning/dir_utils_status.md
----------------------------------------
# dir_utils 共有化ステータス

## 目的
- sim_esp32d / serialctl / metricsd / seriald に重複している `ensure_dir_` と `dir_of_` を共通ユーティリティへ移動する。
- DRY 原則に沿って保守性を上げる。

## 状態
- 完了: 共通ユーティリティを `rpi/lib/mc_core` に追加
- 完了: 各アプリの参照先を `mc::core::ensure_dir` / `mc::core::dir_of` に切替
- 完了: `ensure_dir` を再帰作成（mkdir -p相当）に拡張
- 未着手: 影響範囲のビルド確認
- 進行中: レビュー後の最終更新

## 変更方針メモ
- 共有先は `rpi/lib/mc_core` 配下にヘッダを追加する。
- API は既存利用と同等の振る舞いを維持する。
----------------------------------------

----------------------------------------
File: docs/planning/ros2_bag_session_status.md
----------------------------------------
# ROS2 bag 運用強化（PROFILE/run_id/session）ステータス

## 目的
bag 運用の再現性・トレーサビリティを強化し、run_id をセッション唯一の真実として固定する。

## 範囲
- bag_record の PROFILE 対応（core/slam/all）とデフォルト強化
- topics プロファイルファイルの追加
- /mc/run_id の publish（transient_local）
- session 起動スクリプトで run_id を全体に伝播
- docs（bag_ops/topic_spec など）の更新
- （必要なら）Make 導線の追加

## ステータス
| 項目 | 状態 | 備考 |
| --- | --- | --- |
| topics プロファイル追加 | 完了 | core/slam を追加 |
| bag_record.sh 改修 | 完了 | PROFILE/--all/TOPICS 優先度 |
| publish_run_id.sh 追加 | 完了 | transient_local で 1 回 publish |
| session_up.sh 追加 | 完了 | RUN_ID 生成→publish→起動→record |
| docs 更新（bag_ops/topic_spec/dev_env） | 完了 | 運用/ICD 固定 |
| Make 導線（必要なら） | 完了 | ros2-session-up 追加 |
| .gitignore の data/bags パターン修正 | 完了 | ルート固定の安全パターンに変更 |
| session_up の安全装置強化 | 完了 | trap/待機/環境伝播 |
| bag_record の present_topics 記録 | 完了 | meta.txt に可視トピックを追記 |
| run_id 運用の実装側強制（契約更新） | 完了 | mc_bridge 契約へ反映 |
| SESSION_CMD の安全注意を明記 | 完了 | 外部入力の禁止を明文化 |
| session_up のプロセスグループ分離 | 完了 | kill で子プロセスを残さない |
| /mc/run_id の keepalive 配信 | 完了 | セッション中の遅延参加に対応 |
| publish_run_id の --rate 引数検証 | 完了 | 空値/不正値を防止 |

## 検証タスク
| 項目 | 状態 | 備考 |
| --- | --- | --- |
| スクリプト構文チェック | 完了 | bash -n で確認 |
| Docker 実行確認 | 進行中 | session_up 再確認は Docker デーモン未起動 |

## 進行メモ
- 2026-01-31: 関連 docs を確認し、実装計画を確定。
- 2026-01-31: topics プロファイル、bag_record/publish_run_id/session_up、docs/Make 更新を完了。
- 2026-01-31: bash -n によるスクリプト構文チェックを実施。
- 2026-01-31: docker compose で bag_record を起動し、bag 出力開始ログを確認。
- 2026-01-31: publish_run_id に wait-matching-subscriptions=0 を追加。
- 2026-01-31: session_up（ros2 launch）で run_id publish と bag 作成を確認。
- 2026-01-31: テスト生成した bag を削除。
- 2026-01-31: session_up を slam_toolbox launch で再確認し、meta.txt を検証後に bag を削除。
- 2026-01-31: .gitignore の bags パターンを training/data/bags に固定。
- 2026-01-31: session_up に trap 強化・終了検知・RUN_ID 伝播を追加。
- 2026-01-31: bag_record の meta.txt に present_topics を追加。
- 2026-01-31: mc_bridge 契約に run_id 必須・未取得時の発行禁止を明記。
- 2026-01-31: session_up/bag_record の bash -n を再実行。
- 2026-01-31: Docker デーモン未起動のため session_up 再検証は保留。
- 2026-01-31: SESSION_CMD の安全注意を docs に追記する作業を開始。
- 2026-01-31: bag_ops に SESSION_CMD の安全注意と引数渡しの回避策を追記。
- 2026-01-31: session_up のプロセスグループ分離に着手。
- 2026-01-31: session_up の起動に setsid を使用し、終了時にプロセスグループごとに終了するよう修正。
- 2026-01-31: /mc/run_id の keepalive 配信対応を開始。
- 2026-01-31: bag_record/session_up で keepalive publish を起動し、終了時に停止するよう修正。
- 2026-01-31: publish_run_id の --rate 引数検証追加に着手。
- 2026-01-31: publish_run_id の --rate に空値/不正値ガードを追加。
----------------------------------------

----------------------------------------
File: docs/planning/a_min_spec_implementation_status.md
----------------------------------------
# A 最小仕様 v0.1 実装ステータス

## 目的
`docs/planning/a_min_spec_plan.md` の Day1〜Day3 相当を実装し、B/C が並行開発できる最小仕様を固定する。

## 前提（確認済み）
- ROS2 Docker 環境は `tools/ros2/` を利用（`docs/slam/ros2_setup_v1.md` 方針に合わせる）
- 既存の rpi/ros2_ws/mc_msgs は維持し、契約/運用を不足分で補う

## ステータス
| 項目 | 状態 | 期限 | 備考 |
| --- | --- | --- | --- |
| docs/contracts/ros_topics_v0.1.md 追加 | 完了 | 2026-02-08 | topic/型/frame_id 凍結を明文化 | 
| rpi/ros2_ws/mc_msgs の契約整合 | 完了 | 2026-02-01 | 既存 msg を維持 | 
| mc_tf_static 追加（base_link->laser） | 完了 | 2026-02-08 | rpi/config/frames.yaml を利用 | 
| mc_demo_pub 追加（/scan 疑似発行） | 完了 | 2026-02-08 | RViz 表示の最短経路 | 
| tools/ros2/rviz/default.rviz 追加 | 完了 | 2026-02-08 | Fixed Frame=base_link | 
| Makefile に ros2-rviz 追加 | 完了 | 2026-02-08 | RViz 起動導線 | 
| noVNC（ブラウザ表示）導入 | 完了 | 2026-02-08 | Mac の RViz 安定化 | 
| bag_record/play を規約化（run_id/metadata.json/--clock） | 完了 | 2026-02-08 | metadata.json を必須化 | 
| tools/ros2/scripts/run_id.sh 追加 | 完了 | 2026-02-08 | run_id 生成規則の統一 | 
| docs/contracts/bag_ops_v0.1.md 追加 | 完了 | 2026-02-08 | bag 運用凍結 | 
| docs/contracts/ipc_uds_v0.1.md 追加（推奨） | 完了 | 2026-02-08 | telemetry socket 契約 | 
| docs/ros2/bag_ops.md の整合更新 | 完了 | 2026-02-08 | metadata.json/保存先 | 

## 残タスク（順序付き TODO）
| 順番 | タスク | 状態 | 依存 | 備考 |
| --- | --- | --- | --- | --- |
| 1 | run_id.sh 追加と bag_record.sh 更新 | 完了 | - | metadata.json 出力まで含む |
| 2 | bag_play.sh の --clock 対応 | 完了 | 1 | Makefile への反映も含む |
| 3 | ros_topics_v0.1.md 作成 | 完了 | - | topic_spec.md と整合 | 
| 4 | bag_ops_v0.1.md 作成 | 完了 | 1 | docs/ros2/bag_ops.md も更新 | 
| 5 | mc_tf_static / mc_demo_pub 追加 | 完了 | - | rpi/ros2_ws ビルド対象 | 
| 6 | rviz/default.rviz 追加 + ros2-rviz 導線 | 完了 | 5 | RViz で /scan を確認 | 
| 7 | ipc_uds_v0.1.md 作成 | 完了 | - | 推奨（P0） |
| 8 | noVNC（ブラウザ表示）導入 | 完了 | - | Mac の RViz 起動安定化 |

## 差異・留意
- RViz GUI は X11/XQuartz に加えて noVNC を併設（Mac 安定化のため）。

## 進行メモ
- 2026-02-01: a_min_spec_plan.md と min_spec_v0_1.md を確認。
- 2026-02-01: ros2/topic_spec.md・bag_ops.md・dev_env.md を確認。
- 2026-02-01: ros_topics/bag_ops 契約文書と run_id/metadata.json を実装。
- 2026-02-01: mc_tf_static / mc_demo_pub / rviz config / ros2-rviz 導線を追加。
- 2026-02-01: config/ と ros2_ws を rpi/ 配下へ移動し、参照パスを更新。
- 2026-02-01: noVNC 導入（Dockerfile/compose/Make/docs 更新）。
----------------------------------------

----------------------------------------
File: docs/observability/logging_v1.md
----------------------------------------
# ロギング v1（Interface Freeze）

## 目的
- 制御ループを止めずにログを残す
- コマンド/状態遷移を必ず記録し、後から再現可能にする

## 正本
- ESP32側ログ転送: `docs/proto/log_transport.md`
- RPi側ロガー: `rpi/lib/mc_core/include/mc/core/Log.hpp`

## RPi側 Logger（v1固定）
- API: `mc::core::Logger` を全プロセスで共通利用
- レコード: `LogRecord { ts_us, level, tag, msg }`
- 非同期: 内部キューで非同期書き込み（dropは古いものから）
- 既定の出力: ConsoleSink（stderr）
- 追加出力: FileSink（追記）

### 文字列フォーマット（FileSink/ConsoleSink）
```
[<ts_us>] <LEVEL> [<tag>] <msg>
```

## ESP32↔RPi ログ転送（UART）
- type: `LOG (0x10)`
- payload: `level + text (UTF-8)`
- 非同期送信、送信詰まり時はdrop可

## 記録対象（最低限）
- MODE_SET/DRIVE/KILL などの**命令内容**
- 状態遷移（AUTO/MANUAL、KILLラッチ、TTL失効）
- 重要イベント（CRC不正、HBタイムアウト、UART切断）

## ローテーション/容量（v1方針）
- v1では**ローテーションは未実装**
- 運用では `logrotate` 等の外部管理で回す

## Dropポリシー（v1固定）
- RPi: `Logger` 内部キューは上限を超えたら **古いレコードを破棄**
- ESP32: LogTxTask 送信詰まり時は **送信を諦めてdrop**

----------------------------------------

----------------------------------------
File: docs/ros2/dev_env.md
----------------------------------------
# ROS2 開発環境（Docker/RViz）v0.1

## 目的
- Ubuntu/Mac の両方で ROS2 + RViz を再現可能にする
- bag 運用や SLAM 検証をコンテナ内で統一する

## 前提
- ROS2: Humble
- Docker/compose を利用
- リポジトリを `/ws` にマウント

## 1) Docker イメージのビルド
```
docker compose -f tools/ros2/compose.yml build
```

## 2) シェルに入る
```
docker compose -f tools/ros2/compose.yml run --rm ros2 bash
```

## 3) RViz 起動（GUI）
### 事前注意（DISPLAY）
`docker compose up` は **DISPLAY を自動設定しない**。ホストの環境変数に従うため、
Ubuntu は `DISPLAY=:0`、Mac は `DISPLAY=host.docker.internal:0` を **事前に設定**してから起動すること。
一方で `make ros2-up` / `make ros2-rviz` は Mac の場合に DISPLAY などを自動設定する。

### Ubuntu（X11）
```
xhost +local:root
export DISPLAY=:0
```
コンテナ内で：
```
rviz2
```

### Mac（Docker Desktop + XQuartz）
1. XQuartz を起動し「接続を許可」を有効化
2. ホスト側で以下を設定
```
export DISPLAY=host.docker.internal:0
xhost + 127.0.0.1
```
3. コンテナ内で `rviz2`

### Mac（noVNC 推奨）
XQuartz 不要でブラウザ表示に切り替える。
```
make ros2-novnc
```
ブラウザで以下を開く。
```
http://localhost:6080/vnc.html
```
#### LAN 公開が必要な場合
デフォルトは `127.0.0.1` バインドのため、LAN からはアクセス不可。
LAN 公開する場合は **明示的に** `NOVNC_BIND=0.0.0.0` を指定すること。

#### Compose での注意
`tools/ros2/compose.yml` の `ros2-novnc` はコンテナ内で 0.0.0.0 にバインドさせる。
ホスト側の公開範囲は `ports: 127.0.0.1:6080:6080` でローカル限定のまま。

例:
```
NOVNC_BIND=0.0.0.0 make ros2-novnc
```

### Mac 自動設定（Make 経由）
`make ros2-rviz` / `make ros2-up` は Mac の場合に以下の環境変数を自動設定する：
- `DISPLAY=host.docker.internal:0`
- `LIBGL_ALWAYS_SOFTWARE=1`
- `QT_XCB_GL_INTEGRATION=none`
- `XDG_RUNTIME_DIR=/tmp/runtime-root`
XQuartz の設定と `xhost` は必要。

### RViz デフォルト設定
```
make ros2-rviz
```
`tools/ros2/rviz/default.rviz` を使用して起動する。

## 4) rpi/ros2_ws のビルド
```
./tools/ros2/scripts/ros2_build.sh
```
`rpi/ros2_ws/src/mc_msgs` がメッセージ定義の雛形です。

## 5) demo publisher（/scan）と static TF
```
ros2 run mc_tf_static mc_tf_static --ros-args --params-file /ws/rpi/config/frames.yaml
ros2 run mc_demo_pub mc_demo_pub
```
`/scan` は `frame_id=laser` で publish される。

## 6) bag の record/play
- record: `./tools/ros2/scripts/bag_record.sh`
- session: `./tools/ros2/scripts/session_up.sh`（run_id 伝播を固定したい場合）
- play: `./tools/ros2/scripts/bag_play.sh <bag_path> [rate]`

## 7) RPi から bag をコピーして再生（推奨運用）
RPi 側で bag を保存し、PC 側へコピーして再生する。

例（RPi → PC）:
```
scp -r pi@<rpi-host>:/ws/training/data/bags/<run_id> ./training/data/bags/
```

コピー後の再生例:
```
./tools/ros2/scripts/bag_play.sh ./training/data/bags/<run_id>
```
----------------------------------------

----------------------------------------
File: docs/ros2/topic_spec.md
----------------------------------------
# ROS2 Topic Spec v0.1

## 方針
- ROS2 topic は mc_proto と意味一致させる
- B/C が bag 前提で並行開発できるように固定する

## Topics

### /scan
- 型: `sensor_msgs/LaserScan`
- frame_id: `laser`
- angle: -pi..pi（推奨）
- range_min/max: センサ仕様に合わせる

### /mc/drive_cmd
- 型: `mc_msgs/DriveCmd`
- 意味: `mc::proto::DrivePayload` と同等
- 出所: `seriald.telemetry` に **RPi→ESP32 送信フレームをミラー**して可視化
- フィールド:
  - `steer_cdeg` (int16, 0.01deg)
  - `speed_mm_s` (int16, mm/s)
  - `ttl_ms` (uint16, ms)
  - `dist_mm` (uint16, mm)

### /mc/status
- 型: `mc_msgs/Status`
- 意味: `mc::proto::StatusPayload` と同等
- フィールド:
  - `seq_applied` (uint8)
  - `auto_active` (uint8)
  - `faults` (uint16)
  - `speed_mm_s` (int16)
  - `steer_cdeg` (int16)
  - `age_ms` (uint16)

### /mc/hils_state
- 型: `mc_msgs/HilsState`
- 意味: `mc::proto::HilsStatePayload` と同等
- フィールド:
  - `timestamp` (uint32)
  - `throttle_raw` (int16)
  - `steer_cdeg` (int16)
  - `flags` (uint8)

### /mc/log
- 型: `mc_msgs/LogRecord`
- 意味: ログ統一仕様
- フィールド:
  - `ts_ms` (uint32)
  - `level` (uint8)
  - `text` (string)
  - `run_id` (string, **必須**。`/mc/run_id` と一致させる)

### /mc/run_id
- 型: `std_msgs/String`
- 意味: セッション唯一の run_id（bag_record が生成）
- QoS: transient_local 推奨（遅延参加でも受け取れる）

### /tf_static（推奨）
- 型: `tf2_msgs/TFMessage`
- 意味: 静的な座標変換（例: `base_link -> laser`）

### /tf（推奨、出ている場合）
- 型: `tf2_msgs/TFMessage`
- 意味: 動的な座標変換（例: `odom -> base_link`, `map -> odom`）
----------------------------------------

----------------------------------------
File: docs/ros2/bag_ops.md
----------------------------------------
# rosbag 運用 v0.1

## 保存場所
- `training/data/bags/<run_id>/`

## run_id 付与
- `bag_record.sh` が `run_id.sh` で `YYYYMMDD_HHMMSS_<short>` を自動生成
- `PUBLISH_RUN_ID=1` の場合、`/mc/run_id` を transient_local で publish
- `RUN_ID_PUB_KEEPALIVE=1`（デフォルト）の場合、セッション中は keepalive で継続配信
- `RUN_ID_PUB_RATE` で keepalive の Hz を指定（デフォルト: 1）
- `/mc/log.run_id` は **必須**（`/mc/run_id` と一致させる）
- `OUT_DIR` を指定すれば任意の場所に保存可能

## record
```
RUN_ID=<run_id> TOPICS="/scan /mc/status /mc/drive_cmd" NOTES="optional" \
  ./tools/ros2/scripts/bag_record.sh
```
- `TOPICS` が最優先（完全手動）
- `TOPICS` 未指定なら `PROFILE` に従う（デフォルト: `core`）
- `PROFILE=all` のときのみ `--all` で記録
- `metadata.json` に run_id / git_sha / host / notes / created_at を保存
- `meta.txt` に run_id / git_sha / host / created_at / notes を保存
- `meta.txt` に profile / topics / topics_file も保存
- `meta.txt` に `present_topics`（記録開始時に見えていた topic）も保存

## play
```
./tools/ros2/scripts/bag_play.sh <bag_path> [rate]
```
- `--clock` を有効にして再生する

## topics プロファイル
- `tools/ros2/topics/<profile>.txt` で管理
- 例: `PROFILE=slam ./tools/ros2/scripts/bag_record.sh`

## session 起動（run_id 伝播を固定したい場合）
```
SESSION_CMD="ros2 launch <pkg> <file.launch.py>" \
  ./tools/ros2/scripts/session_up.sh
```
- Make 経由: `SESSION_CMD="ros2 launch <pkg> <file.launch.py>" make ros2-session-up`
- `session_up.sh` が `RUN_ID` を生成・publish し、同じ `RUN_ID` で `bag_record.sh` を起動
- `SESSION_CMD` 未指定なら bag 記録のみ
- `RUN_ID_PUB_KEEPALIVE=1` の場合、`session_up.sh` が keepalive publish を起動し、
  `bag_record.sh` 側の重複 publish は抑止される
- 注意: `SESSION_CMD` は `bash -lc` で実行されるため、**信頼できる文字列のみ**を渡すこと（外部入力の直接連結は禁止）
- 安全に実行したい場合は引数で渡す: `./tools/ros2/scripts/session_up.sh -- ros2 launch <pkg> <file.launch.py>`

## 推奨トピック
- `/scan` (sensor_msgs/LaserScan)
- `/mc/status`
- `/mc/drive_cmd`
- `/mc/hils_state`
- `/mc/log`
- `/mc/run_id`
- `/tf_static`（推奨）
- `/tf`（推奨、出ている場合）
----------------------------------------

----------------------------------------
File: docs/testing/hils_e2e_plan.md
----------------------------------------
# 机上E2E 統合テスト計画（seriald + sim_esp32d + racerd）

## 目的
- 物理機体なしで「RPi↔ESP32契約（v1）」の最小E2Eを検証する
- `DRIVE` → `STATUS` の往復と、TTL/KILL/AUTOの安全挙動を机上で再現する

## 構成（想定）
```
[racerd] --(UDS seqpacket / mcproto)--> [seriald] --(PTY/UART)--> [sim_esp32d]
                                 ^                             |
                                 +----(UDS seqpacket)----------+
```

## 前提
- `seriald` が UDS (SOCK_SEQPACKET) でIPC中継できる
- `sim_esp32d` が UART で mcproto を受信/返信できる
- PTYを用いてUARTを模擬できる

## テスト環境
- OS: Linux（AF_UNIX SOCK_SEQPACKETが必要）
- 生成物:
  - `rpi/build/apps/seriald/seriald`
  - `rpi/build/apps/sim_esp32d/sim_esp32d`
- 通信:
  - PTY master/slave
  - UDS socket: `/tmp/seriald.sock`

## ローカル実行（簡易）
- `make hils-local`（seriald + sim_esp32d を起動し STATUS を確認）
  - 既定で DRIVE を周期送信（TTLは送信周期より大きく設定）

## テストケース（最小）

### TC1: MODE_SET + DRIVE → STATUS
- 手順
  1. PTYを作成し、serialdのUARTをslaveへ接続
  2. sim_esp32dを同じslaveへ接続
  3. IPCクライアントから MODE_SET(AUTO) を送信
  4. 続けて DRIVE を送信
  5. STATUS が IPC で受信できること
- 期待結果
  - STATUS の `auto_active=1`
  - `speed_now_mm_s` / `steer_now_cdeg` が DRIVE に一致

### TC2: TTL失効 → STOP
- 手順
  1. AUTOでDRIVE送信
  2. TTLの2倍以上待機
  3. STATUS を確認
- 期待結果
  - `faults` に TTL_EXPIRED
  - `speed_now_mm_s=0`, `steer_now_cdeg=0`

### TC3: KILL → STOP維持
- 手順
  1. AUTOでDRIVE送信
  2. KILL送信
  3. STATUS を確認
- 期待結果
  - `faults` に KILL_LATCHED
  - 以降の DRIVE でも停止維持

### TC4: MANUAL時のDRIVE受理のみ
- 手順
  1. MODE_SET(MANUAL)
  2. DRIVE送信
  3. STATUS を確認
- 期待結果
  - `auto_active=0`
  - `faults` に AUTO_INACTIVE
  - 出力は停止

### TC5: PING → ACK
- 手順
  1. PING送信
  2. ACKを確認
- 期待結果
  - ACK の `seq` が一致

## 実装方針（最初の一歩）
- 既存 `test/rpi/seriald/test_seriald_integration.py` を拡張
  - PTYを共有し、sim_esp32dを subprocess で起動
  - IPCからMODE_SET/DRIVEを送信し、STATUS/ACKを検証
- 追加テスト: `test/rpi/hils/test_hils_e2e.py`
  - `racerd_stub`（テスト専用）で MODE_SET/DRIVE を送信
----------------------------------------

----------------------------------------
File: docs/testing/hils_v1.md
----------------------------------------
# HILS v1（Interface Freeze）

## 目的
- 物理機体が無くても「DRIVE→STATUS」往復と安全挙動を検証できること
- TTL/KILL/モード切替の**安全条件**を机上で再現すること

## 正本
- `docs/firmware/hils_guide.md`（実機HILSの運用）
- `docs/proto/overview.md`（UARTプロトコル）

## v1要件（sim_esp32d）
- `DRIVE` を受理すると `STATUS` を返す
- `MODE_SET` に従い AUTO時のみ DRIVE を適用する
- `KILL` はラッチして停止維持する
- `ttl_ms` を超過したら停止する
- `PING` は常に `ACK` を返す

## v1受入条件（机上E2E）
- seriald + sim_esp32d + racerd の統合テストが通る
- 以下のシナリオを再現できる
  - DRIVE未受信が一定時間続く → STOP
  - KILL受信 → STOP維持
  - MANUAL時のDRIVEは受理のみ（適用しない）

## 既存HILS（実機）との関係
- 実機HILSは **出力観測経路**（Shadow/Hilsモード）として維持
- sim_esp32d は **机上の代替ESP32** として扱う

## fault injection（sim_esp32d）
- `--status-delay-ms <ms>`: STATUS送信の遅延
- `--status-drop-every <N>`: N回に1回 STATUS を送らない
- `--status-corrupt-every <N>`: N回に1回 STATUS のCRCを破壊
----------------------------------------

----------------------------------------
File: docs/architecture/overview.md
----------------------------------------
# Architecture Overview — Robo Racer

## 目的 / Why this exists
このリポジトリは、**小型自動運転カーを「安全に・早く・再現性高く」走らせる**ための
フルスタック構成です。単なるデモではなく、次の3点を満たすことを狙います。

1. **低遅延で安全**: 走行の最終制御はESP32が担当し、緊急停止を最優先にする。
2. **責務配置の柔軟性**: 走行戦略や認識を、ESP32/RPiのどちらでも試せる構造にする。
3. **学習パイプラインの再現性**: 学習→モデル管理→実機投入の流れを一本化する。

---

## 設計の前提: 固定責務と可変責務

本プロジェクトは「**責務を試行錯誤しやすい構成**」を重視します。ただし、**物理走行と安全**
に関わる責務は固定します。

### 固定される責務（物理走行・安全）

この範囲は設計実験の対象外で、**配線や安全要件が変わらない限り固定**とします。

- **ESP32の固定責務**
  - **サーボ/モータの最終出力**（走行の最終責任）
  - **IMUの送受信**（IMUの取得・ホストへの送信）
  - **緊急停止（E-Stop）と安全クランプ**
  - ホスト監視・リアルタイム制御ループの維持
- **RPiの固定責務**
  - **2D LiDARの取得と送受信**（2D LiDARはRPiで扱い、必要な情報をESP32に送る）
- **RPi ↔ ESP32の堅牢通信**
  - 低遅延・エラー検出が可能なバイナリ通信を維持する

### 可変な責務（試行領域）

以下は **ESP32でもRPiでも自由に配置を試せる**領域です。

- 走行戦略（Cruise / Brake / 回避 / 追従など）
- 経路計画・速度プロファイル
- 障害物認識・地物推定
- モデル推論・学習済みモデルの適用
- ルールベース vs 学習ベースの比較

---

## 構成イメージ（固定と可変の分離）

```
2D LiDAR (fixed) -> RPi (I/O + optional perception)
                         |
                  COBS + CRC16 (UART)
                         |
ESP32 (fixed): Motor/Servo, IMU I/O, E-Stop
ESP32 (optional): strategy/control if試したい場合
```

---

## 配置パターンの例（いずれも許容）

- **RPi主導**: RPiで認識/戦略を実装し、操舵/速度目標をESP32へ送信
- **ESP32主導**: ESP32側で戦略まで完結し、RPiはログ/可視化のみ
- **ハイブリッド**: RPiで高レベル意思決定、ESP32で低遅延の局所回避

どのパターンでも、**固定責務は必ず維持**します。

---

## 通信インターフェース（RPi ↔ ESP32）

- **物理層**: UART
- **フレーミング**: COBS
- **検査**: CRC16-CCITT
- **最低限のメッセージ**
  - `SetMode` / `SetManual` / `SetPrefer`
  - `Estop` / `ClearEstop`
  - `Status`（姿勢・出力・状態）

**設計意図**: アルゴリズム配置の変更に耐えるよう、基礎メッセージは保ちつつ拡張可能にする。

---

## 現状の実装（参考）

### RPiランタイム（Python, src/）

- **perception/**: カメラ/2D LiDAR入力、推論、地物推定（現在は雛形）
- **control/**: 走行戦術/速度目標（実験領域）
- **driver/**: ESP32との通信ドライバ
- **common/**: 型定義・共有ユーティリティ

### ESP32ファームウェア（firmware/）

- **app/App**: ループ統括（センサ → コマンド → 状態遷移 → 出力 → テレメトリ）
- **control/**: 走行制御・状態機械（戦略は可変領域として扱う）
- **hardware/**: IMU、モータ、サーボ、その他接続センサ
- **comm/**: COBS + CRC16のプロトコル

---

## 安全設計（固定ルール）

- **E-Stopは常に最優先**（即座にスロットル0、操舵センター）
- **安全クランプの維持**（距離・姿勢などの安全条件）
- **ホスト監視**（通信途絶時は安全停止）

---

## 学習・モデル運用（想定）

```
training/data -> training/src -> models/production -> 推論（RPi or ESP32）
```

- 学習モデルの配置場所と更新フローは維持する
- 推論実行場所は **可変領域** として扱う

---

## 既知の未実装 / 今後の埋めどころ

- RPi側の通信実装（Protocol.h準拠の送受信）
- perception/control の具体ロジック
- training パイプラインの実装とデータ仕様
- config/ の実データ化（車体パラメータ、学習ハイパーパラメータ）
----------------------------------------

----------------------------------------
File: docs/architecture/test_design.md
----------------------------------------
# Test Design

## 目的
- すべてのテストは pytest で実行する。
- 仕様追加に合わせて分類ディレクトリを増やし、テストの居場所を明確にする。
- C++のプロトコル検証は pytest からビルドして実行する。

## 方針
- ルート配下は `test/` を唯一の起点とする。
- `test/rpi` と `test/firmware` に分割し、さらに機能別に分類する。
- ビルドに含めないC++テストは pytest からコンパイルして実行する。
- Makefile にはテスト用のコンパイルルールの記述を追加しない。

## ディレクトリ構成
```
test/
  rpi/
    proto/
      cpp/
        proto_tests.cpp
      test_proto_rpi_cpp.py
    comm/
      test_placeholder.py
  firmware/
    proto/
      cpp/
        proto_tests.cpp
      test_proto_firmware_cpp.py
    comm/
      test_placeholder.py
```

## 実行方法
- `uv run pytest`

## RPiプロトコルのC++テスト
- `test/rpi/proto/test_proto_cpp.py` が g++ でビルドして実行する。
- 依存ソースは `rpi/src/proto/*.cpp` を使用する。
----------------------------------------

----------------------------------------
File: docs/ml/dataset_schema_v1.md
----------------------------------------
# Dataset Schema v1（タスクC）

## 目的
- ログから**再現可能に学習データを生成**する
- 学習/評価の入力が**同じフォーマット**になることを保証する

## 正本/参照
- IPC payload: `docs/interfaces/ipc_payloads_v1.md`
- ログ仕様: `docs/observability/logging_v1.md`
- プロトコル: `docs/proto/overview.md`

---

## 入力ソース
- `IPC_LIDAR_SCAN` / `IPC_LIDAR_SUMMARY`
- `IPC_DRIVE_CMD`（教師ラベル）
- `IPC_VEHICLE_STATUS`
- `IPC_IMU_SAMPLE`
- `LOG_RECORD`（イベント/状態遷移）

---

## データセット構成（推奨）
```
training/data/datasets/<dataset_id>/
  meta.json
  frames.parquet
  lidar_scan.parquet   (任意)
  events.parquet       (任意)
```

### meta.json（必須）
- `dataset_id`
- `schema_version: "v1"`
- `source_logs`: 入力ログの一覧
- `time_range_ms`: [start, end]
- `lidar_frame`: 角度基準（0=前方）
- `notes`

---

## frames.parquet（必須）
**基準タイムスタンプ**: `ts_ms`（monotonic）

| カラム | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | フレーム時刻 |
| `best_heading_cdeg` | i16 | 0.01° | LIDAR_SUMMARY | 
| `best_distance_mm` | u16 | mm | LIDAR_SUMMARY |
| `min_distance_mm` | u16 | mm | LIDAR_SUMMARY |
| `min_distance_heading_cdeg` | i16 | 0.01° | LIDAR_SUMMARY |
| `confidence` | u8 | - | LIDAR_SUMMARY |
| `ax_mg..gz_mdps` | i16 | mg/mdps | IMU |
| `auto_active` | u8 | - | VEHICLE_STATUS |
| `faults` | u16 | bit | VEHICLE_STATUS |
| `speed_mm_s` | i16 | mm/s | VEHICLE_STATUS |
| `steer_cdeg` | i16 | 0.01° | VEHICLE_STATUS |
| `age_ms` | u16 | ms | VEHICLE_STATUS |
| `cmd_steer_cdeg` | i16 | 0.01° | DRIVE_CMD |
| `cmd_speed_mm_s` | i16 | mm/s | DRIVE_CMD |
| `cmd_ttl_ms` | u16 | ms | DRIVE_CMD |
| `cmd_source` | u8 | enum | DRIVE_CMD |

**欠損の扱い**
- センサ欠損は `null` にする
- 学習時は **前方補間 or 直近値ホールド**を選択

**サンプリング**
- `DRIVE_CMD` を基準（20-50Hz）
- 近傍 `ts_ms` のセンサ値を結合（許容遅延は±1周期）

---

## lidar_scan.parquet（任意）
- scan をチャンク再構成した**生データ**
- 1フレーム1スキャンを行として保存

| カラム | 型 | 説明 |
| --- | --- | --- |
| `ts_ms` | u32 | スキャン時刻 |
| `angles_cdeg[]` | i16[] | 角度配列 |
| `ranges_mm[]` | u16[] | 距離配列 |

---

## events.parquet（任意）
- MODE_SET/KILL/状態遷移などのイベントログ

| カラム | 型 | 説明 |
| --- | --- | --- |
| `ts_ms` | u32 | 時刻 |
| `event` | string | 例: MODE_SET, KILL |
| `value` | string | 付随情報 |

---

## 学習用ラベル
- `DRIVE_CMD` を教師信号とする
- `cmd_source` により **manual/ftg/ai** を区別

---

## バージョニング
- `schema_version` を固定（v1）
- 互換性を壊す変更は v2 へ
----------------------------------------

----------------------------------------
File: docs/ml/policy_plugin_v1.md
----------------------------------------
# Policy Plugin v1（タスクC）

## 目的
- racerd に **FTG/AI の差し替え口**を用意する
- AI失敗時は **FTGへフェイルセーフ** する

## 前提/参照
- `docs/interfaces/ipc_payloads_v1.md`
- `docs/interfaces/ipc_topics_v1.md`
- `docs/proto/overview.md`

---

## モード
- `FTG`: ルールベース（既定）
- `AI`: 学習モデルの推論結果を使用
- `SHADOW`: 推論は行うが **出力は適用しない**（ログのみ）

---

## インターフェース（提案）

### 入力（PolicyInput）
- `ts_ms`
- `LidarSummaryPayload`（必須）
- `LidarScanChunkPayload`（任意、再構成済み）
- `VehicleStatusPayload`（任意）
- `ImuSamplePayload`（任意）

### 出力（PolicyOutput）
- `DriveCmdPayload`（必須）
  - `source` は以下を使用
    - FTG: `SOURCE_FTG`
    - AI: `SOURCE_AI`
    - Shadow: `SOURCE_SHADOW`
- `valid`（bool）: falseなら FTGへフォールバック

---

## 実行制約
- 周期: 20-50ms
- 推論処理は **周期内に完了**（過走行禁止）
- 期限超過時は `valid=false` を返す

---

## フェイルセーフ
- `valid=false` or 例外時は **FTGへ即時フォールバック**
- AUTOでなければ `DriveCmd` を出さない
- `fault` が立っている場合は **停止指令**を優先

---

## ログ要件
- モード切替（FTG/AI/SHADOW）を必ず記録
- AIの推論結果と実適用コマンドの差分を記録

---

## DoD
- 1つのポリシー差し替えで走行が変わる
- SHADOWで **ログのみ生成** できる
- AI失敗時に **FTGで安全に走れる**
----------------------------------------

----------------------------------------
File: docs/ops/monitoring_thresholds_v1.md
----------------------------------------
# 性能監視の閾値 v1

## 目的
- 温度/CPU使用率の異常をログで検知できるようにする
- 運用時の暫定アラート基準を明文化する

## デフォルト閾値（metricsd）
- CPU温度
  - WARN: 70.00°C（`temp_warn_cdeg=7000`）
  - CRIT: 80.00°C（`temp_crit_cdeg=8000`）
- CPU使用率（permille）
  - WARN: 80%（`cpu_warn_permille=800`）
  - CRIT: 95%（`cpu_crit_permille=950`）

## 変更方法
`metricsd` 起動時にオプションを指定する。

```
metricsd \
  --interval-ms 1000 \
  --temp-warn-cdeg 6500 \
  --temp-crit-cdeg 7500 \
  --cpu-warn-permille 700 \
  --cpu-crit-permille 900
```

## 運用メモ
- WARNは減速や検証を促すための目安
- CRITは即時停止/再起動を検討する目安
- 実機での温度分布を観測した後、必ず再調整する

----------------------------------------

----------------------------------------
File: docs/ops/systemd_v1.md
----------------------------------------
# systemd運用・ログローテ手順 v1

## 目的
- RPi上で常駐プロセスを自動起動・再起動できるようにする
- ログローテーションを外部で管理し、ディスク肥大化を防ぐ

## 対象プロセス（例）
- `seriald`
- `metricsd`
- `racerd`（今後の本体）

## 前提
- バイナリは `rpi/build/apps/*/` に配置されていること
- ログ出力は `/var/log/robo-racer/` に集約すること

## systemd unit例

### seriald
`/etc/systemd/system/seriald.service`
```
[Unit]
Description=Robo Racer seriald
After=network.target

[Service]
Type=simple
ExecStart=/home/pi/robo-racer/rpi/build/apps/seriald/seriald \
  --dev /dev/ttyAMA0 \
  --baud 921600 \
  --sock /tmp/seriald.sock \
  --log /var/log/robo-racer/seriald.log
Restart=always
RestartSec=1

[Install]
WantedBy=multi-user.target
```

### metricsd
`/etc/systemd/system/metricsd.service`
```
[Unit]
Description=Robo Racer metricsd
After=network.target

[Service]
Type=simple
ExecStart=/home/pi/robo-racer/rpi/build/apps/metricsd/metricsd \
  --interval-ms 1000 \
  --log /var/log/robo-racer/metricsd.log \
  --sock /tmp/metrics.sock
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target
```

### racerd（将来）
`/etc/systemd/system/racerd.service`
```
[Unit]
Description=Robo Racer racerd
After=network.target seriald.service

[Service]
Type=simple
ExecStart=/home/pi/robo-racer/rpi/build/apps/racerd/racerd \
  --sock /tmp/seriald.sock
Restart=always
RestartSec=1

[Install]
WantedBy=multi-user.target
```

## 有効化/起動
```
sudo systemctl daemon-reload
sudo systemctl enable seriald metricsd
sudo systemctl start seriald metricsd
```

## 状態確認
```
systemctl status seriald
journalctl -u seriald -f
```

## ログローテ（logrotate）
`/etc/logrotate.d/robo-racer`
```
/var/log/robo-racer/*.log {
  daily
  rotate 7
  missingok
  compress
  delaycompress
  notifempty
  copytruncate
}
```

## 注意点
- `copytruncate` はプロセスを止めずにローテするための暫定策
- 高頻度ログは `interval-ms` を調整して量を抑える
- `seriald` のデバイス名は機体構成に合わせて調整する

----------------------------------------

----------------------------------------
File: docs/interfaces/ipc_topics_v1.md
----------------------------------------
# RPi内 IPC トピック v1（Interface Freeze）

## 方針
- RPi内IPCは **mcprotoフレーム（COBS+CRC）をそのまま運搬**する
- エンコード/デコード資産を共通化するため、`shared/proto` の型を正本とする
- **MAX_PAYLOAD=64** を前提に、サイズ超過データはチャンク化して送る

## 送受信経路（推奨）
- UDS `SOCK_SEQPACKET`
- sender/receiver は `mc::proto::PacketWriter/PacketReader` を利用

## トピック一覧（v1）
| Topic | mcproto Type | payload | 方向 | 目安頻度 | Drop方針 |
| --- | --- | --- | --- | --- | --- |
| LIDAR_SCAN | `IPC_LIDAR_SCAN` | `LidarScanChunkPayload` + data | lidard -> consumers | 5-20Hz | 古いscan_idを破棄 |
| LIDAR_SUMMARY | `IPC_LIDAR_SUMMARY` | `LidarSummaryPayload` | lidard/ftg -> consumers | 10-50Hz | 最新優先 |
| IMU_SAMPLE | `IPC_IMU_SAMPLE` | `ImuSamplePayload` | imu -> consumers | 50-200Hz | 最新優先 |
| DRIVE_CMD | `IPC_DRIVE_CMD` | `DriveCmdPayload` | racerd -> seriald | 20-100Hz | 最新優先 |
| VEHICLE_STATUS | `IPC_VEHICLE_STATUS` | `VehicleStatusPayload` | seriald -> consumers | 10-50Hz | 最新優先 |
| METRICS | `IPC_METRICS` | `MetricsPayload` | metricsd -> consumers | 1-5Hz | 最新優先 |
| LOG_RECORD | `IPC_LOG_RECORD` | `LogRecordPayload` | any -> logd | 1-100Hz | drop可（非同期） |

## チャンク仕様（LIDAR_SCAN）
- `LidarScanChunkPayload` の `chunk_index/chunk_count` で同一scanを再構成する
- `point_count` は **このチャンク内の点数**（1点=uint16 mm）
- `encoding=0` は `uint16` の距離配列（mm）
- 再構成は **同一scan_id** をキーに結合する

## サイズ制約
- 1フレームあたり `payload_len <= 64`
- チャンク化時の推奨: 1チャンク 20〜25点

## 互換性ルール
- 未知のtypeは破棄（必要ならログ）
- `payload_len` 不一致は破棄
- v1で追加するpayload構造体のサイズを変えない

----------------------------------------

----------------------------------------
File: docs/interfaces/protocol_rpi_esp32_v1.md
----------------------------------------
# RPi↔ESP32 プロトコル v1（Interface Freeze）

## 目的
RPi↔ESP32間の通信を「安全優先・低遅延・拡張可能」に保つため、v1の仕様を凍結する。
この文書は**運用上の契約**であり、変更は原則として v2 へ持ち越す。

## 正本（詳細仕様）
- `docs/proto/overview.md`
- `docs/proto/log_transport.md`

本書は上記の要点をまとめ、凍結範囲を明示する。

## 物理・フレーム仕様（v1固定）
- UART: 921600 bps / 8N1
- フレーミング: COBS + `0x00` 終端
- CRC: CRC16-CCITT-FALSE（header+payloadに対して計算）
- Header v1は9 bytes固定（MAGIC/VER/TYPE/FLAGS/SEQ/LEN）

## type一覧（v1固定）
- 0x01 `DRIVE`   : 操舵/速度/TTL
- 0x02 `KILL`    : 即時停止（ラッチ）
- 0x03 `MODE_SET`: MANUAL/AUTO 切替
- 0x04 `PING`    : 生存確認（ACK応答）
- 0x10 `LOG`     : ESP32ログ（level + text）
- 0x11 `STATUS`  : 状態通知
- 0x12 `HILS_STATE` : HILS観測（既存）
- 0x80 `ACK`     : ACK応答

## 安全ポリシー（凍結）
- **KILLは最優先**（どのモードでも即時停止、解除はローカル操作）
- **AUTO中は手動入力を無視**（介入はKILLのみ）
- **TTL失効で停止**（受理時刻基準、RPi時刻は不使用）

## 互換性ルール（v1）
- `ver != 1` のフレームは破棄する
- `len` が期待と合わない場合は破棄する
- 未知の `type` は破棄（ログのみ許可）
- 予約ビットは0固定（v1）
- 追加は **typeの拡張**で行い、既存type/サイズを変更しない

## 変更管理
- v1の変更は**原則禁止**。必要な変更は v2 として追加する
- v1の仕様差異は `docs/proto/*` を一次情報として判断する

----------------------------------------

----------------------------------------
File: docs/interfaces/ipc_payloads_v1.md
----------------------------------------
# RPi内 IPC Payload 定義 v1（Interface Freeze）

## 目的
RPi内IPCで運搬する payload の**フィールド/単位/意味**を凍結し、
タスクB（ルールベース/SLAM/安全）とタスクC（AI/データ/推論入口）の実装で解釈違いを防止する。

## 正本
- `shared/proto/include/mc_proto.h`（Single Source of Truth）
- `docs/interfaces/ipc_topics_v1.md`（トピック/頻度/Drop方針）

## 共通ルール（v1固定）
- IPCは **mcprotoフレーム（COBS+CRC）** をそのまま運ぶ
- 各payloadのサイズは **MAX_PAYLOAD=64** を超えない
- `*_le` のフィールドは**little-endian前提**（IPC内でも変換関数経由）
- `ts_ms` は **monotonic time**（`mc::core::Time::ms()`）
- 予約フィールド/予約ビットは **0固定**（v1）

---

## LIDAR_SCAN: `IPC_LIDAR_SCAN`
### `LidarScanChunkPayload`（14 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 取得時刻（monotonic） |
| `scan_id` | u16 | - | 同一スキャンを識別（wrap可） |
| `angle_start_cdeg` | i16 | 0.01° | チャンク先頭角度（車体前方=0） |
| `angle_step_cdeg` | i16 | 0.01° | 連続点の角度ステップ |
| `chunk_index` | u8 | - | 0..chunk_count-1 |
| `chunk_count` | u8 | - | スキャン内の総チャンク数 |
| `point_count` | u8 | - | このチャンクに含まれる点数 |
| `encoding` | u8 | - | 0=uint16 mm |

### 後続データ
- `point_count` 個の `uint16` 距離（mm）
- 角度は `angle_start_cdeg + angle_step_cdeg * i`

**角度の符号**
- v1: 車体前方=0、左回り（反時計回り）を正とする
- 実機座標が異なる場合は **lidard側で補正**する

---

## LIDAR_SUMMARY: `IPC_LIDAR_SUMMARY`
### `LidarSummaryPayload`（14 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 取得時刻（monotonic） |
| `best_heading_cdeg` | i16 | 0.01° | 推奨進行方向（操舵角と同符号） |
| `best_distance_mm` | u16 | mm | 推奨方向の余裕距離 |
| `min_distance_mm` | u16 | mm | 視野内の最小距離 |
| `min_distance_heading_cdeg` | i16 | 0.01° | 最小距離方向 |
| `confidence` | u8 | 0-255 | 推奨方向の信頼度（0=無効） |
| `flags` | u8 | bit | 予約（v1は0固定） |

---

## IMU_SAMPLE: `IPC_IMU_SAMPLE`
### `ImuSamplePayload`（16 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 取得時刻（monotonic） |
| `ax_mg` | i16 | mg | 加速度X |
| `ay_mg` | i16 | mg | 加速度Y |
| `az_mg` | i16 | mg | 加速度Z |
| `gx_mdps` | i16 | mdps | 角速度X |
| `gy_mdps` | i16 | mdps | 角速度Y |
| `gz_mdps` | i16 | mdps | 角速度Z |

---

## DRIVE_CMD: `IPC_DRIVE_CMD`
### `DriveCmdPayload`（12 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 生成時刻（monotonic） |
| `steer_cdeg` | i16 | 0.01° | 目標舵角 |
| `speed_mm_s` | i16 | mm/s | 目標速度 |
| `ttl_ms` | u16 | ms | 有効期限（ESP32受理時刻基準） |
| `source` | u8 | enum | 生成元（下表） |
| `flags` | u8 | bit | 予約（v1は0固定） |

**source（v1固定）**
- 0: `SOURCE_UNKNOWN`
- 1: `SOURCE_FTG`
- 2: `SOURCE_AI`
- 3: `SOURCE_SHADOW`
- 4: `SOURCE_REPLAY`
- 5: `SOURCE_MANUAL`

---

## VEHICLE_STATUS: `IPC_VEHICLE_STATUS`
### `VehicleStatusPayload`（14 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 受信時刻（monotonic） |
| `status` | `StatusPayload` | - | ESP32 STATUS をそのまま格納 |

### `StatusPayload`（10 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `seq_applied` | u8 | - | 最後に適用した `DRIVE.seq` 下位8bit |
| `auto_active` | u8 | - | 1=AUTO, 0=MANUAL |
| `faults_le` | u16 | bit | fault bitfield（LE） |
| `speed_mm_s_le` | i16 | mm/s | 現在速度（LE） |
| `steer_cdeg_le` | i16 | 0.01° | 現在舵角（LE） |
| `age_ms_le` | u16 | ms | 最終DRIVE受理からの経過（LE） |

---

## METRICS: `IPC_METRICS`
### `MetricsPayload`（16 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 取得時刻（monotonic） |
| `cpu_temp_cdeg` | u16 | 0.01°C | CPU温度 |
| `cpu_usage_permille` | u16 | ‰ | CPU使用率（0-1000） |
| `mem_used_kb` | u32 | KB | 使用メモリ |
| `mem_total_kb` | u32 | KB | 総メモリ |

---

## LOG_RECORD: `IPC_LOG_RECORD`
### `LogRecordPayload`（8 bytes）
| フィールド | 型 | 単位 | 説明 |
| --- | --- | --- | --- |
| `ts_ms` | u32 | ms | 生成時刻（monotonic） |
| `level` | u8 | - | ログレベル |
| `text_len` | u8 | bytes | 後続テキスト長 |
| `flags` | u8 | bit | 予約（v1は0固定） |
| `reserved` | u8 | - | 予約（0固定） |

### 後続データ
- `text_len` bytes の UTF-8 テキスト
- NUL終端はしない
----------------------------------------

----------------------------------------
File: platformio.ini
----------------------------------------
[platformio]
default_envs = esp32dev
src_dir = firmware/src
lib_dir = firmware/lib
test_dir = firmware/test

[env:esp32dev]
platform = espressif32@6.10.0
board = esp32dev
framework = arduino
monitor_speed = 115200
upload_speed = 921600
lib_extra_dirs = shared

; Bluepad32入りArduino-ESP32コアに差し替え
platform_packages =
  framework-arduinoespressif32@https://github.com/maxgerhardt/pio-framework-bluepad32/archive/refs/heads/main.zip
----------------------------------------

----------------------------------------
File: README.md
----------------------------------------

## Environment
- C++23
- Python >= 3.10

Set up the environment by executing the following:
```sh
make init
```

## File structure
```
./
├── .clang-format
├── .clang-tidy
├── .coderabbit.yaml
├── .github/
├── .gitignore
├── .gitmodules
├── Makefile             # 全体の管理
├── pyproject.toml       # 依存管理 (実機用と学習用をグループ分け定義)
├── platformio.ini       # ESP32用設定
├── uv.lock
├── compile_commands.json
├── robo-racer           # ホスト側バイナリ
├── firmware/            # [ESP32] マイコン用コード (C++)
│   ├── src/
│   ├── lib/
│   └── test/
├── rpi/                 # [Pi 5] 実機・学習用コード
│   ├── apps/            # 実機ユーティリティ
│   ├── build/           # ビルド成果物
│   ├── config/          # 共通設定
│   ├── lib/             # 共有ライブラリ
│   ├── models/          # 学習済みモデル
│   │   ├── production/  # 実機で使う最新モデル
│   │   └── archive/     # 過去のモデル
│   ├── src/             # 実機ランタイム
│   └── training/        # 学習・解析用ワークスペース
│       ├── data/        # 学習データ
│       ├── notebooks/   # 解析・試行錯誤用
│       └── src/         # 学習パイプラインのソースコード
├── test/                # テスト
├── docs/
├── tools/
├── playground/
├── cad/
└── logs/
```
----------------------------------------

----------------------------------------
File: .github/workflows/pull_request_size_checker.yml
----------------------------------------
name: pull_request_size_checker
on: pull_request
jobs:
  pull_request_size_checker:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Get Pull Request Size
        env:
          EXCLUDE_PATH: "node_modules|dist|playground|*.log|*.md|*.txt|*.json|*.yml|*.yaml|*.xml|*.png|*.jpg|*.jpeg|*.gif|*.svg|*.ico|*.pdf"
        run: |
          base_branch_name=${{ github.base_ref }}
          echo "base_branch_name: $base_branch_name"
          head_branch_name=${{ github.head_ref }}
          echo "head_branch_name: $head_branch_name"
          base_commit=$(git merge-base origin/$head_branch_name origin/$base_branch_name)
          echo "base_commit: $base_commit"
          head_commit=$(git rev-parse origin/$head_branch_name)
          echo "head_commit: $head_commit"
          add_lines=$(git diff $base_commit...$head_commit --numstat ":(exclude)*${EXCLUDE_PATH}*" | awk '{ additions+=$1 } END { printf "%d", additions }')
          delete_lines=$(git diff $base_commit...$head_commit --numstat ":(exclude)*${EXCLUDE_PATH}*" | awk '{ additions+=$2 } END { printf "%d", additions }')
          changed_lines=$(($add_lines+$delete_lines))
          echo "add_lines: $add_lines"
          echo "delete_lines: $delete_lines"
          echo "changed_lines: $changed_lines"
          changed_files=$(git diff $base_commit...$head_commit --name-only ":(exclude)*${EXCLUDE_PATH}*" | wc -l)
          echo "changed_files: $changed_files"
          echo "CHANGED_LINES=$changed_lines" >> $GITHUB_ENV
          echo "CHANGED_FILES=$changed_files" >> $GITHUB_ENV
      - name: Create comments
        env:
          CHANGED_LINES: ${{env.CHANGED_LINES}}
          CHANGED_FILES: ${{env.CHANGED_FILES}}
          PULL_REQUEST_LIMIT_LINES: 512
          PULL_REQUEST_LIMIT_FILES: 24
        run: |
          cat << EOF > comments
          プルリク差分行数 ${CHANGED_LINES} 行
          プルリク差分ファイル数 ${CHANGED_FILES} ファイル
          EOF
          if [ $((${CHANGED_LINES})) -gt $((${PULL_REQUEST_LIMIT_LINES})) ]; then
            echo "**[Warning]差分行数が多いので分割を検討してください！(LIMIT: ${PULL_REQUEST_LIMIT_LINES})**" >> comments;
          else
            echo "差分行数問題なし :+1:" >> comments
          fi
          if [ $((${CHANGED_FILES})) -gt $((${PULL_REQUEST_LIMIT_FILES})) ]; then
            echo "**[Warning]差分ファイル数が多いので分割を検討してください！(LIMIT: ${PULL_REQUEST_LIMIT_FILES})**" >> comments;
          else
            echo "差分ファイル数問題なし :+1:" >> comments
          fi
      - name: Post comments
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          URL: ${{ github.event.pull_request.html_url }}
        run:
          gh pr comment -F ./comments "${URL}"
----------------------------------------

----------------------------------------
File: .github/workflows/ci.yml
----------------------------------------
name: ci
on:
  push:
    branches: ["**"]
  pull_request:
jobs:
  test:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "latest"
      - name: Install build deps
        run: sudo apt-get update && sudo apt-get install -y build-essential
      - name: Sync Python deps
        run: uv sync --all-extras
      - name: Run tests
        run: uv run pytest -q test/rpi test/firmware
----------------------------------------

----------------------------------------
File: .github/copilot-instructions.md
----------------------------------------
# Copilot Instructions
## 基本ルール
- すべて日本語で記述してください
- ベストプラクティスの具体例を提示してください
- リファレンスや学習リソースの提案を積極的に行ってください
- スケーラビリティとパフォーマンスを重点的にチェックしてください

## コードレビュー専用指示
### レビューの基本方針
以下のプレフィックスを使用してレビューコメントを分類してください：
- `[must]` - 必須修正項目（セキュリティ、バグ、重大な設計問題）
- `[recommend]` - 推奨修正項目（パフォーマンス、可読性の大幅改善）
- `[nits]` - 軽微な指摘（コードスタイル、タイポ等）

### 重点チェック項目
1. **セキュリティ**: SQLインジェクション、XSS、認証・認可の不備
2. **パフォーマンス**: N+1問題、不要なループ、メモリリーク
3. **可読性**: 変数名、関数名、コメントの適切性
4. **保守性**: DRY原則、SOLID原則の遵守
5. **テスト**: テストケースの網羅性、エッジケースの考慮
6. **言語固有のベストプラクティス**: 各言語の推奨パターンに準拠しているか、非推奨・廃止予定のAPIや構文を使用していないかチェック

## 作業指示の場合の共通ルール
- 必要に応じて、ユーザに質問を行い、要求を明確にすること
- 作業完了後、作業内容とユーザが次に取れる行動を説明すること

## 専門作業タスク指示のルール
- 「調査」と指示された場合、都度 docs/reports に記載すること
  - 不明な点については、fetch mcp を使用して検索すること
  - ファイル名は `YYYYMMDDmmss-title.md` とする

- 「計画」と指示した場合、*plan.md に計画を記載する
  - 前回の内容が残っている場合は、読まずに消して構わない
  - コードベース / docs を読み込み、要件に関連性のあるファイルパスをすべて記載すること
  - 必要最小限の要件のみを記載すること
  - このフェーズで、コードを書いては絶対にいけない
  - ソースコードを読み込み、影響範囲や関連箇所の特定と考慮をする

- ユーザが「実装」と指示した場合、*plan.md に記載された内容に基づいて実装を行う
  - 必ず docs 内にステートメント管理を行ってから実装を始める
  - ステート管理には、必ず根拠を示した順番通りの並びにする必要がある
  - plan に記載されている以上の実装を絶対に行わない
  - ここでデバッグしない

- 「デバッグ」と指示された場合、直前のタスクのデバッグ「手順」のみを示す
----------------------------------------

----------------------------------------
File: AGENTS.md
----------------------------------------
# Repository Guidelines

## Project Structure & Module Organization
- `src/`: Raspberry Pi 5 runtime (Python) with `common/`, `control/`,
  `perception/`, and `driver/`.
- `firmware/`: ESP32 firmware (C++) with `src/` and shared `lib/`.
- `training/`: training and analysis workspace (`training/src`, notebooks, data).
- `config/`: shared YAML configuration such as `vehicle.yaml`.
- `models/`: trained model artifacts (`production/` and `archive/`).
- `cad/`: KiCad hardware design files.
- `test/`: pytest-based Python tests.
- `docs/`, `tools/`, `playground/`: documentation, utilities, and experiments.

## Build, Test, and Development Commands
- `make init`: set up git hooks and Python env via `uv`.
- Python-related setup and commands should use `uv` (e.g., `uv sync`,
  `uv run pytest -q`) rather than calling `pip` directly.
- `make pysync`: sync Python dependencies (`pyproject.toml` extras).
- `make activate`: open a shell with the repo virtualenv.
- `make test`: run pytest quietly against `test/`.
- `make all`: build the host C++ binary `bin` (if C++ sources exist).
- `platformio run`: build ESP32 firmware using `platformio.ini`.
- `platformio run -t upload`: flash firmware to the board.
- `make tidy` / `make check`: clang-tidy or cppcheck static analysis.

## Coding Style & Naming Conventions
- C++: formatted by `.clang-format` (tabs, width 4, 80 columns). Run
  `clang-format -i` or use `make tidy` for static checks.
- Python: lint/format with `ruff` (e.g., `uv run ruff check .`).
- Tests: name files `test_*.py` or `*_test.py`, and test functions `test_*`.

## Testing Guidelines
- Framework: `pytest` configured in `pyproject.toml`.
- Location: keep Python tests in `test/` with clear unit coverage.
- Run locally with `make test` or `uv run pytest -q`.

## Commit & Pull Request Guidelines
- Commit history uses short, imperative subject lines (no required prefix).
- PRs should include a brief summary, testing notes, and any firmware or model
  impact. Add logs, plots, or screenshots when behavior changes are visible.

## Configuration & Data Notes
- Keep shared parameters in `config/*.yaml` and review changes carefully.
- Keep ESP32 servo calibration constants (min/max/center pulse widths) in
  `firmware/src/config/Config.h` as macros or `static const` values, and read
  them from `ServoSteering::begin(...)`.
- Treat `training/data/` as local data; avoid committing large datasets.
- Update `models/production/` only for release-ready model artifacts.

## Development Workflow Expectations
- 開発を始める前に `docs/` 内の関連資料を必ず参照し、仕様を確認してください。
- 実装前には、進捗と差異を追跡するためのステート管理用 Markdown ファイル（例: `docs/planning/ftg_implementation_status.md`）を作成し、進行中/完了/再検討などの状態を記録した上で実装に入ってください。
- 実装が完了したら、対応するステートファイルをこまめに更新し、どの機能がどの状態かを明示してください。
- これらの追加メモやステート記録は、**日本語**で記述してください。
----------------------------------------

----------------------------------------
File: .coderabbit.yaml
----------------------------------------
language: "ja-JP"
early_access: false
reviews:
  profile: "chill"
  request_changes_workflow: false
  high_level_summary: true
  poem: false
  review_status: true
  collapse_walkthrough: false
  auto_review:
    enabled: true
    drafts: false
chat:
  auto_reply: true
----------------------------------------

